<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.sonatype.com/tmp/docbook/xml/4.5/docbookx.dtd">
<chapter id="assemblies">
  <title>Maven套件</title>

  <section>
    <title>简介</title>

    <para>Maven提供了可以用来创建大多数常见归档类型的插件，这些归档类型中的大部分可以由其它项目作为依赖使用。这样的插件有<acronym>JAR</acronym>,
    <acronym>WAR</acronym>, <acronym>EJB</acronym>, 以及
    <acronym>EAR</acronym>插件。如在<xref
    linkend="lifecycle" />中讨论的那样，这些插件对应于不同的项目打包类型，每种类型的构建过程都有微小的差别。虽然Maven有插件及自定义生命周期来支持标准的打包类型，但还是有些时候你需要创建一个自定义格式的归档文件或目录。这样的归档叫做Maven套件(Assembly)。</para>

    <para>在很多情况下你需要为你的项目构建自定义的归档。最常见的可能就是项目分发。单词“分发(distribution)”意思是，根据项目将会如何被使用，为不同的人（或项目）提供不同的东西。本质上来说，这些归档是为用户提供一种便捷的方式来安装，否则用户就必须使用项目的发布版本。一些情况下，这可能是构建一个带有应用服务器（如Jetty）的web应用。还有一些情况，可能是包裹了项目API文档，源码，和已编译字节码的JAR文件。当你构建项目的最终分发包的时候，Maven套件就十分有用了。以<xref
    linkend="repository-manager" />中介绍的Nexus为例，它是一个大型的包含了很多模块Maven项目的产品，而你从Sonatype下载的最终归档就是一个Maven套件。</para>

    <para>大多数情况下，Assembly插件十分适用于构建项目的分发包。然而，套件不一定就要是分发包；套件的目的是能让用户灵活的构建任意类型的自定义归档文件。本质上说，套件是为了弥补由项目打包类型所提供的标准归档格式的不足。当然，你可以完全写一个Maven插件来帮助生成你的自定义归档格式，同时创建生命周期映射和构件处理配置来告诉Maven如何部署。但大部分情况下，有了Assembly插件，这就完全没有必要了。该插件为创建自定义归档格式提供了普遍的支持，你不需要花很多时间来编写Maven插件代码。</para>
  </section>

  <section id="sect-assembly-basics">
    <title>Assembly基础</title>

    <para>在我们进一步讨论之前，最好先花几分钟来讲一下Assembly插件的两个主要目标：<varname>assembly:assembly</varname>，和<varname>single</varname>
    mojo。我用不同的方式列出这两个目标，是因为这样可以很好的体现它们不同的使用方式。<varname>assembly:assembly</varname>目标被设计成直接从命令行调用，它永远不应该被绑定到生命周期阶段。反之，<varname>single</varname>
    mojo被设计成作为你每日构建的一部分，应该被绑定到项目生命周期的某个阶段。</para>

    <para>有这种区别的主要理由是，<varname>assembly:assembly</varname>目标在Maven术语中是一个聚合mojo；意思是，无论有多少个模块正被构建，该mojo在一个构建中最多被运行一次。它从根项目的中提取配置——通常是顶层<acronym>POM</acronym>或者命令行目录的<acronym>POM</acronym>。而在绑定到生命周期后，一个聚合mojo就会有很多讨厌的副作用。它会强迫<varname>package</varname>生命周期阶段提前运行，从而造成在一次构建中<varname>package</varname>阶段被执行了两次。</para>

    <para>由于<varname>assembly:assembly</varname>目标是一个聚合mojo，在多模块构建中它造成了一些问题，它应当在命令行中作为单独的mojo被调用。永远不要将<varname>assembly:assembly</varname>目标绑定到生命周期阶段中。<varname>assembly:assembly</varname>是Assembly插件最原始的目标，不是被设计成用作项目标准构建过程的一部分的。但很显然，为一个项目生成套件归档合情合理，因此开发了<varname>single</varname>
    mojo。该mojo假设它被绑定到了构建过程的正确部分，因此它能访问它在大型模块Maven项目生命周期中执行需要的项目文件及构件。在一个多模块环境中，它会执行很多次，因为它被绑定到了不同模块的<acronym>POM</acronym>上。不像<varname>assembly:assembly</varname>，<varname>single</varname>从来不会强制在它之前执行另外一个生命周期阶段。</para>

    <para>除了上述的两项，Assembly插件还提供了很多其它目标；然后，讨论这些mojo超出了本章范围，主要是由于它们是为一切奇怪或者过时的用例服务的，基本上不会被用到。只要可能，你都应该坚持在命令行生成套件时使用<varname>assembly:assembly</varname>，在绑定到生命周期阶段生成套件时使用<varname>single</varname>。</para>

    <section>
      <title>预定义的套件描述符</title>

      <para>虽然很多人选择创建他们自己的归档解决方案——称之为套件描述符——但这不是必须的。Assembly插件为一些常用的归档类型提供了内置的描述符，你可以不写
      一行配置就马上使用。以下的套件描述符是由Maven Assembly插件预定义的：</para>

      <variablelist>
        <varlistentry>
          <term><varname>bin</varname></term>

          <listitem>
            <para>假设一个项目构建了一个jar作为它的主构件，<varname>bin</varname>
            描述符用来包裹该主构件和项目的<filename>LICENSE</filename>,
            <filename>README</filename>,
            和<filename>NOTICE</filename>文件。我们可以认为这是一个完全自包含项目的最可能小的二进制分发包。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>jar-with-dependencies</varname></term>

          <listitem>
            <para><varname>jar-with-dependencies</varname>描述符构建一个带有主项目jar文件和所有项目运行时依赖未解开内容的<acronym>JAR</acronym>归档文件。外加上适当的<varname>Main-Class</varname>
            Manifest条目（在下面的“插件配置”讨论），该描述符可以为你的项目生成一个自包含的，可运行的jar，即使该项目含有依赖。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>project</varname></term>

          <listitem>
            <para><varname>project</varname>描述符会简单的将你文件系统或者版本控制中的项目目录结构整个的归档。当然，target目录会被忽略，目录中的版本控制元数据文件如<filename>.svn</filename>和<filename>CVS</filename>目录也会被忽略。基本上，该描述符的目的是创建一个解开后就立刻能由Maven构建的归档。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>src</varname></term>

          <listitem>
            <para><varname>src</varname>描述符生成一个包含你项目源码，<filename>pom.xml</filename>文件，以及项目根目录中所有<filename>LICENSE</filename>，<filename>README</filename>，和<filename>NOTICE</filename>文件的归档。它类似于<varname>project</varname>描述符，大部分情况下能生成一个可以被Maven构建的归档。然而，由于它假设所有的源文件和资源文件都位于标准的<filename>src</filename>目录下，它就可能遗漏那些非标准的目录和文件，而这些文件往往对构建起着关键作用。</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section>
      <title>构建一个套件Building an Assembly</title>

      <para>Assembly插件可以以两种方式运行：你可以直接在命令行调用，或者你可以通过绑定到生命周期阶段将其配置成标准构建过程的一部分。直接调用自有它的用处，主要是为了那些一次性，不属于你项目核心分发包的套件。大部分情况下，你可能以标准项目构建过程一部分的形式生成套件。这么做，不管你的项目被安装还是部署，都能包含你自定义的套件，从而它们也一直是对用户可用的。</para>

      <para>作为一个直接调用Assembly插件的例子，考虑你想要将你的项目复制一份给别人让他们也能从源码构建。你需要同时包含源码，而不仅仅是一个最终的产品。而且你只是偶尔需要这么做，因此往你的<abbrev>POM</abbrev>中添加配置显得没有必要。你可以使用如下的命令：</para>

      <screen>$ <command>mvn -DdescriptorId=project assembly:single</command> 
...
[INFO] [assembly:single] 
[INFO] Building tar : /Users/~/mvn-examples-1.0/assemblies/direct-invocation/\
                      target/direct-invocation-1.0-SNAPSHOT-project.tar.gz 
[INFO] Building tar : /Users/~/mvn-examples-1.0/assemblies/direct-invocation/\
                      target/direct-invocation-1.0-SNAPSHOT-project.tar.bz2
[INFO] Building zip: /Users/~/mvn-examples-1.0/assemblies/direct-invocation/\
                      target/direct-invocation-1.0-SNAPSHOT-project.zip
...</screen>

      <para>假如你想要从你的项目生成一个可运行的<acronym>JAR</acronym>。如果你的项目完全是自包含的，没有任何依赖，那么使用<acronym>JAR</acronym>插件的archive配置就能做到。但是，大部分项目都有依赖，而且这些依赖需要被引入到可运行<acronym>JAR</acronym>文件中。这种情况下，每次<acronym>JAR</acronym>被安装或部署的时候你都要确认可运行<acronym>JAR</acronym>包含了这些依赖。</para>

      <para>假设该项目的main类是<classname>org.sonatype.mavenbook.App</classname>，如下的<acronym>POM</acronym>配置将创建一个可运行的<acronym>JAR</acronym>：</para>

      <example>
        <title>可运行JAR的套件描述符</title>

        <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt;

  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
  &lt;artifactId&gt;executable-jar&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;name&gt;Assemblies Executable Jar Example&lt;/name&gt;
  &lt;url&gt;http://sonatype.com/book&lt;/url&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;commons-lang&lt;/groupId&gt;
      &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;
      &lt;version&gt;2.4&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
 &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.2-beta-2&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;create-executable-jar&lt;/id&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;single&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;descriptorRefs&gt;
                &lt;descriptorRef&gt;
                  jar-with-dependencies
                &lt;/descriptorRef&gt;
              &lt;/descriptorRefs&gt;
              &lt;archive&gt;
                &lt;manifest&gt;
                  &lt;mainClass&gt;org.sonatype.mavenbook.App&lt;/mainClass&gt;
                &lt;/manifest&gt;
              &lt;/archive&gt;
           &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;</programlisting>
      </example>

      <para>以上配置中有两点我们要注意。首先，我们不再像上次那样使用<sgmltag>descriptorId</sgmltag>参数，这里我们使用<sgmltag>descriptorRefs</sgmltag>配置。这样可以允许在同一次Assembly插件执行过程中使用多个套件类型，同时还能保持不要引入太多额外的配置。第二，<sgmltag>configuration</sgmltag>下的<sgmltag>archive</sgmltag>元素设置最终JAR的<varname>Main-Class</varname>
      manifest属性。该配置在所有创建<acronym>JAR</acronym>文件的插件中都很常见，如由默认打包类型使用的<acronym>JAR</acronym>插件。</para>

      <para>现在，你可以通过执行<command>mvn
      package</command>生成可运行的<acronym>JAR</acronym>文件。之后，我们看一下target目录的内容，验证一下可运行<acronym>JAR</acronym>已经被生成了。最后，为了证明我们真的有可运行<acronym>JAR</acronym>了，那就运行一下吧。</para>

      <screen>$ <command>mvn package</command>
... (output omitted) ...
[INFO] [jar:jar]
[INFO] Building jar: /Users/~/mvn-examples-1.0/assemblies/executable-jar/target/\
                     executable-jar-1.0-SNAPSHOT.jar
[INFO] [assembly:single {execution: create-executable-jar}]
[INFO] Processing DependencySet (output=)
[INFO] Building jar: /Users/~/mvn-examples-1.0/assemblies/executable-jar/target/\
                     executable-jar-1.0-SNAPSHOT-jar-with-dependencies.jar
... (output omitted) ...
$ <command>ls -1 target</command>
... (output omitted) ...
executable-jar-1.0-SNAPSHOT-jar-with-dependencies.jar
executable-jar-1.0-SNAPSHOT.jar
... (output omitted) ...
$ <command>java -jar \
        target/executable-jar-1.0-SNAPSHOT-jar-with-dependencies.jar </command>
Hello, World!</screen>

      <para>从以上的输出你可以看到，标准的项目构建现在生成了一个新的额外的构件。这个新的构件有一个名为<varname>jar-with-dependencies</varname>的分类器。最后，我们验证了这个新的<acronym>JAR</acronym>是可运行的，运行这个<acronym>JAR</acronym>会产生我们期望的输出“Hello,
      World!”。</para>
    </section>

    <section>
      <title>套件作为依赖</title>

      <para>当你将生成套件作为你标准构建过程的一部分的时候，这些套件归档会被附着到你项目的主构件上。意思是，当它们会随着主构件的安装和部署一起被安装或部署，而且它们会以差不多相同的方式被解析。每个套件构件会被给予同样的基本坐标（<varname>groupId</varname>,
      <varname>artifactId</varname>, 和
      <varname>version</varname>）。但是，由于这些构件是附件，在Maven中意思是，它们是基于主项目构建的某些方面派生出来的。这里是一些例子，<varname>source</varname>套件包含了项目的原始输入，<varname>jar-with-dependencies</varname>套件包含了项目的类及依赖。由于这种派生的性质，附属构件就能精确的规避一个项目，或一个构件的Maven需求。</para>

      <para>由于套件（通常）是附属构件，除了标准的构件坐标，它们还必须拥有一个分类器来和主构件加以区分。默认情况下，该分类器就是套件描述符的定义符。当如上例使用内置的套件描述符的时候，套件描述符的定义符和<sgmltag>descriptorRef</sgmltag>中对应使用的定义符是一样的。</para>

      <para>在你伴随着项目的主构件部署了一个套件后，如何才能在其它项目中使用这个套件呢？答案很简单。回忆一下<xref
      linkend="sect-maven-coordinates" />和<xref
      linkend="sect-more-coordinates" />中讨论的项目依赖，一个项目依赖于另外一个项目的时候，它使用项目坐标四个元素的组合：<varname>groupId</varname>,
      <varname>artifactId</varname>, <varname>version</varname>, 和
      <varname>packaging</varname>。在<xref
      linkend="sect-platform-classifier" />中，同一个项目的构件有针对多个平台的变种，该项目设置了值为<varname>win</varname>或<varname>linux</varname>的<varname>classifier</varname>元素，以为目标平台选择合适的依赖构件。使用项目的坐标加上套件被安装或部署时的分类器，我们就可以将套件设为依赖。如果套件不是一个<acronym>JAR</acronym>归档，我们还需要声明其类型。</para>
    </section>

    <section>
      <title>通过套件依赖组装套件</title>

      <para>起这么一个使人困惑的名字是怎么回事？让我们建立这样一个能解释组装套件(assembling
      assemblies)概念的场景。假设你想要创建一个归档，它包含了一些项目套件。再假设你有一个多模块构建，并且想要部署一个包含很多相关项目套件的套件。在本节的例子中，我们要为一组通常一起被使用的项目创建一个“可构建”的项目目录。为了简便，我们要重用前面讨论的两个<varname>project</varname>和<varname>jar-with-dependencies</varname>内置套件描述符。在这个特定的例子中，假设每个项目在主要的<acronym>JAR</acronym>构件之外还创建<varname>project</varname>套件。假设这个多模块构建中每个项目都使用<varname>project</varname>
      <sgmltag>descriptorRef</sgmltag>绑定到<varname>package</varname>阶段的<varname>single</varname>目标。每个模块都会从顶层的<filename>pom.xml</filename>中继承该配置，其<sgmltag>pluginManagement</sgmltag>元素如<xref
      linkend="ex-top-pom-assembly" />所示：</para>

      <example id="ex-top-pom-assembly">
        <title>在顶层POM中配置项目套件</title>

        <programlisting language="xml">&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;pluginManagement&gt;
      &lt;plugins&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
          &lt;version&gt;2.2-beta-2&lt;/version&gt;
          &lt;executions&gt;
            &lt;execution&gt;
              &lt;id&gt;create-project-bundle&lt;/id&gt;
              &lt;phase&gt;package&lt;/phase&gt;
              &lt;goals&gt;
                &lt;goal&gt;single&lt;/goal&gt;
              &lt;/goals&gt;
              &lt;configuration&gt;
                &lt;descriptorRefs&gt;
                  &lt;descriptorRef&gt;project&lt;/descriptorRef&gt;
                &lt;/descriptorRefs&gt;
              &lt;/configuration&gt;
            &lt;/execution&gt;
          &lt;/executions&gt;
        &lt;/plugin&gt;
      &lt;/plugins&gt;
    &lt;/pluginManagement&gt;
  &lt;/build&gt;
  ...
&lt;/project&gt;</programlisting>
      </example>

      <para>每个项目的<acronym>POM</acronym>都使用很小的一部分插件声明引用了<xref
      linkend="ex-top-pom-assembly" />中的插件配置，如<xref
      linkend="ex-activating-assembly" />所示：</para>

      <example id="ex-activating-assembly">
        <title>在子项目中激活Assembly插件配置</title>

        <programlisting language="xml">&lt;build&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
    &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/build&gt;
</programlisting>
      </example>

      <para>要生成一组项目套件，从顶层目录运行<command>mvn
      install</command>。你会看到Maven使用分类器将套件安装到你的本地仓库。</para>

      <screen>$ <command>mvn install</command>
...
[INFO] Installing ~/mvn-examples-1.0/assemblies/as-dependencies/project-parent/\
                  second-project/target/second-project-1.0-SNAPSHOT-project.tar.gz to 
       ~/.m2/repository/org/sonatype/mavenbook/assemblies/second-project/1.0-SNAPSHOT/\
                  second-project-1.0-SNAPSHOT-project.tar.gz
...
[INFO] Installing ~/mvn-examples-1.0/assemblies/as-dependencies/project-parent/\
                  second-project/target/second-project-1.0-SNAPSHOT-project.tar.bz2 to 
       ~/.m2/repository/org/sonatype/mavenbook/assemblies/second-project/1.0-SNAPSHOT/\
                  second-project-1.0-SNAPSHOT-project.tar.bz2
...
[INFO] Installing ~/mvn-examples-1.0/assemblies/as-dependencies/project-parent/\
                  second-project/target/second-project-1.0-SNAPSHOT-project.zip to 
       ~/.m2/repository/org/sonatype/mavenbook/assemblies/second-project/1.0-SNAPSHOT/\\
                  second-project-1.0-SNAPSHOT-project.zip
...</screen>

      <para>当你运行install的时候，Maven会将每个项目的主构件和每个套件复制到你的本地Maven仓库中。现在本地的所有其它项目都可以使用依赖引用这些构件。如果你最终的目的是创建一个包含多个多模块项目构件的软件包，你可以创建一个项目，它以依赖的形式引入其它项目的套件。这个包裹项目（贴切的命名为project-bundle）负责创建一个最终的包裹套件。这个包裹项目的<acronym>POM</acronym>如<xref
      linkend="ex-bundling-pom" />所示：</para>

      <example id="ex-bundling-pom">
        <title>套件包裹项目的POM</title>

        <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
  &lt;artifactId&gt;project-bundle&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;pom&lt;/packaging&gt;
  &lt;name&gt;Assemblies-as-Dependencies Example Project Bundle&lt;/name&gt;
  &lt;url&gt;http://sonatype.com/book&lt;/url&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
      &lt;artifactId&gt;first-project&lt;/artifactId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
      &lt;classifier&gt;project&lt;/classifier&gt;
      &lt;type&gt;zip&lt;/type&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
      &lt;artifactId&gt;second-project&lt;/artifactId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
      &lt;classifier&gt;project&lt;/classifier&gt;
      &lt;type&gt;zip&lt;/type&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.2-beta-2&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;bundle-project-sources&lt;/id&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;single&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;descriptorRefs&gt;
                &lt;descriptorRef&gt;
                  jar-with-dependencies
                &lt;/descriptorRef&gt;
              &lt;/descriptorRefs&gt;
            &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</programlisting>
      </example>

      <para>该包裹项目的<acronym>POM</acronym>引用了来自于<varname>first-project</varname>和<varname>second-project</varname>的两个套件。这个POM指定了一个值为<varname>project</varname>的分类器和一个值为<varname>zip</varname>的类型，而不是直接引用过了项目的主构件。这告诉Maven去解析<varname>project</varname>套件创建的<acronym>ZIP</acronym>归档。注意包裹项目生成了一个<varname>jar-with-dependencies</varname>套件。<varname>jar-with-dependencies</varname>并不创建一个非常简洁的套件，而是简单的创建一个包含所有依赖拆解内容的<acronym>JAR</acronym>文件。<varname>jar-with-dependencies</varname>实际上做的事情是：告诉Maven拿来所有依赖，将其拆解，然后创建一个包含当前项目所有输出的归档。在这个项目中，它的效果就是创建一个带有<varname>first-project</varname>和<varname>second-project</varname>套件拆解内容的<acronym>JAR</acronym>文件，</para>

      <para>该样例展示了如何不用自定义套件描述符就能联合Maven
      Assembly插件的基本能力。它实现了创建一个包含多模块项目内容的单独归档这样一个目的。这个时候，<varname>jar-with-dependencies</varname>仅仅是一个存储格式，因此我们没必要指定<varname>Main-Class</varname>的manifest属性。我们只要正常的构建<varname>project-bundle</varname>项目就能得到套件。</para>

      <screen>$ <command>mvn package</command>
...
[INFO] [assembly:single {execution: bundle-project-sources}]
[INFO] Processing DependencySet (output=)
[INFO] Building jar: ~/downloads/mvn-examples-1.0/assemblies/as-dependencies/\
        project-bundle/target/project-bundle-1.0-SNAPSHOT-jar-with-dependencies.jar
</screen>

      <para>要验证project-bundle套件是否包含了所有依赖套件的拆解内容，运行<command>jar
      tf</command>：</para>

      <screen>$ <command>java tf \
  target/project-bundle-1.0-SNAPSHOT-jar-with-dependencies.jar</command>
...
first-project-1.0-SNAPSHOT/pom.xml
first-project-1.0-SNAPSHOT/src/main/java/org/sonatype/mavenbook/App.java
first-project-1.0-SNAPSHOT/src/test/java/org/sonatype/mavenbook/AppTest.java
...
second-project-1.0-SNAPSHOT/pom.xml
second-project-1.0-SNAPSHOT/src/main/java/org/sonatype/mavenbook/App.java
second-project-1.0-SNAPSHOT/src/test/java/org/sonatype/mavenbook/AppTest.java</screen>

      <para>阅读本节内容之后，标题应该容易理解了。我们使用了一个包裹项目，它依赖于两个项目的套件，然后我们再根据这两个项目的套件装配出一个最终的套件。</para>
    </section>
  </section>

  <section>
    <title>套件描述符概述</title>

    <para>当<xref
    linkend="sect-assembly-basics" />中介绍的标准套件描述符不够的时候，你就需要自定义你自己的套件描述符。套件描述符是一个定义了套件结构和内容的XML文档。</para>

    <figure>
      <title>套件描述符图解</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="figs/web/assemblies_descriptor.png" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>套件描述符包含五个主要的小节，以及两个额外的小节：一个叫做组件描述符，用来指定标准的套件描述符片段，另一个用来指定自定义的文件处理类，以帮助管理套件生产过程。</para>

    <variablelist>
      <varlistentry>
        <term>基本配置</term>

        <listitem>
          <para>该小节包含了所有套件需要的信息，还有一些关于整个归档格式的额外配置选项，如所有归档项使用的基础路径。为了使套件描述符有效，你必须至少指定套件id，至少一种格式，以及至少一个如上所示的其它小节。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>文件信息</term>

        <listitem>
          <para>套件描述符这个片段中的配置应用于文件系统中该项目目录结构中特定的文件。这个片段包含了两个主要部分：<sgmltag>files</sgmltag>和<sgmltag>fileSets</sgmltag>。你可以使用<sgmltag>files</sgmltag>和<sgmltag>fileSets</sgmltag>来控制套件中文件的权限，从套件中包含或者排除文件。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>依赖信息</term>

        <listitem>
          <para>几乎任意大小的所有的项目都依赖于其它项目。在创建分发归档的时候，项目依赖通常被包含在最终产品套件中。该小节管理依赖被包含在最终归档中的方式。该小节允许你依赖是否被拆解，是直接添加到<filename>lib/</filename>目录中，还是映射至新的文件名。该小节也允许你控制套件中依赖的权限，以及哪些依赖被包含在套件中。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>仓库信息</term>

        <listitem>
          <para>有时，将构建一个项目必要的所有构件分隔开来很有用，它们是否是依赖构件，依赖构件的<acronym>POM</acronym>，或者甚至是一个项目本身POM的祖先（你的父<acronym>POM</acronym>，父<acronym>POM</acronym>的父<acronym>POM</acronym>，等等）。该小节允许你通过各种配置选项，在套件中包含一个或者多个构件仓库目录，然而Assembly插件没有能力引入在这些仓库中的插件构件。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>模块信息</term>

        <listitem>
          <para>套件描述符的这一小节允许你在装配自定义归档的时候利用父子关系，以包含你项目模块的源文件，构件，和依赖。这是套件描述符中最复杂的小节，因为它允许你以两种方式操作模块和子模块：以一系列<sgmltag>fileSets</sgmltag>（通过<sgmltag>sources</sgmltag>小节）或者以一系列<sgmltag>dependencySets</sgmltag>（通过<sgmltag>binaries</sgmltag>小节）。</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>

  <section>
    <title>套件描述符</title>

    <para>本节作为一个套件描述符的教程，包含了一些开发自定义套件描述符的指南。Assembly插件是Maven世界中最大的插件之一，也是最灵活的插件之一。</para>

    <section>
      <title>套件描述符中的属性引用</title>

      <para>任何在<xref
      linkend="sect-properties" />中讨论的属性都可以在一个套件描述符中引用。在套件描述符被Maven使用之前，它首先会根据<acronym>POM</acronym>及构建环境的信息修改一些对应的值。所有运行时<acronym>POM</acronym>中可修改的值，同样适用于套件描述符，包括<acronym>POM</acronym>属性，<acronym>POM</acronym>元素的值，系统属性，用户定义的属性，以及操作系统环境变量。</para>

      <para>这一插值阶段的例外是<sgmltag>outputDirectory</sgmltag>，<sgmltag>outputDirectoryMapping</sgmltag>，和<sgmltag>outputFileNameMapping</sgmltag>元素。保持它们原始的值是为了能在解析构件特定的——或者组件特定的信息的时候，能得到正确的值。</para>

      <!--This last paragraph is not clear.
The reason these are held back in their raw form is to allow artifact- or module-specific information
 to be applied when resolving expressions in these values, on a per-item basis.-->
    </section>

    <section>
      <title>必须的套件信息</title>

      <para>对于每个套件来说，有两个重要的信息是必须的：id，和一个要生成的归档格式的列表。实际情况中，至少还需要其它一小节描述符的内容——因为大部分归档格式如果没有可引入的文件，将一文不值，同时，如果没有一个id和至少一种格式，就不会产生任何归档。id首先被用到归档的文件名中，同时它还是归档构件分类器名称一部分。格式（format）字符串同时也控制archiver-component实例去创建最终的套件归档。所有套件描述符必须包含一个id和至少一个format：</para>

      <example id="ex-required-assembly">
        <title>必须的套件描述符元素</title>

        <programlisting language="xml">&lt;assembly&gt;
  &lt;id&gt;bundle&lt;/id&gt; 
  &lt;formats&gt;
    &lt;format&gt;zip&lt;/format&gt;
  &lt;/formats&gt;
  ...
&lt;/assembly&gt;</programlisting>
      </example>

      <para>套件id可以是任意不包含空格的字符串。标准的实践是使用破折号（-）来分隔单词。如果你要创建一个拥有有趣的唯一打包结构（interesting
      unique package
      structure）的套件，那么其id就会是interesting-unique-package。同时，套件描述符还支持多种格式，允许你轻松创建.zip,
      .tar.gz,和.tar.bz2等熟悉分发归档。如果你没有找到你需要的归档格式，你也可以创建自定义的格式。自定义格式在<xref
      linkend="sect-componentDescriptors" />中讨论。Assembly插件原生支持多种归档格式，包括：</para>

      <itemizedlist>
        <listitem>
          <para><varname>jar</varname></para>
        </listitem>

        <listitem>
          <para><varname>zip</varname></para>
        </listitem>

        <listitem>
          <para><varname>tar</varname></para>
        </listitem>

        <listitem>
          <para><varname>bzip2</varname></para>
        </listitem>

        <listitem>
          <para><varname>gzip</varname></para>
        </listitem>

        <listitem>
          <para><varname>tar.gz</varname></para>
        </listitem>

        <listitem>
          <para><varname>tar.bz2</varname></para>
        </listitem>

        <listitem>
          <para><varname>rar</varname></para>
        </listitem>

        <listitem>
          <para><varname>war</varname></para>
        </listitem>

        <listitem>
          <para><varname>ear</varname></para>
        </listitem>

        <listitem>
          <para><varname>sar</varname></para>
        </listitem>

        <listitem>
          <para><varname>dir</varname></para>
        </listitem>
      </itemizedlist>

      <para>id和format至关重要，因为它们将成为套件归档坐标的一部分。<xref
      linkend="ex-required-assembly" />中的例子会创建一个打包类型为zip，分类器为bundle的套件构件。</para>
    </section>
  </section>

  <section>
    <title>控制一个套件的内容</title>

    <para>理论上，只有id和format才是一个合法套件描述符必要的元素；然而，对于大多数归档来说，如果输出归档中没有包含一个文件，该归档就会失效。套件描述符中，有五个主要的部分来定义哪些文件被包含到套件中，他们是：files,
    fileSets, dependencySets, repositories,
    和moduleSets。为了最有效的探究这些部分，我们首先讨论最基本的部分：files。然后，我们接着讨论两个最常用的部分：fileSets和dependencySets。在你理解了它们如何工作之后，就能更轻松的理解repositories和moduleSets。</para>

    <section>
      <title><sgmltag>Files</sgmltag> 元素</title>

      <para>files元素是套件描述符中最简单的部分，它被设计成定义那些相对与你项目目录的路径。使用该元素，你就可以完全控制哪些文件被包含到你的套件中，它们如何被命名，以及它们在归档中的位置。</para>

      <example id="ex-assembly-files">
        <title>使用files在一个套件中包含一个JAR文件</title>

        <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;files&gt;
    &lt;file&gt;
      &lt;source&gt;target/my-app-1.0.jar&lt;/source&gt;
      &lt;outputDirectory&gt;lib&lt;/outputDirectory&gt;
      &lt;destName&gt;my-app.jar&lt;/destName&gt;
      &lt;fileMode&gt;0644&lt;/fileMode&gt;
    &lt;/file&gt;
  &lt;/files&gt;
  ...
&lt;/assembly&gt;</programlisting>
      </example>

      <para>假设你要构建一个名为my-app的版本为1.0的项目，<xref
      linkend="ex-assembly-files" />会将你项目的JAR文件包含到套件的lib/目录下，同时除去了文件名的版本部分，使最终的文件名为my-app.jar。该描述符会让这个JAR文件对于所有人可读，对于拥有者可写（这就是0664模式的意思，这里使用了Unix四位十进制数的权限标记）。要了解更多关于fileMode的值的格式的信息，请看维基百科的解释<ulink
      url="http://en.wikipedia.org/wiki/File_system_permissions#Octal_notation_and_additional_permissions">four-digit
      Octal notation</ulink>。</para>

      <para>如果你知道所有需包含的文件的完整列表，你就可以使用file条目构建了一个十分复杂的套件。即使在构建开始之前你不知道这个完整的列表，你也可以使用一个自定义的Maven插件来发现这个列表，然后生成如上例中的套件描述符。files元素能给你提供细粒度的文件控制，包括每个文件的权限，位置及名称，但是在一个大型的归档中，为所有文件罗列file元素就比较繁琐了。因此大部分情况下，你需要使用fileSets针对一组文件进行操作。余下的四个文件包含配置元素，用来帮助你包含整个一组匹配某个特定标准的文件。</para>
    </section>

    <section>
      <title><sgmltag>FileSets</sgmltag> 元素</title>

      <para>与files元素类似，fileSets应用于那些相对于你的项目结构有一个明确位置的文件。然而，和files元素不同的是，fileSets描述一组文件，这组文件由文件模式或者路径模式定义，判断文件在总体目录结构中的位置是否匹配该模式。最简单的fileSet仅仅指定文件所处的位置：</para>

      <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;fileSets&gt;
    &lt;fileSet&gt;
      &lt;directory&gt;src/main/java&lt;/directory&gt;
    &lt;/fileSet&gt;
  &lt;/fileSets&gt;
  ...
&lt;/assembly&gt;</programlisting>

      <para>这个文件集合仅仅包含src/main/java目录下的内容。它利用了很多该元素的默认设置，这里我简要的介绍一下。</para>

      <para>首先，你会注意到我们没有指定匹配的文件集合应该位于套件中的什么位置。默认情况，目标输出目录（由outputDirectory指定）和源文件目录（在这里，是src/main/java）是一样的。此外，我们没有指定任何包含和排除模式。当它们为空的时候，fileSet假设会包含整个源文件目录，并伴随着一些重要的例外。这一规则的例外主要是为了排除源码控制元数据文件和目录，这一例外由userDefaultExclludes标记控制，其值默认为true。当userDefaultExcludes被开启的时候，所有如.svn/和CVS/的目录都会被排除在套件归档之外。<xref
      linkend="sect-default-excludes" />显示了一个详细的默认排除模式的列表。</para>

      <para>如果想要更多的对于文件集的控制，我们可以进一步显式的指定。<xref
      linkend="ex-explicit-fileSet" />展示了一个指定所有默认值的fileSet元素。</para>

      <example id="ex-explicit-fileSet">
        <title>使用fileSet包含文件</title>

        <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;fileSets&gt;
    &lt;fileSet&gt;
      &lt;directory&gt;src/main/java&lt;/directory&gt;
      &lt;outputDirectory&gt;src/main/java&lt;/outputDirectory&gt;
      &lt;includes&gt;
        &lt;include&gt;**&lt;/include&gt;
      &lt;/include&gt;
      &lt;useDefaultExcludes&gt;true&lt;/useDefaultExcludes&gt;
      &lt;fileMode&gt;0644&lt;/fileMode&gt;
      &lt;directoryMode&gt;0755&lt;/directoryMode&gt;
    &lt;/fileSet&gt;
  &lt;/fileSets&gt;
  ...
&lt;/assembly&gt;</programlisting>
      </example>

      <para>includes元素使用了一系列include元素，后者包含了路径模式。这些模式可能包含一些通配符，“**”表示匹配一个或者多个目录，“*”表示匹配文件名的任一部分，“？”表示匹配文件名中的任意单个字符。<xref
      linkend="ex-explicit-fileSet" />使用了一个fileMode元素来指定该文件集对于所有人可读，但是只有文件所有者可写。由于fileSet包含了目录，我们还可以指定directoryMode，它的使用方式和fileMode完全一样。一个目录的执行权限控制用户列出目录内容，我们这里想要确保目录对于所有人是可读且可执行的。和文件一样，只有目录所有者才拥有写的权限。</para>

      <para>fileSet元素还提供了一些其它的配置选项。首先，它允许一个excludes子元素，其形式和includes完全一样。这些排除模式能让你从fileSet中排除特定的文件。包含模式优先于排除模式。此外，如果你想要将所包含文件中的表达式替换成属性值，你可以将filtering标记设置成true。表达式可以用${}标记（如${project.groupId}）或者@@标记（这是标准的Ant表达式，如@project.groupId）来表示。你可以使用lineEnding元素来调整文件的换行字元；可用lineEnding值有：</para>

      <variablelist>
        <varlistentry>
          <term>keep</term>

          <listitem>
            <para>保持原始文件的换行字元。（这是默认值。）</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>unix</term>

          <listitem>
            <para>Unix风格的字元</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>lf</term>

          <listitem>
            <para>仅仅一个换行符</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>dos</term>

          <listitem>
            <para>MS-DOS风格的字元</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>crlf</term>

          <listitem>
            <para>回车后加一个换行符</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>最后，如果你想要确保所有文件匹配模式都被使用到，你可以使用userStrictFiltering元素，并将其值指定为true（默认值为false）。有些时候未使用的模式可能预示着某个中间输出目录缺失文件。使用值为true的useStrictFiltering后，当某个包含模式未被使用，Assembly插件就会失败。换句话说，如果你使用一个包含模式来包含构建中的某个文件，但是这个文件不存在，将userStrictFiltering设置成true会使得Maven构建失败。</para>

      <!--TODO: JCasey, I had to take the statement about Ant Expressions out because I couldn't verify it.
I can add this back in later.  I didn't want to talk about it without an example.  - TIM-->
    </section>

    <section id="sect-default-excludes">
      <title><sgmltag>fileSets的默认排除模式</sgmltag></title>

      <para>当你使用默认排除模式的时候，Maven
      Assembly插件不仅仅会忽略SVN和CVS信息。默认情况排除拥由Codehaus中<ulink
      url="http://plexus.codehaus.org/plexus-utils/">plexus-utils</ulink>项目的<ulink
      url="http://svn.codehaus.org/plexus/plexus-utils/trunk/src/main/java/org/codehaus/plexus/util/DirectoryScanner.java">DirectoryScanner</ulink>类定义。这个排除模式的数组被定义为一个static,
      final的String数组，其名称为DEFAULTEXCLUDES。该变量的内容如<xref
      linkend="ex-default-excludes" />所示。</para>

      <example id="ex-default-excludes">
        <title>Plexus Utils中模式排除模式的定义</title>

        <programlisting language="java">   public static final String[] DEFAULTEXCLUDES = {
        // Miscellaneous typical temporary files
        "**/*~",
        "**/#*#",
        "**/.#*",
        "**/%*%",
        "**/._*",

        // CVS
        "**/CVS",
        "**/CVS/**",
        "**/.cvsignore",

        // SCCS
        "**/SCCS",
        "**/SCCS/**",

        // Visual SourceSafe
        "**/vssver.scc",

        // Subversion
        "**/.svn",
        "**/.svn/**",

        // Arch
        "**/.arch-ids",
        "**/.arch-ids/**",

        //Bazaar
        "**/.bzr",
        "**/.bzr/**",

        //SurroundSCM
        "**/.MySCMServerInfo",

        // Mac
        "**/.DS_Store"
    };</programlisting>
      </example>

      <para>这个默认的模式数组会排除来自于如<ulink
      url="http://www.gnu.org/software/emacs/">GNU
      Emacs</ulink>的编辑器的临时文件，Mac中常见的临时文件，以及一些常见源码控制系统的元数据文件（虽然Visual
      SourceSafe得到的更多的是恶名而非好的源码控制系统）。如果你需要覆盖这个默认的排除模式，你可以将setDefaultExcludes设置成false，然后在你自己的套件描述符中定义一组排除模式。</para>
    </section>

    <section id="sect-output-algorithm">
      <title><sgmltag>dependencySets</sgmltag> 元素</title>

      <para>套件中最常见的需求之一是包含项目的依赖。files和fileSets只是处理你项目中的文件，而依赖文件不存在于你的项目中。项目依赖的构件需要在构建过程中由Maven解析。依赖构件是抽象的，它们缺少明确的位置，它们使用一组Maven坐标来进行解析。相比较使用file和fileSets需要一个具体的资源路径，我们使用一组Maven坐标和依赖范围来包含或者排除依赖。</para>

      <para>最简单的dependencySet是一个简单空元素：</para>

      <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet/&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>

      <para>上述的dependencySet会匹配你项目的所有运行时依赖（运行时范围隐式的包含编译范围依赖），并且它会将这些依赖添加到套件归档的根目录中。如果当前项目的主构件存在，它同时会复制该主构件至套件归档的根目录。</para>

      <note>
        <para>等等？我之前认为dependencySet是用来包含我项目的依赖的，而不是项目的主构件。这一反直觉的副作用是Assembly插件版本2.1的一个bug，但是这个bug被广泛使用了，由于Maven强调向后兼容性，这一反直觉的，错误的行为就必须在2.1和2.2版中保持下来。但是，你可以控制这一行为，只要设置useProjectArtifact为false即可。</para>
      </note>

      <para>虽然没有任何配置的默认依赖集合十分有用，但该元素同时也支持很多配置选项，能让你定制其行为以适应你的环境。例如，第一件你想对依赖集合做的事情可能就是排除当前项目的构件，你会想设置userProjectArtifact为false（再次强调，由于历史原因，该配置的默认值为true）。这让你能够把项目输出和项目依赖分开管理。还有，你可能会将unpack标记为true（默认为false）来拆解依赖构件。当unpack被设置成true时，Assembly插件会组合所有匹配依赖的拆解内容至归档的根目录。</para>

      <para>从这里你就可以看到，你有很多选择来控制依赖集合。下一节我们讨论如何定义依赖集合的输出位置，如何通过范围来包含和排除依赖。最后，我们会扩展依赖集的拆解功能，研究一些拆解依赖的高级选项。</para>

      <section id="sect-output-location">
        <title>自定义依赖输出目录</title>

        <para>有两个配置选项可以用来协调定义依赖文件在套件归档中的位置：outputDirectory和outputFileNameMapping。你可能想要使用依赖构件自身的属性来定义其在套件中的位置。比如说你想要将依赖放到与其groupId对应的目录中。这时候，你可以使用dependencySet的outputDirectory元素，并提供如下的配置：</para>

        <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;outputDirectory&gt;${artifact.groupId}&lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>

        <para>这会使得所有依赖被放到与其groupId对应的子目录中。</para>

        <para>如果你想要更进一步的自定义，并移除所有依赖的版本号。你可以使用outputFileNameMapping来自定义每个输出文件的文件名，如：</para>

        <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;outputDirectory&gt;${artifact.groupId}&lt;/outputDirectory&gt;
      &lt;outputFileNameMapping&gt;
        ${module.artifactId}.${module.extension}
      &lt;/outputFileNameMapping&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>

        <para>这个例子中，依赖commons:commons-codec版本1.3最后会成为文件commons/commons-codec.jar。</para>
      </section>

      <section>
        <title>依赖输出位置的属性插值</title>

        <para>正如在套件插值一小节所介绍的那样，outputDirectory和outputFileNameMapping不会和套件描述符的其它内容一样接受插值，这是因为它们的原始值必须使用额外的，构件特定的表达式解析器进行解释。</para>

        <para>对于这两个元素可用的构件表达式只有微小的差别。对两者来说，所有POM中及套件描述符其它部分中可用的${project.*},
        ${pom.*},
        和${*}表达式，这里也能用。对于outputFileNameMapping元素来说，解析表达式的过程如下：</para>

        <orderedlist>
          <listitem>
            <para>如果表达式匹配模式${artifact.*}：</para>

            <orderedlist numeration="loweralpha">
              <listitem>
                <para>基于依赖的Artifact实例进行匹配（解析：groupId, artifactId, version,
                baseVersion, scope, classifier, 和file.*）</para>
              </listitem>

              <listitem>
                <para>基于依赖的ArtifactHander实例进行匹配（解析：expression）</para>
              </listitem>

              <listitem>
                <para>基于和依赖Artifact相关的Project实例进行匹配（解析：主要是POM属性）</para>
              </listitem>
            </orderedlist>
          </listitem>

          <listitem>
            <para>如果表达式匹配模式${pom.*}或者${project.*}：</para>

            <orderedlist numeration="loweralpha">
              <listitem>
                <para>基于当前构建的项目实例（MavenProject)进行解析。</para>
              </listitem>
            </orderedlist>
          </listitem>

          <listitem>
            <para>如果表达式匹配模式${dashClassifier?}，而且Artifact实例包含一个非空的classfier，则解析成classifier前置一个破折号（-classfier）。否则，解析成一个空字符串。</para>
          </listitem>

          <listitem>
            <para>尝试基于当前构建的项目实例解析表达式。</para>
          </listitem>

          <listitem>
            <para>尝试基于当前项目的POM属性解析表达式。</para>
          </listitem>

          <listitem>
            <para>尝试基于系统属性解析表达式。</para>
          </listitem>

          <listitem>
            <para>尝试基于操作系统环境变量解析表达式。</para>
          </listitem>
        </orderedlist>

        <para>outputDirectory也以差不多的方式进行插值，区别在于，对于outputDirectory没有可用的${artifact.*}信息，而只有特定构件的${project.*}实例信息。因此，上述罗列的的相关条目（上述处理过程列表中的1a,
        1b和3）就无效了。</para>

        <para>我们怎么知道何时使用outputDirectory，何时使用outputFileNameMapping呢？当依赖被拆解的时候，只有outputDirectory会被用来计算输出路径。当依赖以完整的文件被管理时（不拆解），outputDirectory和outputFileNameMapping两者可以同时使用。在同时的时候，其结果等价于：</para>

        <programlisting language="xml">&lt;archive-root-dir&gt;/&lt;outputDirectory&gt;/&lt;outputFileNameMapping&gt;</programlisting>

        <para>在没有outputDirectory的时候，它便不被使用。当没有outputFileNameMapping的时候，其默认值为：</para>

        <programlisting language="java">${artifact.artifactId}-${artifact.version}${dashClassifier?}.${artifact.extension}</programlisting>
      </section>

      <section>
        <title>通过范围包含或排除依赖</title>

        <para>在<xref
        linkend="pom-relationships" />中，我们看到所有项目的依赖都有范围。依赖范围决定了依赖在构建过程的哪些阶段被使用。例如，test范围的依赖不会在编译项目主资源的时候被引入到classpath中；但当编译单元测试资源的时候，这些依赖就会被加入到classpath中。这是因为项目主资源的代码不该包含任何测试特有的代码，测试并不是一个项目的功能（它是项目构建过程的一个功能）。类似的，provided范围的依赖会被认为是已经在最终的部署环境中存在。但是，如果一个项目依赖于某个特定的provided依赖，那么它还是需要这个依赖以进行编译。因此，provided范围的依赖存在于编译classpath中，但是不会和项目构件或套件一起被打包发布。</para>

        <para>同样在<xref
        linkend="pom-relationships" />中，可以回忆到，一些依赖范围暗指了其它依赖范围。例如，runtime依赖范围暗指了compile范围，代码运行的时候需要所有编译时的依赖（除去那些provided范围的依赖）。各种各样的依赖范围之前有很多复杂的关系，这些关系控制一个直接依赖的范围如何影响间接依赖的范围。在Maven套件描述符中，我们可以使用依赖范围将不同的设置应用到不同的依赖组中。</para>

        <para>例如，如果我们打算在web应用中包裹<ulink
        url="http://www.mortbay.org/jetty-6/">Jetty</ulink>以创建一个完全自包含的应用，我们会需要包含所有jetty目录结构中的所有provided范围依赖。这才能确保那些provided范围的依赖存在于实际的运行环境着哦国内。非provided的，运行时的依赖仍然位于WEB-INF/lib目录中，因此这两组依赖需要分别处理。这些依赖组可能看起来很类似，如下列XML：</para>

        <example>
          <title>使用范围来定义依赖组</title>

          <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
      &lt;outputDirectory&gt;lib/${project.artifactId}&lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
      &lt;outputDirectory&gt;
        webapps/${webContextName}/WEB-INF/lib
      &lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>provided范围的依赖会添加到套件根目录下的lib/目录中，该目录是一个会被包含到Jetty全局运行classpath中的类库目录。我们使用根据项目artifactId命名的子目录以方便跟踪某个类库的出处。运行时依赖被添加到web应用的WEB-INF/lib路径下，这位于标准jetty的webapps/下的一个子目录中，该子目录使用自定义的POM属性webContextName进行设置。在这个例子中我们完成的事情是，将应用程序特定的依赖与那些位于Server容器全局classpath中的依赖隔离。</para>

        <para>然而，简单的根据范围来分隔依赖可能还不够，尤其是在web应用中。我们可以想象到某个或者多个运行时依赖可能实际上是供web应用使用的标准化的，非二进制的资源包裹。例如，考虑有一组web应用程序重用了一组Javascript,
        CSS, SWF,
        和图片资源。为了是这些资源更容易标准化，通常的做法是将它们包裹成一个归档文件并部署到Maven仓库中。这样，它们就可以通过标准的Maven依赖被引用——可能依赖的类型是zip——而这样的依赖通常是runtime范围的。但是，别忘了，它们是资源文件，不是应用程序代码本身的二进制依赖；因此，盲目的将这些文件放到WEB-INF/lib目录中是错误的。我们应该把这些资源归档和其它runtime依赖区别对待，将它们放到拆解后放到web应用的文档根目录中。为了实现这种分离，我们需要使用可以应用到特定依赖坐标上的包含和排除模式。</para>

        <para>换句话说，假如你有三个或者四个web应用，它们重用了同样的资源。你想要创建一个套件，将provided依赖放到lib/，将runtime依赖放到webapps/&lt;contextName&gt;/WEB-INF/lib，将某个特定的runtime依赖拆解并放到web应用的文档根目录中。你能完成这个任务，因为Assembly允许你为某个dependencySet元素定义多个包含和排除模式。阅读下一节将帮助你了解更多相关内容。</para>
      </section>

      <section>
        <title>微调：依赖包含和排除</title>

        <para>一个资源依赖可能只是简单的某个项目的一组资源（CSS, Javascript,
        和图片），该项目为此创建了一个ZIP归档格式的套件。基于我们web应用的特性，我们也许可以简单的通过依赖的打包格式来区分资源依赖和其它字节码依赖。大部分web应用以jar的形式依赖其它项目，因此我们可以简单的决定说有zip依赖为资源依赖。又或者，可能某些时候资源以jar的格式存储，但我们可以使用一个分类器，如resources。不管哪种情形，我们都可以为这些资源依赖使用包含模式，同时为其它字节码依赖使用不同的逻辑。我们会使用dependencySet的includes和excludes子元素来指定这些微调模式。</para>

        <para>includes和excludes都包含一子元素，相应的为include和exclude子元素。每个include或者exclude元素包含一个字符串值，该值可以包含通配符。每个字符串值都可以通过很多不同方式匹配依赖。总的来说，这里支持三种定义符匹配格式：</para>

        <variablelist>
          <varlistentry>
            <term><varname>groupId:artifactId</varname> - 无版本id</term>

            <listitem>
              <para>仅仅使用groupId和artifactId来匹配依赖。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><varname>groupId:artifactId:type[:classifier]</varname> -
            冲突id</term>

            <listitem>
              <para>该模式能让你指定一个更广的坐标范围，以创建更具体的包含/排除模式。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><varname>groupId:artifactId:type[:classifier]:version</varname>
            - 完整构件定义符</term>

            <listitem>
              <para>如果你需要十分十分的具体，你可以指定所有坐标。</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>所有这三种模式都支持通配符‘*’，它可以匹配定义符的任何一个子段，但不局限于一个单独的子段（位于‘:’中间的部分）。同时，注意上述的分类器部分是可选的，如果需要匹配的依赖没有分类器，就不需要在模式中指定分类器子段。</para>

        <para>在前面讲述的例子中，关键的区别在于构件类型zip，并且没有任何依赖拥有分类器，下列的模式会匹配所有类型为zip的资源依赖：</para>

        <programlisting>*:zip</programlisting>

        <para>上述的模式使用了第二种依赖定义符：依赖的冲突id。既然我们拥有了区分资源依赖和其它字节码依赖的模式，我们可以修改依赖集合来区分处理资源归档：</para>

        <example id="ex-complex-dependencySet">
          <title>在dependencySets中使用依赖排除和包含</title>

          <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
      &lt;outputDirectory&gt;lib/${project.artifactId}&lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
      &lt;outputDirectory&gt;
        webapps/${webContextName}/WEB-INF/lib
      &lt;/outputDirectory&gt;
      &lt;excludes&gt;
        &lt;exclude&gt;*:zip&lt;/exclude&gt;
      &lt;/excludes&gt;
    &lt;/dependencySet&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
      &lt;outputDirectory&gt;
        webapps/${webContextName}/resources
      &lt;/outputDirectory&gt;
      &lt;includes&gt;
        &lt;include&gt;*:zip&lt;/include&gt;
      &lt;/includes&gt;
      &lt;unpack&gt;true&lt;/unpack&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>在<xref
        linkend="ex-complex-dependencySet" />中，前一个例子中的运行时依赖集合已经更新，现在它排除了资源依赖。我们的字节码依赖（非zip依赖）需要被添加到web应用的WEB-INF/lib目录中。而资源依赖现在有其自身的依赖集合，它被配置成包含那些zip依赖，并输出至web应用的资源目录。例子中最后一个dependencySet中的includes元素和前一个dependencySet中的excludes元素起到的效果完全相反，因此使用同样的定义符模式，资源依赖就被准确包含了。最后一个dependencySet元素指向了共享资源依赖，并会拆解资源依赖至web应用的文档根目录中。</para>

        <para><xref
        linkend="ex-complex-dependencySet" />的前提是所有共享资源依赖的类型和其它依赖类型不一样。那么如果共享资源依赖和其它依赖的类型一致呢？你如何区分这些依赖？在这种情况下，假如所有的共享资源依赖都被打包成JAR，并且其分类器是resources，你就可以更改定义符模式来匹配这些依赖：</para>

        <programlisting>*:jar:resources</programlisting>

        <para>这里不再匹配那些类型为zip且没有分类器的构件，我们匹配所有类型为jar且分类器为resources的构件。</para>

        <para>和fileSets元素一样，dependencySets元素也支持useStrictFiltering标记。开启这个标记的时候，当任何一个指定的模式没有匹配任何依赖的时候，assembly插件运行就会失败，因此构建也会失败。有时候这是个很有用的保障，可以用来保证你项目的依赖和套件描述符是同步的，且按照你的意愿相互作用。默认情况下，为了向前兼容，该标记是关闭的。</para>
      </section>

      <section>
        <title>传递性依赖，项目构件，项目附属构件</title>

        <para>dependencySet元素支持两种更通用的机制来微调一小组匹配构件：传递性依赖选项，以及操作项目构件的选项。这两种特性都是为了支持遗留配置，这些配置所理解的“依赖”条件更为宽松。举个典型的例子，让我们考虑项目本身的构件。一般来说，这不会被算作是一个依赖；然而老版本的Assembly插件把项目本身的构件也算作依赖集。为了给这种“特性”提供向前兼容性，Assembly插件的2.2版本（目前是2.2-beta-2）支持一个名为useProjectArtifact的标记，其默认值为true。因此默认情况依赖集合在计算包含和排除的时候会考虑项目本身构件。如果你要单独处理项目构件，就需要将该标记置为false。</para>

        <tip>
          <para>本书的作者推荐你一直将useProjectArtifact置为false。</para>
        </tip>

        <para>自然的，作为项目构件的扩展，项目的附属构件也可以通过使用useProjectAttachments标记（默认值为false）在dependencySet中进行管理。开启这个标记后，指定分类器和类型的模式就会匹配那些“附属到”项目主构件的构件；就是说，它们共享基本的groupId/artifactId/version定义符，但是他们的type和classifier和主构件不同。当我们需要在套件中包含JavaDoc或者源码文件的时候，就可以使用这一特性。</para>

        <para>除了处理项目自身的构件，我们还能够微调使用两个传递性依赖解析标记来微调依赖集合。首先，名为useTransitiveDependencies（默认为true）指定依赖集合是否计算传递性依赖。举个实际的例子，如果你的POM依赖于另外一个套件，这个套件（很可能）会有一个分类器以区分其主构件并将自身作为一个附属构件。然而，Maven在解析依赖的时候，就算是解析套件构件，其主构件的传递性依赖信息还是会被解析。如果套件已经将项目依赖包裹，使用传递性依赖解析就会造成这些依赖的重复。为了避免这一情况，我们重要简单的将useTransitiveDependencies置为false。</para>

        <para>另外一个传递性依赖解析标记就更微妙了。它叫做useTransitiveFiltering，其默认值为false。要了解这个标记是做什么的，我们首先需要理解在解析过程中哪些信息是对所有任何构件可用的。当一个构件是依赖的依赖的时候（就是说，需要在你项目本身的POM再往下至少一层），它有一个被Maven称作“依赖踪迹“的东西，依赖踪迹维护一个字符串序列，该序列包含一列完整的构件定义符（groupId:artifactId:type:[classifier:]version），所有你项目的POM和拥有该依赖踪迹的构件的定义符都在其中。如果你还记得依赖集合模式匹配中可用的三种构件定义符，你会注意到依赖踪迹的每一项——完整构件定义符——对应了第三种类型。在useTransitiveFiltering为true的时候，依赖踪迹中的条目就会像主构件一样被包含或排除。</para>

        <para>如果你考虑使用传递性依赖过滤（transitive
        filtering），要小心！某个构件可能会在传递依赖图中被包含多次，但是自Maven
        2.0.9之后，只有第一个包含的踪迹会被认作该类型的匹配。当聚集你项目的依赖的时候，这可能会造成微妙的问题。</para>

        <warning>
          <para>大部分套件实际上不需要对于依赖集合这么深层次的控制；当你真要这么做的时候，仔细考虑，很可能没有这个必要。</para>
        </warning>
      </section>

      <section>
        <title>高级拆解选项</title>

        <para>正如我们之前讨论的，一些项目依赖需要先被拆解以帮助创建可用的套件归档。在前面的例子中，是否要拆解很明显。但是，没有考虑哪些部分需要拆解，或者，更重要的，哪些部分不要拆解。为了更好的控制拆解过程，我们可以配置dependencySet的unpackOptions元素。使用该元素，我们就可以选择拆解的时候包含或者排除那些文件模式，并且还可以配置那些被包含的文件是否需要被过滤以使用当前POM信息解析表达式。事实上，关于拆解依赖集合可用的选项，与包含项目目录结构使用的fileSets可用的选项十分类似。</para>

        <para>我们继续前面的web应用样例，假设一些资源依赖包裹了分发许可证文件。而在我们的web应用中，我们希望在自己套件的NOTICES文件中集中处理许可证信息，因此我们不希望引入该资源依赖的许可证文件。要排除这个文件，我们只需要在依赖集合配置中添加拆解选项如下：</para>

        <example>
          <title>在依赖拆解的时候排除文件</title>

          <programlisting language="xml">&lt;asembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
      &lt;outputDirectory&gt;
        webapps/${webContextName}/resources
      &lt;/outputDirectory&gt;
      &lt;includes&gt;
        &lt;include&gt;*:zip&lt;/include&gt;
      &lt;/includes&gt;
      &lt;unpack&gt;true&lt;/unpack&gt;
      &lt;unpackOptions&gt;
        &lt;excludes&gt;
          &lt;exclude&gt;**/LICENSE*&lt;/exclude&gt;
        &lt;/excludes&gt;
      &lt;/unpackOptions&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>注意这里我们使用的exlude元素和前面fileSet中使用的exlude元素十分类似。这里，我们拦截资源依赖目录中所有以LICENSE名字开头的文件。你可以将拆解选项看成是一个应用到每个匹配依赖上的轻量级fileSet配置。换句话说，它是一个应用到拆解依赖上的fileSet配置。和为资源依赖指定文件排除模式一样，我们也可以使用includes元素严格指定一组被包含的文件。在fileSets中用来处理包含和排除的同样的代码在unpackOptions这里是被完全重用的。</para>

        <para>除了包含和排除，拆解选项同样提供了filtering标记，其默认的值为false。同样，我们在fileSets中讨论该选项。对于两者来说，使用Maven语法的${property}和使用Ant语法的@property@都被支持。然而，对于依赖集合来说，过滤是一个非常有用的特性，因为这能让你建立标准化的，版本化的资源模板，并且每个套件在包含该模板的时候都可以对其进行自定义。一旦你掌握了如何使用过滤的，拆解的，包含共享资源的依赖，你就可以能抽象出那些重复的资源文件，生成一个通用的资源项目。</para>
      </section>

      <section>
        <title>依赖集合小结</title>

        <para>最后，值得一提的是，依赖集合和文件集合一样支持同样的fileMode和directoryMode配置选项，但是你应该记住directoryMode只有在依赖被拆解的时候被使用。</para>
      </section>
    </section>

    <section>
      <title><sgmltag>moduleSets</sgmltag> 元素</title>

      <para>多模块构建通常会使用相互关联POM中的parent和modules元素来凝聚在一起。典型的来说，父POM在modules元素中指名其子模块，一般情况这就会使得子POM被包含到父项目的构建过程中。这种关系的具体定义对Assembly插件在构建过程中起的作用会造成很大影响，之后我们会详细讨论这一点。目前，只要求你在我们讨论moduleSets元素的时候记住父子关系。</para>

      <!--TODO: I think we need a simple example of how/why this would be used.-->

      <para>很多项目被凝聚在一个多模块构建中是因为它们是一个更大系统的一部分。这些项目被设计成一起使用，在一个大型构建中的一个单独模块本身没有太大的实用价值。从某方面来说，项目构建的结构和我们期望该项目（以及它的模块）被使用的方式相关。如果从用户的角度考虑这个项目，那么可以认为构建的最终理想目标是提供一个单独的，可分发的，用户无须花太多安装的文件。由于Maven多模块项目基本上都遵循一个上下结构，其依赖信息，插件配置，还有其它信息自从父到子被继承，那么很自然的，我们会想到将所有模块凝聚成一个单独分发包的这样一个工作，最终会落到顶层项目的头上。这就是为什么会有moduleSet元素的原因。</para>

      <para>模块集合能让属于项目结构中每个模块的资源被包含到最终的套件归档中。就像你可以使用fileSet和dependencySet选择包含一组文件一样，在一个多模块构建中，你可以使用moduleSet指定包含某些模块的文件和资源。通过激活两个基本类型的，模块特定的包含元素就可以实现这一点：file-based，和artifacts-based。在我们深入了解基于文件包含和基于构件包含之前，我们先简单讨论一下选择处理哪些模块。</para>

      <section>
        <title>模块选择</title>

        <para>到目前为止，你应该已经熟悉includes/excludes模式了，它们贯穿了整个套件描述符，用来过滤文件和依赖。当你在套件描述符中指向模块的时候，你就需要使用includes/excludes模式来定义规则，这些规则会被应用到一组模块上。moduleSet中的includes和excludes元素不同的地方在于它们不允许使用通配符模式。（到2.2-beta-2版本为止，还没看到这个特性有太大的需要，因此仍然未实现。）每个Include或者exclude的值都只是简单的某个模块的groupId和artifactId，通过冒号分隔，如：</para>

        <programlisting>groupId:artifactId</programlisting>

        <para>除了includes和excludes，moduleSet还支持一种额外的选择工具：includeSubModules标记（默认值为true）。多模块构建中的父子关系并不会严格的限制在两层。事实上，你可以包含任意层的模块。一个当前项目模块包含的模块被认为是一个子模块。某些情况，你想要单独的处理构建中的每一个模块（包括子模块）。例如，通常处理基于构件的贡献的最简单的方法是在这些模块中处理，为此，你只要简单的让includeSubModules为默认值true。</para>

        <para>当你试图从每个模块的目录结构中包含文件的时候，你可能会希望一次整个的处理所有模块的目录。如果你的项目目录结构和POM中的父子结构一致，这种方式就能让模式如**/src/main/java不仅仅应用到当前模块的目录中，同时也应用到子模块的目录中。这种情况下你不想直接处理子模块（它们会以当前项目子目录的形式被处理），你应该将includeSubModules设置成false。</para>

        <para>在我们决定了选择哪些模块被处理之后，我们就可以选择每个模块包含的内容了。正如前面提到的，我们可以选择包含模块项目的文件或者构件。</para>
      </section>

      <section>
        <title>源码选择</title>

        <para>假设你想要在套件中包含所有模块的源码，但是你希望排除某个特殊的模块。比如说可能你有一个名为secret-sauce的项目，它包含了一些你不想随着项目分发的秘密且敏感的代码。要做到这一点，最简单的方式是使用moduleSet，它在${module.basedir.name}中包含每个项目的目录，并且将secret-sauce排除在套件之外。</para>

        <example id="ex-include-exclude-moduleSet">
          <title>使用moduleSet包含和排除模块</title>

          <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;moduleSets&gt;
    &lt;moduleSet&gt;
      &lt;includeSubModules&gt;false&lt;/includeSubModules&gt;
      &lt;excludes&gt;
        &lt;exclude&gt;
          com.mycompany.application:secret-sauce
        &lt;/exclude&gt;
      &lt;/excludes&gt;
      &lt;sources&gt;
        &lt;outputDirectoryMapping&gt;
          ${module.basedir.name}
        &lt;/outputDirectoryMapping&gt;
        &lt;excludeSubModuleDirectories&gt;
          false
        &lt;/excludeSubModuleDirectories&gt;
        &lt;fileSets&gt;
          &lt;fileSet&gt;
            &lt;directory&gt;/&lt;/directory&gt;
            &lt;excludes&gt;
              &lt;exclude&gt;**/target&lt;/exclude&gt;
            &lt;/excludes&gt;
          &lt;/fileSet&gt;
        &lt;/fileSets&gt;
      &lt;/sources&gt;
    &lt;/moduleSet&gt;
  &lt;/moduleSets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>在<xref
        linkend="ex-include-exclude-moduleSet" />中，由于我们是在处理每个模块的源码，因此只处理当前项目模块更简单，我们可以使用文件集合的文件路径通配符来处理子模块。这里我们将includeSubModules元素设为false，因此就不用担心子模块出现在套件的根目录中。exclude元素会负责排除secret-sauce模块。我们就不会包含这个秘密模块的源码了。</para>

        <para>一般来说，包含的模块源码会位于套件中一个名为模块artifactiId的子目录中。然而，因为Maven允许模块不位于根据其artifact命名的目录中，因此通常最好使用表达式${module.basedir.name}来保证模块目录的实际名称（${module.basedir.name}与MavenProject.getBasedir().getName()的值一致）。一定要记住模块并不是一定以子目录的形式存在。如果你的项目有一个十分奇怪的目录结构，你可能就需要凭借特殊的moduleSet声明来包含特定的项目，以及解释你项目的特异性。</para>

        <warning>
          <para>尽量降低你项目的特异性，虽然Maven很灵活，但如果你发现你配置太多，就很可能有一种更简单的方式。</para>
        </warning>

        <para>继续讨论<xref
        linkend="ex-include-exclude-moduleSet" />，由于我们没有在这个模块集合中显式的处理子模块，我们需要确保子模块的目录内容没有被排除在外。通过设置excludeSubModuleDirectories为true，我们就可以在子模块的目录中应用相同的文件模式。最后在<xref
        linkend="ex-include-exclude-moduleSet" />中，我们对模块集合构建过程中的任何输出都没有兴趣，因此我们从所有模块中排除target/目录。</para>

        <para>还有一点值得一提的是，除了支持嵌套fileSets以外，sources元素本身直接支持所有类fileSet的元素。这些配置元素用来提供对之前Aseembly插件版本（版本2.1及之前）的向前兼容性，之前的版本在没有创建一个单独的模块集合声明的情况下，不支持同一模块的多个文件集合。这种用法是被废弃的，不应该被使用。</para>
      </section>

      <section>
        <title><sgmltag>moduleSets中outputDirectoryMapping的插值</sgmltag></title>

        <para>在<xref
        linkend="sect-output-location" />中，我们使用元素outputDirectoryMapping来更改包含每个模块源码的目录名称。解析该表达式元素的方式和依赖集合中解析outputFileNameMapping元素的方式完全一致（见<xref
        linkend="sect-output-algorithm" />中该算法的解释）。</para>

        <para>在<xref
        linkend="ex-include-exclude-moduleSet" />中，我们使用了表达式${module.basedir.name}。你可能会注意到该表达式的根元素，module，并没有在依赖集合的匹配解析算法中列出；这个根元素moduleSets配置特有的。它其实和outputFileNameMapping元素中使用${artifacts.*}引用一样，只是这里应用到了模块的MavenProject,
        Artifact, 和ArtifactHandler上，而非依赖构件。</para>
      </section>

      <section>
        <title>字节码选择</title>

        <para>源码选择主要关注以源码的形式包含一个模块，而字节码选择就主要关注包含模块的构建输出，或者说构件。虽然这一部分运行就效果就像声明一个依赖集合并应用到每个模块上，但这里还有一些额外的特性只对模块构件有效，这些元素值得讨论：attachmentClassifier和includeDependencies。此外，biniaries元素包含了一些与dependencySet元素类似的选项，它们关系到模块构建本身的处理。它们是：unpack,
        ouputFileNameMapping, outputDirectory, directoryMode,
        以及fileMode。最后，模块字节码可以包含一个dependencySets元素，用来指定每个模块的依赖应该如何被包含到套件归档中。首先，让我们看一下这里提到的选项如何被用来管理模块本身的构件。</para>

        <para>假设你想要在套件中包含每个模块的javadoc jar。这时，我们不考虑包含模块依赖；我们只要javadoc
        jar。然而，由于这个特殊的jar是项目主构件的一个附属构件，我们需要指定它的分类器以获取该jar。简单起见，我们不会涉及到拆解该模块的jajvadoc
        jar，拆解的配置和我们之前配置依赖集合完全一样。最后的模块集合看起来会像<xref
        linkend="ex-include-javadoc-moduleset" />。</para>

        <example id="ex-include-javadoc-moduleset">
          <title>在套件中包含模块的JavaDoc</title>

          <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;moduleSets&gt;
    &lt;moduleSet&gt;
      &lt;binaries&gt;
        &lt;attachmentClassifier&gt;javadoc&lt;/attachmentClassifier&gt;
        &lt;includeDependencies&gt;false&lt;/includeDependencies&gt;
        &lt;outputDirectory&gt;apidoc-jars&lt;/outputDirectory&gt;
      &lt;/binaries&gt;
    &lt;/moduleSet&gt;
  &lt;/moduleSets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>在<xref
        linkend="ex-include-javadoc-moduleset" />中，我们没有显式的设置includeSubModules标记，它默认为true。我们当然想要使用该模块集合来处理所有的模块，包括子模块，因为我们没有使用任何可以匹配子模块目录结构的文件模式。attachmentClassifier会抓取每个被处理模块的分类器为classifier的附属构件。而includeDependencies元素告诉Assembly插件，我们对模块的依赖没有兴趣。最后，outputDirectory元素告诉Assembly插件将所有javadoc
        jar放到套件跟目录下名为apidoc-jars的目录中。</para>

        <para>虽然在本例中我们没有做什么特别复杂的配置，但重点需要理解的是，source元素中关于outputDirectoryMapping子元素讨论的表达式解析算法这里同样适用。也就是说，任何dependencySet的outputFileNameMapping配置中可用的<varname>${artifact.*}</varname>
        ，在这里都可以通过<varname>${module.*}</varname>的形式使用。它们起到的效果是一样的。</para>

        <para>最后，让我们看一个例子，这里我们想要处理模块的构件以及运行时依赖。在这种情况下，我们需要根据模块的artifactId和version将每个模块的构件集合分离到单独的目录结构中。最终的模块结合惊人得简单，就像<xref
        linkend="ex-the-big-include" />：</para>

        <example id="ex-the-big-include">
          <title>在套件中包含模块构件和依赖</title>

          <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;moduleSets&gt;
    &lt;moduleSet&gt;
      &lt;binaries&gt;
        &lt;outputDirectory&gt;
          ${module.artifactId}-${module.version}
        &lt;/outputDirectory&gt;
        &lt;dependencySets&gt;
          &lt;dependencySet/&gt;
        &lt;/dependencySets&gt;
      &lt;/binaries&gt;
    &lt;/moduleSet&gt;
  &lt;/moduleSets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>在<xref
        linkend="ex-the-big-include" />中，我们使用了空的dependencySet元素，这时因为默认情况下，没有任何配置它就会包含所有运行时依赖。这里我们设置了字节码集合的outputDirectory，所有依赖以及模块主构件都会被包含到这个目录中，因此，我们设置不需要再去配置依赖集合。</para>

        <para>很大程度上，模块字节码直接明了。两个部分——主要部分，关注处理模块构件本身，和依赖集合，关注模块依赖——它们的配置选项都和依赖集合的配置类似。当然，binaries元素同时还提供了一些选项用来控制是否包含依赖，以及你想要使用那个主项目构件。</para>

        <para>如同sources元素一样，binaries元素包含了一些目的仅为向前兼容性的元素，它们应该被弃用。这包括了includes和excludes子元素。</para>
      </section>

      <section>
        <title><sgmltag>moduleSets</sgmltag>,
        父<acronym>POM</acronym>，和<sgmltag>binaries</sgmltag>元素</title>

        <para>最后，我们用一个警告来结束模块处理的讨论。Maven内部设计中关于父-模块关系的部分与模块集合binaries元素的运行有着微妙的相互影响。当一个POM声明一个父项目，那么父项目就必须在当前项目被构建之前以某种方式解析。如果父项目在Maven仓库中，这没什么问题。然而，从Maven
        2.0.9起，如果父项目是同一构建下的上一层POM，这就会出现问题，尤其是在父POM期望使用子项目的字节码构建套件的时候。</para>

        <para>Maven
        2.0.9根据依赖关系来安排多模块项目构建的顺序，某个模块的依赖总在该模块之前被构建。问题在于，父项目也被看成是一个依赖，也就是说，父项目的构建必须在子项目构建之前就完成。如果父项目构件的过程包括创建一个套件，而这个套件使用了模块字节码，而这些字节码还不存在，也就不能被包含，那么Assembly插件就会失败。这是一个复杂且微妙的问题，严重影响了套件描述符模块字节码小节的用途。事实上，已经有一个Assembly插件的bug记录来跟踪这一问题：<ulink
        url="http://jira.codehaus.org/browse/MASSEMBLY-97">http://jira.codehaus.org/browse/MASSEMBLY-97</ulink>。希望未来版本的Maven能够找到方法来修复这一功能，因为很多时候父项目必须首先构建这一需求并不是完全必要。</para>
      </section>
    </section>

    <section>
      <title>Repositories元素</title>

      <para>套件描述符中的repositories元素是可以说是一个舶来品，因为除了Maven自己很少有应用能够利用Maven仓库的目录结构。此外，repositories元素中的很多功能与dependencySets元素十分类似，因此我们这里不花太多时间在这上面。大部分情况下，理解依赖集合的用户都能很轻松的在套件描述符中编写正确的repositories元素。我们就不详细介绍repositories元素了；也不会再建立一个用例再一步步解释。但是，如果你发现自己需要使用repositories元素，我还是警告你小心。</para>

      <!--TODO: We probably need to motivate why you would ever want to do this.  Right now, this section
doesn't make sense to new users.-->

      <para>说过这些之后，这里值得一提的是两个repositories元素特有的特征。第一个是includeMetadata标记。当它为true的时候，套件就会包含仓库元数据，如与-SNAPSHOT虚拟版本对应的一列真实版本，默认情况下，该标记为false。目前，当这个标记为true的时候，只有从Maven中央仓库下载的元数据会被包含进来。</para>

      <para>第二个特性名为groupVersionAlignments。同样，该元素包含一列单独的groupVersionAlignment子元素，该子元素的目的是规范某个特定groupId下包含的所有构件使用一个单独的版本。每个groupVersionAlignment元素包含两个必须的子元素——id和version——还包含可选的excludes元素，该excludes元素可以包含一列artifactId的字符串值，使其被排除在外。不幸的是，这种版本的校正不会修改仓库中的POM，不管是被校正的构件还是依赖于它们的构件，其POM都不会被修改，因此难以想象实际用到这种校正的应用会是什么样子。</para>

      <para>总的来说，当你添加repositories元素的时候，同样遵循使用依赖集合的原则。虽然repositories元素支持上述额外的特性，但这主要还是为了提供向后兼容性，因此以后的版本中可能会被废弃。</para>
    </section>

    <section>
      <title>管理套件的根目录</title>

      <para>到现在为止我们仔细了解的套件描述符的主体部分，我们可以用相对轻量级的内容来结束关于描述符内容相关的叙述：根目录命名和站点目录处理。</para>

      <para>有人可能认为这只是形式考虑，但是拥有对于套件根目录命名的控制，或者是否需要根目录，都通常很重要。幸运的是，套件描述符根元素下的两个配置选项使得管理归档根目录变得简单，它们是：includeBaseDirectory和baseDirectory。如果套件是一个可运行jar文件，你可能就完全不想要根目录。为了忽略根目录，只要简单的将includeBaseDirectory设置为false（默认为true）。这样，生成的归档在打开的时候，就可能在拆解目标目录创建多个目录。如果一个归档在使用之前需要拆解，这通常是一种不好的方式，最好是一个归档能够照原样使用。</para>

      <para>在一些其它情况，你可能想要保证归档根目录的名称与POM的版本或者其它信息一致。默认情况下，baseDirectory的值就等于<varname>${project.artifactId}-${project.version}</varname>。但是，我们可以很简单的更改这个元素的值，可以是一个字符串字面量，或者是一个根据当前POM进行插值的表达式，比如<varname>${project.groupId}-${project.artifactId}</varname>。对你的文档团队来说，这是个好消息！（我们都拥有这样的团队，是吧？）</para>

      <para>另外一个可用的配置选项是includeSiteDirectory，其默认值是false。如果你项目的构建同时使用了site生命周期的Site插件目标创建了web站点文档，你就可以通过将该选项设置成true来包含这些内容。不过，这个特性有一些限制，只有当前POM的文档部分会被包含（默认情况是target/site），而所有子模块的站点目录不在考虑之中。如果你想要用，就用吧，不过一个适当配置的fileSet或者moduleSet可以完成同样的任务，可能还会更好。其实这里又是一个Assembly插件考虑向前兼容性的例子，你最好还是使用fileSet或者moduleSet元素，而非将includeSiteDirectory设置成true。</para>
    </section>

    <section id="sect-componentDescriptors">
      <title><sgmltag>componentDescriptors</sgmltag>和<sgmltag>containerDescriptorHandlers</sgmltag></title>

      <para>为了丰满我们关于套件描述符的讨论，我们还应该简单看一下另外两个元素：containerDescriptorHandlers和componentDescriptors。containerDescriptorHandlers元素指向一个自定义的组件，你可以用该组件来扩展Assembly插件的功能。具体来说，这些自定义的组件能让你定义及处理一些特殊的文件，它们可能需要被从各个成分（constituent）归并到一起以创建你的套件。举个很好的例子，可能有一个自定义容器描述符处理器，用来从一个成分war或者war片段文件归并web.xml到你的套件中，这样你就可以在最终的套件中保持一个单独的web应用描述符，并将其看成一个war文件。</para>

      <para>componentDescriptors元素允许你引用外部的套件描述符片段，然后将其包含到当前的描述符中。组件引用可以是如下任何一种：</para>

      <orderedlist>
        <listitem>
          <para>相对文件路径：
          <filename>src/main/assembly/component.xml</filename></para>
        </listitem>

        <listitem>
          <para>构件引用：
          <varname>groupId:artifactId:version[:type[:classifier]]</varname></para>
        </listitem>

        <listitem>
          <para>Classpath资源：
          <filename>/assemblies/component.xml</filename></para>
        </listitem>

        <listitem>
          <para>URL： <ulink
          url="http://www.sonatype.com/component.xml">http://www.sonatype.com/component.xml</ulink></para>
        </listitem>
      </orderedlist>

      <para>顺便说一下，在解析组件描述符的时候，Assembly插件严格的按照上面的顺序采取不同的策略。第一个成功的策略会被使用。</para>

      <para>组件描述符可以包含大多数组件描述符中可用的关于内容的元素，但是moduleSets除外，这时因为该元素被认为是每个项目特定的，不该被重用。组件描述符中还可以包含的元素是containerDescriptorHandlers，这个之前已经简要过。组件描述符不能包含格式，套件ID，或者其它任何与套件归档基础目录相关的配置，所有这些配置都是特定套件描述符唯一的。虽然共享格式元素是有道理的，但在2.2-beta-2版本的Assembly插件中，还没有实现。</para>
    </section>
  </section>

  <section>
    <title>最佳实践</title>

    <para>Assembly插件提供了足够的灵活性，以很多不同的方式处理许多问题。如果你的项目有特定的需求，那么你完全可以使用本章叙述的方法来实现几乎任何的套件结构。本节，我们讨论讨论一些最佳实践，如果你遵循它们，你就能更高效的使用Assembly插件，同时也能减少不必要的痛苦。</para>

    <section>
      <title>标准的，可重用的套件描述符</title>

      <para>到目前位置，我们主要讨论了一些针对某个特定套件的一次性解决方案。但是如果你有几十个项目需要某个特定类型的套件怎么办？简言之，我们如何才能重用我们为某个套件所花的精力，并将其使用到多个项目中去，而不是复制粘贴套件描述符？</para>

      <para>最简单的答案是从套件描述符中创建一个标准化的，版本化的构件，并将其部署。一旦完成了这一步，你就可以在你项目的POM中指定Assembly插件的plugin元素以插件级别依赖的形式去使用套件描述符构件，这会让Maven解析并包含套件描述符至插件的classpath中。这时，你就可以通过配置Assembly插件的descriptorRefs元素来使用这个套件描述符。请看如下的套件描述符：</para>

      <programlisting language="xml">&lt;assembly&gt;
  &lt;id&gt;war-fragment&lt;/id&gt;
  &lt;formats&gt;
    &lt;format&gt;zip&lt;/format&gt;
  &lt;/formats&gt;
 &lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt;
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;outputDirectory&gt;WEB-INF/lib&lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  &lt;fileSets&gt;
    &lt;fileSet&gt;
      &lt;directory&gt;src/main/webapp&lt;/directory&gt;
      &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
      &lt;excludes&gt;
        &lt;exclude&gt;**/web.xml&lt;/exclude&gt;
      &lt;/excludes&gt;
    &lt;/fileSet&gt;
  &lt;/fileSets&gt;
&lt;/assembly&gt;</programlisting>

      <para>在你的项目中使用它，所有项目的内容就会被打包在一起，然后可以直接解压添加到现存web应用中（为了添加一个扩展特性）。然而，如果你的团队构建了很多个web片段项目，那么你就会想要重用该描述符，而非复制它。为了将该描述符以构件的形式部署，我们就要将其放到一个项目中，位于<filename>src/main/resources/assemblies</filename>目录。</para>

      <para>这个套件描述符构件的项目结构看起来如下：</para>

      <programlisting>|-- pom.xml
`-- src
    `-- main
        `-- resources
            `-- assemblies
                `-- web-fragment.xml
</programlisting>

      <para>注意web-fragment.xml文件的位置。默认情况下，Maven会将整个src/main/resources目录打包到最终的jar中，这里，如果没有额外的配置，套件描述符也就会被打包。同时注意assemblies/这一路径前缀，Assembly插件需要所有插件classpath中的描述符拥有这一前缀。将我们的描述符放到恰当的相对路径十分重要，这样Assembly才能够在运行的时候识别它们。</para>

      <para>记住，现在这个项目已经和你实际的web-fragment项目分离了；套件描述符拥有了自己的构件，自己的版本，甚至有可能的话，自己的发布周期。一旦你使用Maven
      install了这一新的项目，你就能够在web-fragment项目中使用它。如果还不清楚，检查构建过程，看起来应该如下：</para>

      <screen>$ <command>mvn install</command>
(...)
[INFO] [install:install]
[INFO] Installing (...)/web-fragment-descriptor/target/web-fragment-descriptor-1.0-SNAPSHOT.jar 
       to /Users/~/.m2/repository/org/sonatype/mavenbook/assemblies/\
          web-fragment-descriptor/1.0-SNAPSHOT/web-fragment-descriptor-1.0-SNAPSHOT.jar
[INFO] ---------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ---------------------------------------------------------------
[INFO] Total time: 5 seconds
(...)</screen>

      <para>由于web-fragment-descriptor项目没有源码，得到的jar除了包含web-fragment套件描述符什么都没有。现在，让我们使用这个新的描述符构件：</para>

      <programlisting language="xml">&lt;project&gt;
  (...)
  &lt;artifactId&gt;my-web-fragment&lt;/artifactId&gt;
  (...)
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.2-beta-2&lt;/version&gt;
        &lt;dependencies&gt;
          &lt;dependency&gt;
            &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
            &lt;artifactId&gt;web-fragment-descriptor&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
          &lt;/dependency&gt;
        &lt;/dependencies&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;assemble&lt;/id&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;single&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;descriptorRefs&gt;
                &lt;descriptorRef&gt;web-fragment&lt;/descriptorRef&gt;
              &lt;/descriptorRefs&gt;
            &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
      (...)
    &lt;/plugins&gt;
  &lt;/build&gt;
  (...)
&lt;/project&gt;
</programlisting>

      <para>在这个Assembly插件配置中，有两个特殊的地方：</para>

      <itemizedlist>
        <listitem>
          <para>这里必须包含一个插件级别依赖声明，只有依赖了web-fragment-descriptor构件之后我们才能通过插件classpath访问套件描述符。</para>
        </listitem>

        <listitem>
          <para>由于我们使用classpath引用，而非本地项目目录结构的文件，我们就必须使用descriptorRefs元素，而非descriptor。还有要注意的是，虽然套件描述符实际上是位于插件classpath的assemblies/web-fragment.xml位置，但我们这里引用的时候没有写明assemblies/前缀。这是因为Assembly插件假设所有内置的套件描述符都永远位于classpath下的该前缀位置下。</para>
        </listitem>
      </itemizedlist>

      <para>现在，你可以随意的在任何多个项目中重用这部分POM配置，并能确保它们所有的web-fragment套件是相似的。可能你需要调整套件格式——可能是为了包含其它资源，或者为了微调依赖和文件集合——你可以提升套件描述符项目的版本，然后再次发布。引用该套件描述符的POM就可以使用新的版本来生效。</para>

      <para>关于套件描述符重用最后一点：你可能不仅仅想要将描述符发布成一个构件，你还希望共享插件配置。这很简单；只要将上述的插件配置放到父POM的pluginManagement元素中，然后在子模块的POM中如下引用这段插件配置：</para>

      <programlisting language="xml">(...)
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
      &lt;/plugin&gt;
(...)</programlisting>

      <para>如果你已经将前面的插件配置放到了父POM中的pluginManagement中，那么所有继承该POM的项目就可以使用如上最少的配置，正确的引用套件描述符，实现我们自定义的高级的套件格式。</para>
    </section>

    <section>
      <title>分发（聚合）套件</title>

      <para>正如之前提到的，Assembly插件提供很多种方式来创建不同的归档格式。分发包是一个典型的例子，因为它们通常结合了多模块构建的多个模块，还有它们的依赖，以及可能还有除此之外的其它文件和构件。分发包的目的是将所有不同的代码，资源，文件包裹到一个单独的归档中，供用户方便的下载，拆解，运行。然而，我们也提到了一些使用套件描述符moduleSets元素的缺点——那就是POM之间的父子关系在某些情况会使子模块构件不可用。</para>

      <para>具体的说，如果子模块POM引用的父项目包含了一段Assembly插件配置，在多模块构建运行的时候，这个父项目会在子模块之前被构建。但是父项目运行Assembly的时候会去寻找子模块的构件，而子模块项目还在等待父项目完整构建，这就造成了一个僵持的局面，父项目也就无法成功构建（因为它无法找到需要的子模块构件）。换句话说，子项目依赖于父项目，而父项目同时又依赖于子项目。</para>

      <para>作为一个例子，考虑如下的套件描述符，在一个多模块结构的顶层项目中使用：</para>

      <programlisting language="xml">&lt;assembly&gt;
  &lt;id&gt;distribution&lt;/id&gt;
  &lt;formats&gt;
    &lt;format&gt;zip&lt;/format&gt;
    &lt;format&gt;tar.gz&lt;/format&gt;
    &lt;format&gt;tar.bz2&lt;/format&gt;
  &lt;/formats&gt;
  
  &lt;moduleSets&gt;
    &lt;moduleSet&gt;
      &lt;includes&gt;
        &lt;include&gt;*-web&lt;/include&gt;
      &lt;/includes&gt;
      &lt;binaries&gt;
        &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
        &lt;unpack&gt;true&lt;/unpack&gt;
        &lt;includeDependencies&gt;true&lt;/includeDependencies&gt;
        &lt;dependencySets&gt;
          &lt;dependencySet&gt;
            &lt;outputDirectory&gt;/WEB-INF/lib&lt;/outputDirectory&gt;
          &lt;/dependencySet&gt;
        &lt;/dependencySets&gt;
      &lt;/binaries&gt;
    &lt;/moduleSet&gt;
    &lt;moduleSet&gt;
      &lt;includes&gt;
        &lt;include&gt;*-addons&lt;/include&gt;
      &lt;/includes&gt;
      &lt;binaries&gt;
        &lt;outputDirectory&gt;/WEB-INF/lib&lt;/outputDirectory&gt;
        &lt;includeDependencies&gt;true&lt;/includeDependencies&gt;
        &lt;dependencySets&gt;
          &lt;dependencySet/&gt;
        &lt;/dependencySets&gt;
      &lt;/binaries&gt;
    &lt;/moduleSet&gt;
  &lt;/moduleSets&gt;
&lt;/assembly&gt;</programlisting>

      <para>基于这个父项目——叫做app-parent——它带有三个模块，分别为app-core, app-web,
      和app-addons，注意当我们运行这个多模块构建的时候发生了什么：</para>

      <screen>$ <command>mvn package</command>
[INFO] Reactor build order: 
[INFO]   app-parent &lt;----- PARENT BUILDS FIRST
[INFO]   app-core
[INFO]   app-web
[INFO]   app-addons
[INFO] ---------------------------------------------------------------
[INFO] Building app-parent
[INFO]    task-segment: [package]
[INFO] ---------------------------------------------------------------
[INFO] [site:attach-descriptor]
[INFO] [assembly:single {execution: distro}]
[INFO] Reading assembly descriptor: src/main/assembly/distro.xml
[INFO] ---------------------------------------------------------------
[ERROR] BUILD ERROR
[INFO] ---------------------------------------------------------------
[INFO] Failed to create assembly: Artifact:
org.sonatype.mavenbook.assemblies:app-web:jar:1.0-SNAPSHOT (included by module) does not have \
  an artifact with a file. Please ensure the package phase is run before the assembly is \
  generated.
...</screen>

      <para>父项目——app-parent——首先构建。这时因为所有其它项目都将其引用成父项目，从而使得它必须在所有其它项目之前构建。而app-web模块，套件描述符中第一个要处理的模块，还没有被构建。因此，它就没有相关的构件，因此整个装配就无法成功。</para>

      <para>对于这种情形的一个临时解决办法是从Assembly插件声明中移除executions部分配置，这部分配置将插件绑定到父POM的package生命周期阶段，保持其它的配置不变。然后，分别运行两个Maven命令行任务：首先，package，构件整个多模块项目，然后，再运行assembly:assembly，直接调用Assembly插件，这时能够使用到之前运行输出的构件，并创建出分发套件。这样一个构建的命令行如下：</para>

      <screen>$ <command>mvn package assembly:assembly</command></screen>

      <para>然而，这种方式有几个缺陷。首先，它使得套件分发过程变成了一个更手动的工作，对于整个构建过程，很大程度上这增加了复杂度，且会带来一些潜在的错误。此外，这也意味着如果不使用文件系统引用，那么附属构件——当项目构建运行的时候关联在内存中——也就无法再次被使用。</para>

      <para>除了使用moduleSet来收集多模块构建中的所有构件，通常还有一种更好的的做法：使用一个专门的分发包项目模块，并利用模块间依赖。在这种方式中，你首先在你的构建中创建一个专门来出来装配分发包的模块。这个模块的POM包含了对所有其它模块的依赖，且配置了Assembly插件绑定到其package生命周期阶段。而套件描述符就使用dependencySets元素来取代moduleSets，以收集所有模块构件并决定它们在套件归档中的位置。这种方式避开了前面讲述的关于父子关系的陷阱，现在只需要在套件描述符中使用更简单的配置来完成我们的工作。</para>

      <para>为此，我们可以创建一个新的项目结构，它与我们之间模块集合使用的方式类似，只是需要一个额外的分发项目，我们最终需要五个POM：app-parent,
      app-core, app-web, app-addons,
      以及app-distribution。新的app-deistribution的POM如下：</para>

      <programlisting language="xml">&lt;project&gt;
  &lt;parent&gt;
    &lt;artifactId&gt;app-parent&lt;/artifactId&gt;
    &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;/parent&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;artifactId&gt;app-distribution&lt;/artifactId&gt;
  &lt;name&gt;app-distribution&lt;/name&gt;
  
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;artifactId&gt;app-web&lt;/artifactId&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
      &lt;type&gt;war&lt;/type&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;artifactId&gt;app-addons&lt;/artifactId&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- Not necessary since it's brought in via app-web.
    &lt;dependency&gt; [2]
      &lt;artifactId&gt;app-core&lt;/artifactId&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
    --&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</programlisting>

      <para>注意由于现在的POM中不再能够使用模块集合，我们必须包含项目结构中对于其它模块的依赖。还要注意的是，我们这里没有显式的声明对于app-core的依赖，这时由于我们已经依赖的app-web，app-core已经通过传递性依赖的方式引入。</para>

      <para>接着，当我们将distro.xml套件描述符移到app-distribution项目中时，我们需要使用dependencySets元素对其进行修改，如：</para>

      <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;includes&gt;
        &lt;include&gt;*-web&lt;/include&gt;
      &lt;/includes&gt;
      &lt;useTransitiveDependencies&gt;false&lt;/useTransitiveDependencies&gt;
      &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
      &lt;unpack&gt;true&lt;/unpack&gt;
    &lt;/dependencySet&gt;
    &lt;dependencySet&gt;
      &lt;excludes&gt;
        &lt;exclude&gt;*-web&lt;/exclude&gt;
      &lt;/excludes&gt;
      &lt;useProjectArtifact&gt;false&lt;/useProjectArtifact&gt;
      &lt;outputDirectory&gt;/WEB-INF/lib&lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;
</programlisting>

      <para>现在，如果我们从项目顶层运行构建，就能看到更好的结果：</para>

      <screen>$ <command>mvn package</command>
(...)
[INFO] ---------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] ---------------------------------------------------------------
[INFO] module-set-distro-parent ...............SUCCESS [3.070s]
[INFO] app-core .............................. SUCCESS [2.970s]
[INFO] app-web ............................... SUCCESS [1.424s]
[INFO] app-addons ............................ SUCCESS [0.543s]
[INFO] app-distribution ...................... SUCCESS [2.603s]
[INFO] ---------------------------------------------------------------
[INFO] ---------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ---------------------------------------------------------------
[INFO] Total time: 10 seconds
[INFO] Finished at: Thu May 01 18:00:09 EDT 2008
[INFO] Final Memory: 16M/29M
[INFO] ---------------------------------------------------------------</screen>

      <para>正如你所看到的，使用依赖集合的方式更可靠，并且在运行构建的时候出错的几率更低——至少在Maven的内部项目构建排序逻辑还没有赶上Assembly插件的功能之前是这样。</para>
    </section>
  </section>

  <section>
    <title>总结</title>

    <para>如你在本章所看到的，Maven
    Assembly插件为创建自定义归档格式提供了很多可能性。虽然归档格式的细节可以十分复杂，但显然不是所有情况都这样，因此我们提供了一些内置的套件描述符。即使你的目标是以某种独特的目录结构来包含项目的依赖，选择项目文件，编写一个定制的套件描述符也不是太费力的事情。</para>

    <para>套件对于很多应用都十分有用，但最有用的地方还是各种应用程序分发包。虽然使用Assembly插件有很多不同的方法，但在创建包含字节码的分发包时，使用标准化的套件描述符构件，同时避免使用moduleSets，是避免问题的两种很可靠的方法。</para>
  </section>
</chapter>
