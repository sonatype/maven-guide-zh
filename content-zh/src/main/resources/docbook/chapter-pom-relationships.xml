<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="pom-relationships">
  <title>项目对象模型</title>

  <section>
    <title>简介</title>

    <para>本章讨论Maven的核心概念——<indexterm class="startofrange" id="pom1">
        <primary>POM (Project Object Model)</primary>
      </indexterm>项目对象模型。在<acronym>POM</acronym>中，项目的坐标和结构被声明，构建被配置，与其它项目的关联也被定义。<filename
    moreinfo="none">pom.xml</filename>文件定义了一个Maven项目。</para>
  </section>

  <section id="pom-relationships-pom">
    <title>POM</title>

    <para>Maven项目，依赖，构建配置，以及构件：所有这些都是要建模和表述的对象。这些对象通过一个名为项目对象模型(Project Object
    Model,
    <acronym>POM</acronym>)的<acronym>XML</acronym>文件描述。这个<acronym>POM</acronym>告诉Maven它正处理什么类型的项目，如何修改默认的行为来从源码生成输出。同样的方式，一个Java
    Web应用有一个<filename
    moreinfo="none">web.xml</filename>文件来描述，配置，及自定义该应用，一个Maven项目则通过一个<indexterm>
        <primary>pom.xml file</primary>
      </indexterm><indexterm>
        <primary>pom.xml file</primary>

        <seealso>POM</seealso>
      </indexterm> <filename
    moreinfo="none">pom.xml</filename>文件定义。该文件是Maven中一个项目的描述性陈述；也是当Maven构建项目的时候需要理解的一份“地图”。</para>

    <para>你可以将<filename moreinfo="none">pom.xml</filename>看成是类似于<filename
    moreinfo="none">Makefile</filename>或者Ant中的<filename
    moreinfo="none">build.xml</filename>。当你使用<acronym>GNU</acronym>
    <emphasis>make</emphasis> 来构建诸如MySQL软件的时候，你通常会有一个名为<filename
    moreinfo="none">Makefile</filename>的文件，它包含了显式的指令来清理，编译，打包以及部署一个应用。在这一点上，Make，Ant，和Maven是相似的，它们都依赖于一个统一命名的文件如<filename
    moreinfo="none">Makefile</filename>，<filename
    moreinfo="none">build.xml</filename>，或者<filename
    moreinfo="none">pom.xml</filename>，但相似的地方也仅此而已。如果你看一下Maven的<filename
    moreinfo="none">pom.xml</filename>，<acronym>POM</acronym>的主要内容是处理描述信息：哪里存放源代码？哪里存放资源文件？打包方式是什么？如果你看一下Ant的<filename
    moreinfo="none">build.xml</filename>文件，你会看到完全不同的东西。那里有显式的指令来执行一些任务，如编译一组Java类。Maven的<acronym>POM</acronym>是声明性的，虽然你可以通过Maven
    Ant插件来引入一些过程式的自定义指令，但大部分时间里，你不需要去了解项目构建的过程细节。</para>

    <para>POM也不只是仅仅针对于构建Java项目。虽然本书的大部分样例都是Java应用，但是在Maven的项目对象模型定义中没有任何Java特定的东西。虽然Maven的默认插件是从一组源码，测试，和资源来构建一个<acronym>JAR</acronym>文件。但你同样可以为一个包含C#源码，使用微软工具处理一些微软私有的二进制文件的项目来定义一个<acronym>POM</acronym>。类似的，你也可以为一本技术书籍定义一个<acronym>POM</acronym>。事实上，本书的源码和本书的样例正是用一个Maven多模块项目组织的，我们使用一个Maven
    Docbook插件，将标准的Docbook
    <acronym>XSL</acronym>应用到一系列章节的<acronym>XML</acronym>文件上。还有人编写了Maven插件来将Adobe
    Flex代码构建成<acronym>SWC</acronym>和<acronym>SWF</acronym>，也还有人使用了Maven来构建C编写的项目。</para>

    <para>我们已经确定了<acronym>POM</acronym>是描述性和声明性的，它不像Ant或者Make那样提供显式的指令，我们也注意到<acronym>POM</acronym>的概念不是特定于Java的。让我们深入更多的细节，看一下<xref
    linkend="fig-pom" />，纵览一下<acronym>POM</acronym>的内容。</para>

    <para><figure id="fig-pom">
        <title>项目对象模型</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="figs/web/pom-relationships_pom-small.png" />
          </imageobject>
        </mediaobject>
      </figure></para>

    <para><acronym>POM</acronym>包含了四类描述和配置：</para>

    <variablelist>
      <varlistentry>
        <term>项目总体信息</term>

        <listitem>
          <para>它包含了一个项目的而名称，项目<indexterm>
              <primary>project information (in pom.xml)</primary>
            </indexterm><indexterm>
              <primary>licensing information (project information)</primary>
            </indexterm><indexterm>
              <primary>organizational information (project
              information)</primary>
            </indexterm><indexterm>
              <primary>developer information (project information)</primary>
            </indexterm><indexterm>
              <primary>pom.xml file</primary>

              <secondary>project information in</secondary>
            </indexterm>的<acronym>URL</acronym>，发起组织，以及项目的开发者贡献者列表和许可证。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>构建设置</term>

        <listitem>
          <para>在这一部分，我们自定义<indexterm>
              <primary>build information (in pom.xml)</primary>
            </indexterm><indexterm>
              <primary>pom.xml file</primary>

              <secondary>build information in</secondary>
            </indexterm>Maven构建的默认行为。我们可以更改源码和测试代码的位置，可以添加新的插件，可以将插件目标绑定到生命周期，我们还可以自定义站点生成参数。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>构建环境</term>

        <listitem>
          <para>构建环境包含了一些能在不同使用环境中<indexterm>
              <primary>build environment</primary>
            </indexterm><indexterm>
              <primary>pom.xml file</primary>

              <secondary>build environment</secondary>
            </indexterm>
          激活的profile。例如，在开发过程中你可能会想要将应用部署到一个而开发服务器上，而在产品环境中你会需要将应用部署到产品服务器上。构建环境为特定的环境定制了构建设置，通常它还会由<filename
          moreinfo="none">~/.m2</filename>中的自定义<indexterm>
              <primary>settings.xml file</primary>
            </indexterm><filename
          moreinfo="none">settings.xml</filename>补充。这个settings文件将会在<xref
          linkend="profiles" />中，以及<xref
          linkend="appendix-settings-details" />中的<xref
          linkend="settings-details" />小节中讨论。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>POM关系</term>

        <listitem>
          <para>一个项目很少孤立存在；它会依赖于其它项目，可能从父项目继承<acronym>POM</acronym>设置，它要定义自身的坐标，可能还会包含子模块。</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <section id="section-super-pom">
      <title>超级POM</title>

      <para>在深入钻研一些样例<acronym>POM</acronym>之前，让我们先快速看一下超级<acronym>POM</acronym>。所有的Maven项目的<acronym>POM</acronym>都扩展自超级<acronym>POM</acronym>。超级<acronym>POM</acronym>定义了一组被所有项目共享的默认设置。它是Maven安装的一部分，可以在<filename>${M2_HOME}/lib</filename>中的<filename>maven-2.0.9-uber.jar</filename>文件中找到。如果你看一下这个<acronym>JAR</acronym>文件，你会看到在包<package>org.apache.maven.project</package>下看到一个名为<filename>pom-4.0.0.xml</filename>的文件。这个Maven的超级<acronym>POM</acronym>如<xref
      linkend="ex-super-pom" />所示。</para>

      <example id="ex-super-pom">
        <title>超级POM</title>

        <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;name&gt;Maven Default Project&lt;/name&gt;

  &lt;repositories&gt;
    &lt;repository&gt;
      &lt;id&gt;central&lt;/id&gt; <co id="coDef-super-1"
            linkends="coRef-super-1" />
      &lt;name&gt;Maven Repository Switchboard&lt;/name&gt;
      &lt;layout&gt;default&lt;/layout&gt;
      &lt;url&gt;http://repo1.maven.org/maven2&lt;/url&gt;
      &lt;snapshots&gt;
        &lt;enabled&gt;false&lt;/enabled&gt;
      &lt;/snapshots&gt;
    &lt;/repository&gt;
  &lt;/repositories&gt;

  &lt;pluginRepositories&gt;
    &lt;pluginRepository&gt;
      &lt;id&gt;central&lt;/id&gt; <co id="coDef-super-2"
            linkends="coRef-super-2" />
      &lt;name&gt;Maven Plugin Repository&lt;/name&gt;
      &lt;url&gt;http://repo1.maven.org/maven2&lt;/url&gt;
      &lt;layout&gt;default&lt;/layout&gt;
      &lt;snapshots&gt;
        &lt;enabled&gt;false&lt;/enabled&gt;
      &lt;/snapshots&gt;
      &lt;releases&gt;
        &lt;updatePolicy&gt;never&lt;/updatePolicy&gt;
      &lt;/releases&gt;
    &lt;/pluginRepository&gt;
  &lt;/pluginRepositories&gt;

  &lt;build&gt; <co id="coDef-super-3" linkends="coRef-super-3" />
    &lt;directory&gt;target&lt;/directory&gt;
    &lt;outputDirectory&gt;target/classes&lt;/outputDirectory&gt;
    &lt;finalName&gt;${pom.artifactId}-${pom.version}&lt;/finalName&gt;
    &lt;testOutputDirectory&gt;target/test-classes&lt;/testOutputDirectory&gt;
    &lt;sourceDirectory&gt;src/main/java&lt;/sourceDirectory&gt;
    &lt;scriptSourceDirectory&gt;src/main/scripts&lt;/scriptSourceDirectory&gt;
    &lt;testSourceDirectory&gt;src/test/java&lt;/testSourceDirectory&gt;
    &lt;resources&gt;
      &lt;resource&gt;
        &lt;directory&gt;src/main/resources&lt;/directory&gt;
      &lt;/resource&gt;
    &lt;/resources&gt;
    &lt;testResources&gt;
      &lt;testResource&gt;
        &lt;directory&gt;src/test/resources&lt;/directory&gt;
      &lt;/testResource&gt;
    &lt;/testResources&gt;
  &lt;/build&gt;

      &lt;pluginManagement&gt;<co id="coDef-super-4" linkends="coRef-super-4" />
       &lt;plugins&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt;
           &lt;version&gt;1.1&lt;/version&gt;
         &lt;/plugin&gt;       
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2-beta-1&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.0.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.0&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.3&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-ear-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.3.1&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-ejb-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.1&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.4&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-plugin-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.3&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-rar-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;                
           &lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.0-beta-7&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;                
           &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-site-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.0-beta-6&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.0.4&lt;/version&gt;
         &lt;/plugin&gt;         
         &lt;plugin&gt;
            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.4.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.1-alpha-1&lt;/version&gt;
         &lt;/plugin&gt;
       &lt;/plugins&gt;
     &lt;/pluginManagement&gt;
  
  &lt;reporting&gt;
    &lt;outputDirectory&gt;target/site&lt;/outputDirectory&gt;
  &lt;/reporting&gt;
&lt;/project&gt;</programlisting>
      </example>

      <para>这个超级<acronym>POM</acronym>定义了一些由所有项目继承的标准配置变量。对这些变量的简单解释如下：</para>

      <calloutlist>
        <callout arearefs="coDef-super-1" id="coRef-super-1">
          <para>默认的超级<acronym>POM</acronym>定义了一个单独的远程Maven仓库，ID为<literal>central</literal>。这是所有Maven客户端默认配置访问的中央Maven仓库。该配置可以通过一个自定义的<filename
          moreinfo="none">settings.xml</filename>文件来覆盖。注意这个默认的超级<acronym>POM</acronym>关闭了从中央Maven仓库下载snapshot构件的功能。如果你需要使用一个snapshot仓库，你就要在你的<filename
          moreinfo="none">pom.xml</filename>或者<filename
          moreinfo="none">settings.xml</filename>中自定义仓库设置。Settings和profile将会在<xref
          linkend="profiles" />中和<xref
          linkend="appendix-settings-details" />中的<xref
          linkend="settings-details" />小节中具体介绍。</para>
        </callout>

        <callout arearefs="coDef-super-2" id="coRef-super-2">
          <para>中央Maven仓库同时也包含Maven插件。默认的插件仓库就是这个中央仓库。Snapshot被关闭了，而且更新策略被设置成了“从不”，这意味着Maven将永远不会自动更新一个插件，即使新版本的插件发布了。</para>
        </callout>

        <callout arearefs="coDef-super-3" id="coRef-super-3">
          <para><sgmltag>build</sgmltag>元素设置Maven标准目录布局中那些目录的默认值。</para>
        </callout>

        <callout arearefs="coDef-super-4" id="coRef-super-4">
          <para>从Maven
          2.0.9开始，超级<acronym>POM</acronym>为核心插件提供了默认版本。这么做是为那些没有在它们<acronym>POM</acronym>中指定插件版本的用户提供一些稳定性。</para>
        </callout>
      </calloutlist>

      <figure>
        <title>超级POM永远是最基础的父POM</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="figs/web/pom-relationships_pom-inherit-simple-super.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>最简单的POM</title>

      <para>所有的Maven
      <acronym>POM</acronym>都继承自超级<acronym>POM</acronym>（在前面的小节<xref
      linkend="section-super-pom" />中介绍）。如果你只是编写一个简单的项目，从<filename
      moreinfo="none">src/main/java</filename>目录的源码生成一个<acronym>JAR</acronym>，想要运行<filename
      moreinfo="none">src/test/java</filename>中的JUnit测试，想要使用<command
      moreinfo="none">mvn
      site</command>构建一个项目站点，你不需要自定义任何东西。在这种情况下，你所需要的，是如<xref
      linkend="ex-simplest-pom" />所示的一个最简单的<acronym>POM</acronym>。这个<acronym>POM</acronym>定义了<varname>groupId</varname>，<varname>artifactId</varname>和<varname>version</varname>：这三项是所有项目都需要的坐标。</para>

      <example id="ex-simplest-pom">
        <title>最简单的POM</title>

        <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.ch08&lt;/groupId&gt;
  &lt;artifactId&gt;simplest-project&lt;/artifactId&gt;
  &lt;version&gt;1&lt;/version&gt;
&lt;/project&gt;</programlisting>
      </example>

      <para>对一个简单的项目来说，这样一个简单的<acronym>POM</acronym>已经足够了——例如，一个生成单个<acronym>JAR</acronym>文件的Java类库。它不需要和任何其它项目关联，没有任何依赖，也缺少基本的信息如名字和<acronym>URL</acronym>。如果创建了这个文件，然后创建了一个子目录<filename
      moreinfo="none">src/main/java</filename>，并且放入了一些源代码，运行<command
      moreinfo="none">mvn package</command>将会生成一个名为<filename
      moreinfo="none">target/simple-project-1.jar</filename>的<acronym>JAR</acronym>文件。</para>
    </section>

    <section>
      <title>有效POM</title>

      <para>最简单的<acronym>POM</acronym>能带给我们“有效<acronym>POM</acronym>”的概念。由于<acronym>POM</acronym>可以从其它<acronym>POM</acronym>继承配置，你就需要一直考虑超级<acronym>POM</acronym>，再加上任何父<acronym>POM</acronym>，以及最后当前项目的<acronym>POM</acronym>这些所有配置的结合。Maven开始于超级<acronym>POM</acronym>，然后使用一个或多个父<acronym>POM</acronym>覆盖默认配置，最后使用当前项目的<acronym>POM</acronym>来覆盖之前生成的配置结果。最后你得到了一个混合了各个<acronym>POM</acronym>配置的有效<acronym>POM</acronym>。如果你想要查看项目的有效<acronym>POM</acronym>，你需要运行Maven
      Help插件的<varname>effective-pom</varname>目标，该插件已经之前在小节<xref
      linkend="sect-help-plugin-install" />中介绍。在<filename
      moreinfo="none">pom.xml</filename>文件所在的目录执行以下的命令以运行<varname>effective-pom</varname>目标：</para>

      <screen>$ <command>mvn help:effective-pom</command></screen>

      <para>执行<varname>effective-pom</varname>目标应该会打印出一个<acronym>XML</acronym>文档，该文档的内容是超级<acronym>POM</acronym>和<xref
      linkend="ex-simplest-pom" />中<acronym>POM</acronym>内容的合并。</para>
    </section>

    <section>
      <title>真正的POM</title>

      <para>这里我们就不再设计一组<acronym>POM</acronym>，<indexterm>
          <primary>real POMs</primary>
        </indexterm>一步步的来看了，你可以自己查看一下<xref
      linkend="part-example" />中的样例。Maven就像是变色龙，你可以挑选你想要使用的特性。对于一些开源项目来说，列出开发者和贡献者，生成整洁的项目文档，使用Maven
      Release插件来自动管理版本发布可能很有价值。但另一方面，一些在大公司环境下的小型团队中工作的人可能对Maven的分发管理功能或者开发成员列表功能不感兴趣。本章的剩余部分将会单独的讨论<acronym>POM</acronym>的特性。我们不会用数十页的一组相关<acronym>POM</acronym>来炮轰你，而会集中于为<acronym>POM</acronym>中的特定的小节创建优良的参考内容。本章，我们也会讨论<acronym>POM</acronym>之间的关系，但不会在这里展示这样一个项目。如果你想要看这样一个示例，请参考<xref
      linkend="multimodule-web-spring" />。</para>
    </section>
  </section>

  <section>
    <title>POM语法</title>

    <para>Maven项目<indexterm class="startofrange" id="pom2">
        <primary>POM (Project Object Model)</primary>

        <secondary>syntax</secondary>
      </indexterm>中的<acronym>POM</acronym>永远都是基础目录下的一个名为<filename
    moreinfo="none">pom.xml</filename>的文件。这个<acronym>XML</acronym>文档可以以<acronym>XML</acronym>声明开头，或者你也可以选择忽略它。所有的<acronym>POM</acronym>的值都通过<acronym>XML</acronym>元素的形式体现。</para>

    <section id="sect-versions">
      <title>项目版本</title>

      <para>一个Maven项目发布版本号用<sgmltag>version</sgmltag><indexterm>
          <primary>major versions (projects)</primary>
        </indexterm><indexterm>
          <primary>minor versions (projects)</primary>
        </indexterm><indexterm>
          <primary>incremental versions (projects)</primary>
        </indexterm><indexterm>
          <primary>qualifiers for project versions</primary>
        </indexterm><indexterm>
          <primary>project versions, about</primary>

          <seealso>version attribute</seealso>
        </indexterm><indexterm>
          <primary>version attribute (pom.xml)</primary>
        </indexterm><indexterm>
          <primary>project versions, about</primary>
        </indexterm>编码，用来分组和排序发布。Maven中的版本包含了以下部分：主版本，次版本，增量版本，和限定版本号。一个版本中，这些部分对应如下的格式：</para>

      <screen>&lt;major version&gt;.&lt;minor version&gt;.&lt;incremental version&gt;-&lt;qualifier&gt;
</screen>

      <para>例如：版本“1.3.5”由一个主版本1，一个次版本3，和一个增量版本5。而一个版本“5”只有主版本5，没有次版本和增量版本。限定版本用来标识里程碑构建：alpha和beta发布，限定版本通过连字符与主版本，次版本或增量版本隔离。例如，版本“1.3-beta-01”有一个主版本1，次版本3，和一个限定版本“beta-01”。</para>

      <para>当你想要在你的<acronym>POM</acronym>中使用版本界限的时候，保持你的版本号与标准一致十分重要。在<xref
      linkend="section-version-ranges" />中介绍的版本界限，允许你声明一个带有版本界限的依赖，只有你遵循标准的时候该功能才被支持。因为Maven根据本节中介绍的版本号格式来对版本进行排序。</para>

      <para>如果你的版本号与格式&lt;主版本&gt;.&lt;次版本&gt;.&lt;增量版本&gt;-&lt;限定版本&gt;相匹配，它就能被正确的比较；“1.2.3”将被评价成是一个比“1.0.2”更新的构件，这种比较基于主版本，次版本，和增量版本的数值。如果你的版本发布号没有符合本节介绍的标准，那么你的版本号只会根据字符串被比较；“1.0.1b”和“1.2.0b”会使用字符串比较。</para>

      <section>
        <title>版本构建号</title>

        <para>我们还需要对版本号的<indexterm>
            <primary>ordering of version qualifiers</primary>
          </indexterm><indexterm>
            <primary>qualifiers for project versions</primary>

            <secondary>ordering of</secondary>
          </indexterm>限定版本进行排序。以版本号“1.2.3-alpha-2”和“1.2.3-alpha-10”为例，这里“alpha-2”对应了第二次alpha构建，而“alpha-10”对应了第十次alpha构建。虽然“alpha-10”应该被认为是比“alpha-2”更新的构建，但Maven排序的结果是“alpha-10”比“alpha-2”更旧，问题的原因就是我们刚才讨论的Maven处理版本号的方式。</para>

        <para>Maven会将限定版本后面的数字认作一个构建版本。换句话说，这里限定版本是“alpha”，而构建版本是2。虽然Maven被设计成将构建版本和限定版本分离，但目前这种解析还是失效的。因此，“alpha-2”和“alpha-10”是使用字符串进行比较的，而根据字母和数字“alpha-10”在“alpha-2”前面。要避开这种限制，你需要对你的限定版本使用一些技巧。如果你使用“alpha-02”和“alpha-10”，这个问题就消除了，一旦Maven能正确的解析版本构建号之后，这种工作方式也还是能用。</para>
      </section>

      <section>
        <title>SNAPSHOT版本</title>

        <para>Maven版本可以包含一个字符串字面量来表示项目<indexterm>
            <primary>snapshot versions</primary>
          </indexterm>正处于活动的开发状态。如果一个版本包含字符串“SNAPSHOT”，Maven就会在安装或发布这个组件的时候将该符号展开为一个日期和时间值，转换为<acronym>UTC</acronym>（协调世界时）。例如，如果你的项目有个版本为“1.0-SNAPSHOT”并且你将这个项目的构件部署到了一个Maven仓库，如果你在<acronym>UTC</acronym>2008年2月7号下午11:08部署了这个版本，Maven就会将这个版本展开成“1.0-20080207-230803-1”。换句话说，当你发布一个snapshot，你没有发布一个软件模块，你只是发布了一个特定时间的快照版本。</para>

        <para>那么为什么要使用这种方式呢？SNAPSHOT版本在项目活动的开发过程中使用。如果你的项目依赖的一个组件正处于开发过程中，你可以依赖于一个SNAPSHOT版本，在你运行构建的时候Maven会定期的从仓库下载最新的snapshot。类似的，如果你系统的下一个发布版本是“1.4”你的项目需要拥有一个“1.4-SNAPSHOT”的版本，之后它被正式发布。</para>

        <para>作为一个默认设置，Maven不会从远程仓库检查SNAPSHOT版本，要依赖于SNAPSHOT版本，用户必须在<acronym>POM</acronym>中使用<sgmltag>repository</sgmltag>和<sgmltag>pluginRepository</sgmltag>元素显式的开启下载snapshot的功能。</para>

        <para>当发布一个项目的时候，你需要解析所有对SNAPSHOT版本的依赖至正式发布的版本。如果一个项目依赖于SNAPSHOT，那么这个依赖很不稳定，它随时可能变化。发布到非snapshot的Maven仓库（如<ulink
        url="http://repo1.maven.org/maven2">http://repo1.maven.org/maven2</ulink>）的构件不能依赖于任何SNAPSHOT版本，因为Maven的超级<acronym>POM</acronym>对于中央仓库关闭了snapshot。SNAPSHOT版本只用于开发过程。</para>
      </section>

      <section>
        <title>LATEST 和 RELEASE 版本</title>

        <para>当你依赖于一个插件或一个依赖，你可以使用特殊的版本值LATEST或者RELEASE。LATEST是指某个特定构件最新的发布版或者快照版(snapshot)，最近被部署到某个特定仓库的构件。RELEASE是指仓库中最后的一个非快照版本。总得来说，设计软件去依赖于一个构件的不明确的版本，并不是一个好的实践。如果你处于软件开发过程中，你可能想要使用RELEASE或者LATEST，这么做十分方便，你也不用为每次一个第三方类库新版本的发布而去更新你配置的版本号。但当你发布软件的时候，你总是应该确定你的项目依赖于某个特定的版本，以减少构建的不确定性，免得被其它不受你控制的软件版本影响。如果无论如何你都要使用LATEST和RELEASE，那么要小心使用。</para>

        <para>Maven
        2.0.9之后，Maven在超级POM中锁住了一些通用及核心Maven插件的版本号，以将某个特定版本Maven的核心Maven插件组标准化。这个变化在Maven
        2.0.9中被引入，为Maven构建带来了稳定性和重现性。在Maven
        2.0.9之前，Maven会自动将核心插件更新至LATEST版本。这种行为导致了很多奇怪现象，因为新版本的插件可能会有一些bug，甚至是行为变更，这往往使得原来的构建失败。当Maven自动更新核心插件的时候，我们就不能保证构建的重现性，因为插件随时都可能从中央仓库更新至一个新的版本。从Maven
        2.0.9开始，Maven从根本上锁住了一组核心插件的版本。非核心插件，或者说没有在超级POM中指定版本的插件仍然会使用LATEST版本去从仓库获取构件。由于这个原因，你在构件中使用任何一个自定义非核心插件的时候，都应该显式的指定版本号。</para>
      </section>
    </section>

    <section>
      <title>属性引用</title>

      <para>一个<acronym>POM</acronym>可以通过一对大括弧和前面一个美元符号来包含 <indexterm>
          <primary>properties</primary>

          <secondary>referencing in pom.xml</secondary>
        </indexterm><indexterm>
          <primary>references to properties, in pom.xml</primary>
        </indexterm>对属性的引用。例如，考虑如下的<acronym>POM</acronym>：</para>

      <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;project-a&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;build&gt;
    &lt;finalName&gt;${project.groupId}-${project.artifactId}&lt;/finalName&gt;
  &lt;/build&gt;
&lt;/project&gt;</programlisting>

      <para>如果你将这段<acronym>XML</acronym>放入<filename>pom.xml</filename>，然后运行<command>mvn
      help:effective-pom</command>，你会看到输出包含这一行：</para>

      <programlisting language="xml">...
&lt;finalName&gt;org.sonatype.mavenbook-project-a&lt;/finalName&gt;
...</programlisting>

      <para>在Maven读取一个<acronym>POM</acronym>的时候，它会在载入<acronym>POM</acronym>
      <acronym>XML</acronym>的时候替换这些属性的引用。在Maven的高级使用中Maven属性经常出现，这些属性和其它系统中的属性如Ant或者Velocity类似。它们是一些由<varname>${...}</varname>划界的变量。Maven提供了三个隐式的变量，可以用来访问环境变量，<acronym>POM</acronym>信息，和Maven
      Settings：</para>

      <variablelist>
        <varlistentry>
          <term>env</term>

          <listitem>
            <para><varname>env</varname>变量 <indexterm>
                <primary>env variable</primary>
              </indexterm><indexterm>
                <primary>implicit variables, list of</primary>
              </indexterm>暴露了你操作系统或者shell的环境变量。例如，在Maven
            POM中一个对<varname>${env.PATH}</varname>的引用将会被<varname>${PATH}</varname>环境变量替换（或者Windows中的<varname>%PATH%</varname>）。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>project</term>

          <listitem>
            <para><varname>project</varname>变量暴露了<acronym><indexterm>
                <primary>project variable</primary>
              </indexterm>POM</acronym>。你可以使用点标记（.）的路径来引用<acronym>POM</acronym>元素的值。例如，在本节中我们使用过<varname>groupId</varname>和<varname>artifactId</varname>来设置构建配置中的<sgmltag>finalName</sgmltag>元素。这个属性引用的语法是：<code>${project.groupId}-${project.</code><code>artifactId}</code>。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>settings</term>

          <listitem>
            <para><varname>settings</varname>变量暴露了Maven
            settings信息。可以使用点标记（.）的路径来引用<filename
            moreinfo="none">settings.xml</filename>文件中元素的值。例如，<varname>${settings.offline}</varname>会引用<filename
            moreinfo="none">~/.m2/settings.xml</filename>文件中<sgmltag>offline</sgmltag>元素的值。</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <note>
        <para>你可能在老的构建中看到使用<varname>${pom.xxx}</varname>或者仅仅<varname>${xxx}</varname>来引用<acronym>POM</acronym>属性。这些方法已被弃用，我们只应该使用<varname>${project.xxx}</varname>。</para>
      </note>

      <para>除了这三个隐式的变量，你还可以<indexterm>
          <primary>system properties, referencing</primary>
        </indexterm>引用系统属性，以及任何在Maven
      <acronym>POM</acronym>中和构建profile中自定义的属性组。</para>

      <variablelist>
        <varlistentry>
          <term>Java系统属性</term>

          <listitem>
            <para>所有可以通过<classname>java.lang.System</classname>中<methodname>getProperties()</methodname>方法访问的属性<indexterm>
                <primary>Java system properties, referencing</primary>
              </indexterm>都被暴露成<acronym>POM</acronym>属性。一些系统属性的例子是：<varname>${user.name}</varname>，<varname
            role="keep-together">${user.home}</varname>，<varname>${java.home}</varname>，和<varname>${os.name}</varname>。一个完整的系统属性列表可以在<classname>java.lang.System</classname>类的Javadoc中找到。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>x</term>

          <listitem>
            <para>我们还可以通过<filename
            moreinfo="none">pom.xml</filename>或者<filename moreinfo="none"
            role="keep-together">settings.xml</filename>中的<varname>properties</varname>元素设置自己的属性，或者还可以使用外部载入的文件中属性。如果你在<filename
            moreinfo="none">pom.xml</filename>中设置了一个名为<varname>fooBar</varname>的属性，该属性就可以通过<varname>${fooBar}</varname>引用。当你构建一个系统，它针对不同的部署环境过滤资源，那么自定义属性就变得十分有用。这里是在<acronym>POM</acronym>中设置<literal>${foo}=bar</literal>的语法：</para>

            <programlisting language="xml">&lt;properties&gt;
  &lt;foo&gt;bar&lt;/foo&gt;
&lt;/properties&gt;</programlisting>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>要了解更复杂的可用属性列表，查看<xref linkend="resource-filtering" />。</para>
    </section>
  </section>

  <section>
    <title>项目依赖</title>

    <para>Maven可以管理内部和外部依赖。<indexterm class="startofrange" id="pom3a">
        <primary>dependencies</primary>
      </indexterm><indexterm>
        <primary>POM (Project Object Model)</primary>

        <secondary>project dependencies</secondary>

        <see>dependencies</see>
      </indexterm><indexterm>
        <primary>project dependencies</primary>

        <see>dependencies</see>
      </indexterm><indexterm>
        <primary>external dependencies</primary>
      </indexterm><indexterm>
        <primary>internal dependencies</primary>

        <seealso>dependencies</seealso>
      </indexterm><indexterm>
        <primary>internal dependencies</primary>

        <seealso>dependencies</seealso>
      </indexterm>一个Java项目的外部依赖可能是如Plexus，Spring
    Framework，或者Log4J的类库。一个内部的依赖就像在“一个简单的web应用”中描述的那样，web项目依赖于另外一个包含服务类，模型类，或者持久化逻辑的项目。<xref
    linkend="ex-dependency" />展示了一些项目依赖的例子。</para>

    <para><example id="ex-dependency">
        <title>项目依赖</title>

        <programlisting language="xml">&lt;project&gt;
  ...
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.codehaus.xfire&lt;/groupId&gt;
      &lt;artifactId&gt;xfire-java5&lt;/artifactId&gt;
      &lt;version&gt;1.2.5&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.geronimo.specs&lt;/groupId&gt;
      &lt;artifactId&gt;geronimo-servlet_2.4_spec&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  ...
&lt;/project&gt;
</programlisting>
      </example></para>

    <para>这里的第一个依赖是对于来自Codehaus的XFire
    <acronym>SOAP</acronym>库的编译范围（compile）依赖。如果你的项目在编译，测试，和运行中都依赖于一个类库，你就要使用这种依赖。第二种依赖是一个对于JUnit测试范围（test）的依赖。当你只有在测试的时候才引用类库的时候，你就要使用测试范围依赖。<xref
    linkend="ex-dependency" />中最后一个依赖是对于由Apache Geronimo项目实现的Servlet 2.4
    <acronym>API</acronym>的依赖。最后一项依赖的范围是已提供的（provided）依赖。当你的开发过程只有在编译和测试时需要一个类库，而该类库在运行的时候由容器提供，那么你就需要使用已提供范围的依赖。</para>

    <section id="section-dependency-scope">
      <title>依赖范围</title>

      <para><xref
      linkend="ex-dependency" />简要介绍了三种依赖范围：<literal>compile</literal>，<literal>test</literal>，和<literal>provided</literal>。范围控制哪些依赖在哪些classpath中可用，哪些依赖包含在一个应用中。让我们详细看一下每一种范围：</para>

      <variablelist>
        <varlistentry>
          <term>compile（编译范围）</term>

          <listitem>
            <para><literal>compile</literal>是默认的范围；如果没有提供一个范围，那该依赖的范围就是<indexterm>
                <primary>compile dependencies</primary>
              </indexterm>编译范围。编译范围依赖在所有的classpath中可用，同时它们也会被打包。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>provided（已提供范围）</term>

          <listitem>
            <para><literal>provided</literal>依赖只有在当<acronym>JDK</acronym>或者一个容器已提供该依赖之后才使用。例如，如果你开发了一个web应用，你可能在编译classpath中需要可用的Servlet
            <acronym>API</acronym>来编译一个servlet，但是你不会想要在打包好的<acronym>WAR</acronym>中包含这个Servlet
            <acronym>API</acronym>；这个Servlet <acronym>API</acronym>
            <acronym>JAR</acronym>由你的应用服务器或者servlet容器提供。已提供范围的依赖在编译classpath（不是运行时）可用。它们不是传递性的，也不会被打包。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>runtime（运行时范围）</term>

          <listitem>
            <para><literal>runtime</literal>依赖<indexterm>
                <primary>runtime dependencies</primary>
              </indexterm>在运行和测试系统的时候需要，但在编译的时候不需要。比如，你可能在编译的时候只需要<acronym>JDBC</acronym>
            <acronym>API</acronym>
            <acronym>JAR</acronym>，而只有在运行的时候才需要<acronym>JDBC</acronym>驱动实现。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>test（测试范围）</term>

          <listitem>
            <para><literal>test</literal>范围依赖<indexterm>
                <primary>dependencies</primary>

                <secondary>test-scoped</secondary>
              </indexterm><indexterm>
                <primary>test-scoped dependencies</primary>
              </indexterm><indexterm>
                <primary>unit tests</primary>

                <secondary>test-scoped dependencies</secondary>
              </indexterm><indexterm>
                <primary>testing</primary>

                <secondary>using test-scoped dependencies</secondary>
              </indexterm> 在一般的 编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用。测试范围依赖在之前的<xref
            linkend="section-test-scope" />中介绍过。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>system（系统范围）</term>

          <listitem>
            <para><literal>system</literal>范围依赖与<literal>provided</literal>类似，但是你必须显式的提供一个对于本地系统中<acronym>JAR</acronym>文件的路径。这么做是为了允许基于本地对象编译，而这些对象是系统类库的一部分。这样的构件应该是一直可用的，Maven也不会在仓库中去寻找它。如果你将一个依赖范围设置成系统范围，你必须同时提供一个<sgmltag>systemPath</sgmltag>元素。注意该范围是不推荐使用的（你应该一直尽量去从公共或定制的Maven仓库中引用依赖）。</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section>
      <title>可选依赖</title>

      <para>假定你正在开发一个类库 <indexterm>
          <primary>optional dependencies</primary>
        </indexterm><indexterm>
          <primary>dependencies</primary>

          <secondary>optional</secondary>
        </indexterm>，该类库提供高速缓存行为。你想要使用一些已存在的能够提供文件系统快速缓存和分布式快速缓存的类库，而非从空白开始写自己的快速缓存系统。再假定你想要能让最终用户选择使用文件系统高速缓存或者内存分布式高速缓存。为了缓存文件系统，你会要使用免费的类库如EHCache（<ulink
      url="http://ehcache.sourceforge.net/">http://ehcache.sourceforge.net/</ulink>），为了分布式内存缓存，你想要使用免费的类库如SwarmCache（<ulink
      url="http://swarmcache.sourceforge.net/">http://swarmcache.sourceforge.net/</ulink>）。你将编写一个接口，并且创建一个可以被配置成使用EHCache或者SwarmCache的类库，但是你想要避免为所有依赖于你类库的项目添加全部这两个缓存类库的的依赖。</para>

      <para>换句话说，编译这个项目的时候你需要两个依赖类库，但是你不希望在使用你类库的项目中，这两个依赖类库同时作为传递性运行时依赖出现。你可以使用如<xref
      linkend="ex-optional-depend" />中的可选依赖来完成这个任务。</para>

      <example id="ex-optional-depend">
        <title>声明可选依赖</title>

        <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;my-project&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;
      &lt;artifactId&gt;ehcache&lt;/artifactId&gt;
      &lt;version&gt;1.4.1&lt;/version&gt;
      &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;swarmcache&lt;/groupId&gt;
      &lt;artifactId&gt;swarmcache&lt;/artifactId&gt;
      &lt;version&gt;1.0RC2&lt;/version&gt;
      &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;log4j&lt;/groupId&gt;
      &lt;artifactId&gt;log4j&lt;/artifactId&gt;
      &lt;version&gt;1.2.13&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting>
      </example>

      <para>在你将这些依赖声明为可选之后，你就需要在依赖于<varname>my-project</varname>的项目中显式的引用对应的依赖。例如，如果你正编写一个应用，它依赖于<varname>my-project</varname>，并且想要使用EHCache实现，你就需要在你项目添加如下的<sgmltag>dependency</sgmltag>元素。</para>

      <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;my-application&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
      &lt;artifactId&gt;my-project&lt;/artifactId&gt;
      &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;
      &lt;artifactId&gt;swarmcache&lt;/artifactId&gt;
      &lt;version&gt;1.4.1&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting>

      <para>在理想的世界中，你不需要使用可选依赖。你可以将EHCache相关的代码放到<varname>my-project-ehcache</varname>子模块中，将SwarmCache相关的代码放到<varname>my-project-swarmcache</varname>子模块中，而非创建一个带有一系列可选依赖的大项目。这样，其它项目就可以只引用特定实现的项目，发挥传递性依赖的功效，而不用去引用<varname>my-project</varname>项目，再自己声明特定的依赖。</para>
    </section>

    <section id="section-version-ranges">
      <title>依赖版本界限</title>

      <para>你并不是必须为依赖声明某个特定的版本，<indexterm>
          <primary>version attribute (pom.xml)</primary>

          <secondary>dependency version ranges</secondary>
        </indexterm><indexterm>
          <primary>project versions, about</primary>

          <secondary>dependency version ranges</secondary>
        </indexterm><indexterm>
          <primary>ranges for dependency versions</primary>
        </indexterm>你可以指定一个满足给定依赖的版本界限。例如，你可以指定你的项目依赖于JUnit的3.8或以上版本，或者说依赖于JUnit
      1.2.10和1.2.14之间的某个版本。你可以使用如下的字符来围绕一个或多个版本号，来实现版本界限。</para>

      <variablelist>
        <varlistentry>
          <term role="plain">(, )</term>

          <listitem>
            <para>不包含量词</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term role="plain">[, ]</term>

          <listitem>
            <para>包含量词</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>例如，如果你想要访问JUnit任意的大于等于3.8但小于4.0的版本，你的依赖可以如<xref
      linkend="ex-dep-range" />编写：</para>

      <para><example id="ex-dep-range">
          <title>指定一个依赖界限：JUnit 3.8 - JUnit 4.0</title>

          <programlisting language="xml">&lt;dependency&gt;
  &lt;groupId&gt;junit&lt;/groupId&gt;
  &lt;artifactId&gt;junit&lt;/artifactId&gt;
  &lt;version&gt;[3.8,4.0)&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</programlisting>
        </example></para>

      <para>如果想要依赖JUnit任意的不大于3.8.1的版本<indexterm>
          <primary>upper boundaries (version ranges)</primary>
        </indexterm><indexterm>
          <primary>inclusive boundaries (version ranges)</primary>
        </indexterm><indexterm>
          <primary>lower boundaries (version ranges)</primary>
        </indexterm><indexterm>
          <primary>exclusive boundaries (version ranges)</primary>
        </indexterm><indexterm>
          <primary>boundaries for version ranges, specifying</primary>
        </indexterm>，你可以只指定一个上包含边界，如<xref
      linkend="ex-dep-range-2" />所示：</para>

      <example id="ex-dep-range-2">
        <title>指定一个依赖界限：JUnit &lt;= 3.8.1</title>

        <programlisting language="xml">&lt;dependency&gt;
  &lt;groupId&gt;junit&lt;/groupId&gt;
  &lt;artifactId&gt;junit&lt;/artifactId&gt;
  &lt;version&gt;[,3.8.1]&lt;/version&gt;ex-de
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</programlisting>
      </example>

      <para>在逗号前面或者后面的版本不是必须的，这种空缺意味着正无穷或者负无穷。例如，“[4.0,)”意思是任何大于等于4.0的版本，“(,2.0)”意思是任意小于2.0的版本。“[1.2]”意思是只有版本1.2，没有其它。</para>

      <note>
        <para>当声明一个“正常的”版本如JUnit
        3.8.2，内部它其实被表述成“允许任何版本，但最好是3.8.2”。意思是当侦测到版本冲突的时候，Maven会使用冲突算法来选择最好的版本。如果你指定[3.8.2]，它意味只有3.8.2会被使用，没有其它。如果其它什么地方有一个版本指定了[3.8.1]，你会得到一个构建失败报告，告诉你有版本冲突。我指出这一点是要让你知道有这一选项，但要保守的使用它，只有在确实需要的时候才使用。更好的做法是通过<sgmltag>dependencyManagement</sgmltag>来解决冲突。</para>
      </note>
    </section>

    <section>
      <title>传递性依赖</title>

      <para>一个传递性依赖就是对于一个依赖的依赖。<indexterm>
          <primary>transitive dependencies</primary>
        </indexterm><indexterm>
          <primary>dependencies</primary>

          <secondary>transitive</secondary>

          <see>transitive dependencies</see>
        </indexterm>如果project-a依赖于project-b，而后者接着依赖于project-c，那么project-c就被认为是project-a的传递性依赖。如果<varname>project-c</varname>依赖于<varname>project-d</varname>，那么<varname>project-d</varname>就也被认为是<varname>project-a</varname>的传递性依赖。Maven的部分吸引力是由于它能够管理传递性依赖，并且能够帮助开发者屏蔽掉跟踪所有编译期和运行期依赖的细节。你可以只依赖于一些包如Spring
      Framework，而不用担心Spring Framework的所有依赖，Maven帮你自动管理了，你不用自己去详细了解配置。</para>

      <para>Maven是怎样完成这件事情的呢？它建立一个依赖图，并且处理一些可能发生的冲突和重叠。例如，如果Maven看到有两个项目依赖于同样的<varname>groupId</varname>和<varname>artifactId</varname>，它会自动整理出使用哪个依赖，选择那个最新版本的依赖。虽然这听起来很方便，但在一些边界情况中，传递性依赖会造成一些配置问题。在这种情况下，你可以使用依赖排除。</para>

      <section>
        <title>传递性依赖和范围</title>

        <para><xref
        linkend="section-dependency-scope" />中提到的每种依赖范围不仅仅影响声明项目中的依赖范围，它也对所传递性依赖起作用。表达该信息最简单的方式是通过一张表来表述，如<xref
        linkend="table-transitive-dep-and-scope" />。最顶层一行代表了传递性依赖的范围。最左边的一列代表了直接依赖的范围。行与列的交叉就是为某个传递性依赖指定的范围。表中的空格意思是该传递性依赖被忽略。</para>

        <para><table id="table-transitive-dep-and-scope">
            <title>范围如何影响传递性依赖</title>

            <tgroup cols="5">
              <thead>
                <row>
                  <entry>直接范围</entry>

                  <entry>传递性范围</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry></entry>

                  <entry><emphasis>compile</emphasis></entry>

                  <entry><emphasis>provided</emphasis></entry>

                  <entry><emphasis>runtime</emphasis></entry>

                  <entry><emphasis>test</emphasis></entry>
                </row>

                <row>
                  <entry><emphasis>compile</emphasis></entry>

                  <entry>compile</entry>

                  <entry>-</entry>

                  <entry>runtime</entry>

                  <entry>-</entry>
                </row>

                <row>
                  <entry><emphasis>provided</emphasis></entry>

                  <entry>provided</entry>

                  <entry>provided</entry>

                  <entry>provided</entry>

                  <entry>-</entry>
                </row>

                <row>
                  <entry><emphasis>runtime</emphasis></entry>

                  <entry>runtime</entry>

                  <entry>-</entry>

                  <entry>runtime</entry>

                  <entry>-</entry>
                </row>

                <row>
                  <entry><emphasis>test</emphasis></entry>

                  <entry>test</entry>

                  <entry>-</entry>

                  <entry>test</entry>

                  <entry>-</entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>

        <para>要阐明传递性依赖范围到直接依赖范围的关系，考虑如下例子。如果<varname>project-a</varname>包含一个对于<varname>project-b</varname>的测试范围依赖，后者包含一个对于<varname>project-c</varname>的编译范围依赖。<varname>project-c</varname>将会是<varname>project-a</varname>的测试范围传递性依赖。</para>

        <para>你可以将这看成是一个作用于依赖范围上的传递性边界。那些已提供范围和测试范围的传递性依赖往往不对项目产生影响。该规则的例外是已提供范围传递性依赖到已提供范围直接依赖还是项目的一个已提供范围依赖。编译范围和运行时范围的传递性依赖通常会影响那个一个项目，无论它的直接依赖范围是什么。编译范围的传递性依赖将会和直接依赖产生与后者相同范围的的结果。运行时范围的传递性依赖也会和直接依赖产生与后者相同范围的结果，除非当直接依赖是编译范围的时候，结果是运行时范围。</para>
      </section>
    </section>

    <section>
      <title>冲突解决</title>

      <para>有很多时候你需要排除一个传递性依赖，比如当你依赖于一个项目，后者又继而依赖于另外一个项目，但你的希望是，要么整个的排除这个传递性依赖，要么用另外一个提供同样功能的依赖来替代这个传递性依赖。<xref
      linkend="ex-exclude" />展示的例子中添加了一个对于<varname>project-a</varname>的依赖，但排除了传递性依赖<varname>project-b</varname>。</para>

      <para><example id="ex-exclude">
          <title>排除一个传递性依赖</title>

          <programlisting language="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;project-a&lt;/artifactId&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;exclusions&gt;
    &lt;exclusion&gt;
      &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
      &lt;artifactId&gt;project-b&lt;/artifactId&gt;
    &lt;/exclusion&gt;
  &lt;/exclusions&gt;
&lt;/dependency&gt;</programlisting>
        </example></para>

      <para>通常，你会想要使用另外一个实现来替代一个传递性依赖。比如，如果你正依赖于一个类库，该类库又依赖于Sun
      <acronym>JTA</acronym>
      <acronym>API</acronym>，你会想要替换这个传递性依赖。Hibernate是一个例子。Hibernate依赖于Sun
      <acronym>JTA</acronym>
      <acronym>API</acronym>，而后者在中央Maven仓库中不可用，因为它是不能免费分发的。幸运的是，Apache
      Gernoimo项目创建了一些可以免费分发的独立实现类库。为了用另外的依赖来替换这个传递性依赖，你需要排除这个传递性以依赖，然后在你的项目中再声明一个依赖。<xref
      linkend="ex-exclude-replace" />展示了这样一个替换的样例。</para>

      <example id="ex-exclude-replace">
        <title>排除并替换一个传递性依赖</title>

        <programlisting language="xml">&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate&lt;/artifactId&gt;
    &lt;version&gt;3.2.5.ga&lt;/version&gt;
    &lt;exclusions&gt;
      &lt;exclusion&gt;
        &lt;groupId&gt;javax.transaction&lt;/groupId&gt;
        &lt;artifactId&gt;jta&lt;/artifactId&gt;
      &lt;/exclusion&gt;
    &lt;/exclusions&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.geronimo.specs&lt;/groupId&gt;
    &lt;artifactId&gt;geronimo-jta_1.1_spec&lt;/artifactId&gt;
    &lt;version&gt;1.1&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;</programlisting>
      </example>

      <para>在<xref
      linkend="ex-exclude-replace" />中，没有什么标记说依赖<varname>geronimo-jta_1.1_spec</varname>是一个替换，它只是正好提供了和原来的<acronym>JTA</acronym>依赖一样的<acronym>API</acronym>。以下列举了一些你可能想要排除或者替换传递性依赖的情况：</para>

      <orderedlist>
        <listitem>
          <para>构建的<varname>groupId</varname>和<varname>artifactId</varname>已经更改了，而当前的项目需要一个与传递性依赖不同名称的版本——结果是classpath中出现了同样项目的两份内容。一般来说Maven会捕捉到这种冲突并且使用该项目的一个单独的版本，但是当<varname>artifactId</varname>和<varname>artifactId</varname>不一样的时候，Maven就会认为它们是两种不同的类库。</para>
        </listitem>

        <listitem>
          <para>某个构件没有在你的项目中被使用，而且该传递性依赖没有被标志为可选依赖。在这种情况下，你可能想要排除这种依赖，因为它不是你的系统需要的东西，你要尽量减少应用程序分发时的类库数目。</para>
        </listitem>

        <listitem>
          <para>一个构件已经在运行时的容器中提供了，因此不应该被包含在你的构件中。该情况的一个例子是，如果一个依赖依赖于如Servlet
          API的东西，并且你又要确保这样的依赖没有包含在web应用的<filename>WEB-INF/lib</filename>目录中。</para>
        </listitem>

        <listitem>
          <para>为了排除一个可能是多个实现的<acronym>API</acronym>的依赖。这种情况在<xref
          linkend="ex-exclude-replace" />中阐述；有一个Sun
          <acronym>API</acronym>，需要点击许可证，并且需要耗时的手工安装到自定义仓库，对于同样的<acronym>API</acronym>有可免费分发版本，在中央Maven仓库中可用（Geronimo's
          <acronym>JTA</acronym> 实现）。</para>
        </listitem>
      </orderedlist>
    </section>

    <section>
      <title>依赖管理</title>

      <para>当你在你的超级复杂的企业中采用Maven之后，你有了两百多个相互关联的Maven项目，你开始想知道是否有一个更好的方法来处理依赖版本。如果每一个使用如MySQL数据库驱动依赖的项目都需要独立的列出该依赖的版本，在你需要升级到一个新版本的时候你就会遇到问题。由于这些版本号分散在你的项目树中，你需要手工的编写每一个引用该依赖的<filename>pom.xml</filename>，确保每个地方的版本号都更改了。即使使用了<command>find</command>，<command>xargs</command>，和，<command>awk</command>，你仍然有漏掉一个<acronym>POM</acronym>的风险。</para>

      <para>幸运的是，Maven在<sgmltag>dependencyManagement</sgmltag>元素中为你提供了一种方式来统一依赖版本号。你经常会在一个组织或者项目的最顶层的父<acronym>POM</acronym>中看到<sgmltag>dependencyManagement</sgmltag>元素。使用<filename>pom.xml</filename>中的<sgmltag>dependencyManagement</sgmltag>元素能让你在子项目中引用一个依赖而不用显式的列出版本号。Maven会沿着父子层次向上走，直到找到一个拥有<sgmltag>dependencyManagement</sgmltag>元素的项目，然后它就会使用在这个<sgmltag>dependencyManagement</sgmltag>元素中指定的版本号。</para>

      <para>例如，如果你有一大组项目使用MySQL Java
      connector版本5.1.2，你可以在你的多模块项目的顶层<acronym>POM</acronym>中定义如下的<sgmltag>dependencyManagement</sgmltag>元素。</para>

      <para><example>
          <title>在一个顶层POM中定义依赖版本</title>

          <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;a-parent&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
  ...
  &lt;dependencyManagement&gt;
    &lt;dependencies&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.2&lt;/version&gt;
      &lt;/dependency&gt;
      ...
    &lt;dependencies&gt;
  &lt;/dependencyManagement&gt;
</programlisting>

          <para>然后，在子项目中，你可以使用如下的依赖<acronym>XML</acronym>添加一个对MySQL Java
          Connector的依赖：</para>

          <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
    &lt;artifactId&gt;a-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;project-a&lt;/artifactId&gt;
  ...
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;mysql&lt;/groupId&gt;
      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting>

          <para>你应该注意到该子项目没有显式的列出<varname>mysql-connector-java</varname>依赖的版本。由于这个依赖在顶层<acronym>POM</acronym>的<sgmltag>dependencyManagement</sgmltag>元素中定义了，该版本号就会传播到所有子项目的<varname>mysql-connector-java</varname>依赖中。注意如果子项目定义了一个版本，它将覆盖顶层<acronym>POM</acronym>的<sgmltag>dependencyManagement</sgmltag>元素中的版本。那就是：只有在子项目没有直接声明一个版本的时候，<sgmltag>dependencyManagement</sgmltag>定义的版本才会被使用。</para>

          <para>顶层<acronym>POM</acronym>中的依赖管理与在一个广泛共享的父<acronym>POM</acronym>中定义一个依赖是不同的。对初学者来说，所有依赖都会被继承。如果<varname>mysql-connector-java</varname>在顶层父项目中被作为一个依赖列出，这个层次中的所有项目都将引用该依赖。为了不添加一些不必要的依赖，使用<sgmltag>dependencyManagement</sgmltag>能让你统一并集中化依赖版本的管理，而不用添加那些会被所有子项目继承的依赖。换句话说，<sgmltag>dependencyManagement</sgmltag>元素和一个环境变量一样，能让你在一个项目下面的任何地方声明一个依赖而不用指定一个版本号。</para>
        </example></para>
    </section>
  </section>

  <section>
    <title>项目关系</title>

    <para>使用Maven的引人注目的原因之一是它使得追踪依赖（以及依赖的依赖）的过程非常容易。当一个项目依赖于另一个项目生成的构件，我们就说这个构件是一个依赖。在Java项目的情况下，这可以简单到比如一个项目依赖与外部的如Log4J或JUnit依赖。依赖可以为外部依赖建模，也可以管理一组相关项目的依赖，如果<varname>project-a</varname>依赖于<varname>project-b</varname>，Maven就能够很聪明的知道<varname>project-b</varname>必须在<varname>project-a</varname>之前构建。</para>

    <para>项目关系不仅仅是依赖以及解决一个项目需要能构建出一个构件。Maven可以建模的关系还包括，某个项目是父项目，某个项目是子模块。本节给你项目中各种关系的概览，并且告诉你如何配置这些关系。</para>

    <section id="sect-more-coordinates">
      <title>坐标详解</title>

      <para>坐标为一个项目定义一个唯一的位置，它们首先在<xref
      linkend="simple-project" />中介绍过。项目使用Maven坐标与其它项目关联。一个项目不是简单的依赖于另一个项目，而是一个带有groupId，artifactId，和version的项目依赖于另一个带有groupId，artifactId，和version的项目。回顾一下，Maven坐标有三部分组成：</para>

      <variablelist>
        <varlistentry>
          <term>groupId</term>

          <listitem>
            <para>一个<varname>groupId</varname>归类了一组相关的构件。组定义符基本上类似于一个Java包名。例如：<varname>groupId</varname>
            <varname>org.apache.maven</varname>是所有由Apache
            Maven项目生成的构件的基本groupId。组定义符在Maven仓库中被翻译成路径，例如，<varname>groupId</varname>
            <varname>org.apache.maven</varname>可以在<ulink
            url="http://repo1.maven.org/maven2/org/apache/maven">repo1.maven.org</ulink>的<filename>/maven2/org/apache/maven</filename>目录下找到。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>artifactId</term>

          <listitem>
            <para><varname>artifactId</varname>是项目的主要定义符。当你生成一个构件，这个构件将由<varname>artifactId</varname>命名。当你引用一个项目，你就需要使用<varname>artifactId</varname>来引用它。<varname>artifactId</varname>和<varname>groupId</varname>的组合必须是唯一的。换句话说，你不能有两个不同的项目拥有同样的<varname>artifactId</varname>和<varname>groupId</varname>；在某个特定的<varname>groupId</varname>下，<varname>artifactId</varname>也必须是唯一的。</para>

            <note>
              <para>虽然‘.’在<varname>groupId</varname>中很常用，而你应该避免在<varname>artifactId</varname>中使用它。因为在解析一个完整限定名字至子模块的时候，这会引发问题。</para>
            </note>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>version</term>

          <listitem>
            <para>当一个构件发布的时候，它是使用一个版本号发布的。该版本号是一个数字定义符如“1.0”，“1.1.1”，或“1.1.2-alpha-01”。你也可以使用所谓的快照（snapshot）版本。一个快照版是一个处于开发过程中的组件的版本，快照版本号通常以SNAPSHOT结尾；如，“1.0-SNAPSHOT”，“1.1.1-SNAPSHOT”，和“1-SNAPSHOT”。<xref
            linkend="sect-versions" />介绍了版本和版本界限。</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>还有第四个，也是最少用到的限定符：</para>

      <variablelist>
        <varlistentry>
          <term>classifier</term>

          <listitem>
            <para>如果你要发布同样的代码，但是由于技术原因需要生成两个单独的构件，你就要使用一个分类器（classifier）。例如，如果你想要构建两个单独的构件成<acronym>JAR</acronym>，一个使用Java
            1.4编译器，另一个使用Java
            6编译器，你就可以使用分类器来生成两个单独的<acronym>JAR</acronym>构件，它们有同样的groupId:artifactId:version组合。如果你的项目使用本地扩展类库，你可以使用分类器为每一个目标平台生成一个构件。分类器常用于打包构件的源码，JavaDoc或者二进制集合。</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>当我们在本书说到依赖的时候，我们通常使用如下的简短标志来描述一个依赖：<varname>groupId</varname>:<varname>artifactId</varname>:<varname>version</varname>。要引用Spring
      Framework的2.5版本，我们可以使用<varname>org.springframework:spring:2.5</varname>。当你要求Maven使用Maven
      Dependency插件打印出依赖列表的时候，你也会看到Maven倾向于使用这种简短的依赖标志来打印日志信息。</para>
    </section>

    <section>
      <title>多模块项目</title>

      <para>多模块项目是那些包含一系列待构建模块的项目。一个多模块项目的打包类型总是pom，很少生成一个构件。一个模块项目的存在只是为了将很多项目归类在一起，成为一个构建。<xref
      linkend="fig-multiproject" />展示了一个项目层次，它包含了两个打包类型为<varname>pom</varname>的父项目，另外三个项目的打包类型是<varname>jar</varname>：</para>

      <para><figure id="fig-multiproject">
          <title>多模块项目关系</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="figs/web/pom_multimodule.png" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>文件系统上的目录结构也反映了该模块关系。<xref
      linkend="fig-multiproject" />中的一组项目拥有如下的目录结构：</para>

      <programlisting>top-group/pom.xml
top-group/sub-group/pom.xml
top-group/sub-group/project-a/pom.xml
top-group/sub-group/project-b/pom.xml
top-group/project-c/pom.xml</programlisting>

      <para>这些项目相互关联，因为在<acronym>POM</acronym>中<varname>top-group</varname>和<varname>sub-group</varname>引用了子模块。例如，项目<varname>org.sonatype.mavenbook:top-group</varname>是一个打包类型为<varname>pom</varname>的多模块项目。该项目的<filename>pom.xml</filename>包含如下的modules元素：</para>

      <example>
        <title>top-group的modules元素</title>

        <programlisting language="xml">&lt;project&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;top-group&lt;/artifactId&gt;
  ...
  &lt;modules&gt;
    &lt;module&gt;sub-group&lt;/module&gt;
    &lt;module&gt;project-c&lt;/module&gt;
  &lt;/modules&gt;
  ...
&lt;/project&gt;</programlisting>
      </example>

      <para>当Maven读取<varname>top-group</varname>的<acronym>POM</acronym>的时候，它会检查它的modules元素，看到<varname>top-group</varname>引用了项目<varname>sub-group</varname>和<varname>project-c</varname>。之后Maven会在它们的每个子目录中寻找<filename>pom.xml</filename>。Maven为每一个子模块重复这个过程：它会读取<filename>sub-group/pom.xml</filename>然后看到<varname>sub-group</varname>项目通过如下的modules元素引用了两个项目。</para>

      <example>
        <title>sub-group的modules元素</title>

        <programlisting language="xml">&lt;project&gt;
  ...
  &lt;modules&gt;
    &lt;module&gt;project-a&lt;/module&gt;
    &lt;module&gt;project-b&lt;/module&gt;
  &lt;/modules&gt;
  ...
&lt;/project&gt;</programlisting>
      </example>

      <para>注意我们称多模块项目下的项目为“模块”而不是“子项目”。这是有目的的，是为了而不将由多模块项目归类的项目与那些从其它项目继承<acronym>POM</acronym>信息的项目混淆。</para>
    </section>

    <section>
      <title>项目继承</title>

      <para>有些情况你会想要一个项目从父POM中继承一些值。你可能正构建一个大型的系统，你不想一遍又一遍的重复同样的依赖元素。如果你的项目通过parent元素使用继承，你就可以避免这种重复。当一个项目声明一个parent的时候，它从父项目的POM中继承信息。它也可以覆盖父POM中的值，或者添加一些新的值。</para>

      <para>所有的Maven
      <acronym>POM</acronym>从父<acronym>POM</acronym>中继承值。如果一个<acronym>POM</acronym>没有通过parent元素指定一个直接的父项目，那这个<acronym>POM</acronym>就会从超级<acronym>POM</acronym>继承值。<xref
      linkend="ex-inheritance" />展示了<varname>a-parent</varname>的<sgmltag>parent</sgmltag>元素，它继承了<varname>a-parent</varname>项目定义的<acronym>POM</acronym>。</para>

      <example id="ex-inheritance">
        <title>项目继承</title>

        <programlisting language="xml">&lt;project&gt;
  &lt;parent&gt;
    &lt;groupId&gt;com.training.killerapp&lt;/groupId&gt;
    &lt;artifactId&gt;a-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;project-a&lt;/artifactId&gt;
  ...
&lt;/project&gt;
</programlisting>
      </example>

      <para>在<varname>project-a</varname>中运行会<command>mvn
      help:effective-pom</command>显示一个<acronym>POM</acronym>，该<acronym>POM</acronym>合并了超级<acronym>POM</acronym>，<varname>a-parent</varname>中定义的<acronym>POM</acronym>，以及<varname>project-a</varname>中定义的<acronym>POM</acronym>。<varname>project-a</varname>显式的和隐式的继承关系如<xref
      linkend="fig-inheritance" />所示：</para>

      <figure id="fig-inheritance">
        <title>a-parent和project的项目继承关系</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="figs/web/pom_inheritance.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>当一个项目指定一个父项目的时候，Maven在读取当前项目的<acronym>POM</acronym>之前，会使用这个父<acronym>POM</acronym>作为起始点。它继承所有东西，包括<varname>groupId</varname>和<varname>version</varname>。你会注意到<varname>project-a</varname>没有指定<varname>groupId</varname>和<varname>version</varname>，它们从<varname>a-parent</varname>继承而来。有了parent元素，一个POM就只需要定义一个<varname>artifactId</varname>。但这不是强制的，<varname>project-a</varname>可以有一个不同的<varname>groupId</varname>和<varname>version</varname>，但如果不提供值，Maven就会使用在父<acronym>POM</acronym>中指定的值。如果你开始使用Maven来管理和构建大型的多模块项目，你就会常常创建许多共享一组通用的<varname>groupId</varname>和<varname>version</varname>的项目。</para>

      <para>当你继承一个<acronym>POM</acronym>，你可以选择直接使用继承的<acronym>POM</acronym>信息，或者选择覆盖它。以下是一个Maven
      <acronym>POM</acronym>从它父<acronym>POM</acronym>中继承的项目列表：</para>

      <itemizedlist>
        <listitem>
          <para>定义符（<varname>groupId</varname>和<varname>artifactId</varname>中至少有一个必须被覆盖）</para>
        </listitem>

        <listitem>
          <para>依赖</para>
        </listitem>

        <listitem>
          <para>开发者和贡献者</para>
        </listitem>

        <listitem>
          <para>插件列表</para>
        </listitem>

        <listitem>
          <para>报告列表</para>
        </listitem>

        <listitem>
          <para>插件执行 （id匹配的执行会被合并）</para>
        </listitem>

        <listitem>
          <para>插件配置</para>
        </listitem>
      </itemizedlist>

      <para>当Maven继承依赖的时候，它会将父项目中定义的依赖添加到子项目中。你可以使用Maven的这一特征来指定一些在所有项目被广泛使用的依赖，让它们从顶层<acronym>POM</acronym>中继承。例如，如果你的系统全局使用Log4J日志框架，你可以在你的顶层<acronym>POM</acronym>中列出该依赖。任何从该项目继承<acronym>POM</acronym>信息的项目会自动拥有Log4J依赖。类似的，如果你能确定每个项目都在使用同样版本的一个Maven插件，你可以在顶层父<acronym>POM</acronym>的<sgmltag>pluginManagement</sgmltag>元素中显式的列出该Maven插件的版本。</para>

      <para>Maven假设父<acronym>POM</acronym>在本地仓库中可用，或者在当前项目的父目录(<filename>../pom.xml</filename>)
      中可用。如果两个位置都不可用，默认行为还可以通过<sgmltag>relativePath</sgmltag>元素被覆盖。例如，一些组织更喜欢一个平坦的项目结构，父项目的<filename>pom.xml</filename>并不在子项目的父目录中。它可能在项目的兄弟目录中。如果你的子项目在目录<filename>./project-a</filename>中，父项目在名为<filename>./a-parent</filename>的目录中，你可以使用如下的配置来指定<varname>parent-a</varname>的<acronym>POM</acronym>的相对位置。</para>

      <programlisting language="xml">&lt;project&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
    &lt;artifactId&gt;a-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;relativePath&gt;../a-parent/pom.xml&lt;/relativePath&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;project-a&lt;/artifactId&gt;
&lt;/project&gt;</programlisting>
    </section>
  </section>

  <section>
    <title>POM最佳实践</title>

    <para>Maven可以用来管理那些简单的单模块系统，或者复杂到拥有数百个相互关联的子模块的项目。学习Maven过程的有一部分不仅仅是弄清楚Maven配置的语法，而是学习“Maven方式”——一组使用Maven组织和构建项目的最佳实践。本节试图展现一些这样的知识来帮助你采用最佳实践，你就不用从头开始去Maven的邮件列表的数年的内容中寻找这些技巧。</para>

    <section>
      <title>依赖归类</title>

      <para>如果你有一组逻辑上归类在一起的依赖。你可以创建一个打包方式为pom项目来将这些依赖归在一起。例如，让我们假设你的应用程序使用Hibernate，一种流行的对象关系映射框架。所有使用Hibernate的项目可能同时依赖于Spring
      Framework和MySQL
      <acronym>JDBC</acronym>驱动。你可以创建一个特殊的<acronym>POM</acronym>，它除了声明一组通用依赖之外什么也不做。这样你就不需要在每个使用Hibernate，Spring和MySQL的项目中包含所有这些依赖。你可以创建一个项目叫做<varname>persistence-deps</varname>（持久化依赖的简称），然后让每个需要持久化的项目依赖于这个提供便利的项目。</para>

      <para><example>
          <title>在一个单独的POM项目中巩固依赖</title>

          <programlisting language="xml">&lt;project&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;persistence-deps&lt;/artifactId&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;packaging&gt;pom&lt;/packaging&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate&lt;/artifactId&gt;
      &lt;version&gt;${hibernateVersion}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-annotations&lt;/artifactId&gt;
      &lt;version&gt;${hibernateAnnotationsVersion}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-hibernate3&lt;/artifactId&gt;
      &lt;version&gt;${springVersion}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;mysql&lt;/groupId&gt;
      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
      &lt;version&gt;${mysqlVersion}&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;properties&gt;
    &lt;mysqlVersion&gt;(5.1,)&lt;/mysqlVersion&gt;
    &lt;springVersion&gt;(2.0.6,)&lt;/springVersion&gt;
    &lt;hibernateVersion&gt;3.2.5.ga&lt;/hibernateVersion&gt;
    &lt;hibernateAnnotationsVersion&gt;3.3.0.ga&lt;/hibernateAnnotationsVersion&gt;
  &lt;/properties&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>如果你在一个名为<varname>persistence-deps</varname>的目录下创建了这个项目，你需要做的只是创建该<filename>pom.xml</filename>并且运行<command>mvn
      install</command>。由于打包类型是<varname>pom</varname>，这个POM被安装到你的本地仓库。你现在就可以添加这个项目作为一个依赖，所有该项目的依赖就会被添加到你的项目中。当我们声明一个对于<varname>persistence-deps</varname>项目的依赖的时候，不要忘了指定依赖类型为pom。</para>

      <para><example>
          <title>声明一个对于POM的依赖</title>

          <programlisting language="xml">&lt;project&gt;
  &lt;description&gt;This is a project requiring JDBC&lt;/description&gt;
  ...
  &lt;dependencies&gt;
    ...
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
      &lt;artifactId&gt;persistence-deps&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>如果之后你决定切换一个不同的<acronym>JDBC</acronym>驱动（比如，<acronym>JTDS</acronym>），只要替换<varname>persistence-deps</varname>项目中的依赖，使用<varname>sourceforge.jtds:jtds</varname>而不再是<varname>mysql:mysql-java-connector</varname>，然后更新版本号。所有依赖于<varname>persistence-deps</varname>的项目，如果它们决定更新一个新的依赖版本，就会使用<acronym>JTDS</acronym>。巩固相互关联的依赖是一种减少<filename>pom.xml</filename>文件长度的很好的方法。如果你需要在项目间共享一组很多的依赖，你也可以建立在项目间建立父子关系，然后将所有共同的依赖重构到父项目中，但是这种父子方式的缺点是一个项目只能有一个父项目。有时候将类似的依赖归类在一起并且使用<literal>pom</literal>依赖是更明智的做法。因为这样你的项目就可以根据需要引用很多巩固依赖<acronym>POM</acronym>。</para>

      <note>
        <para>当Maven使用一种“最近者胜出”方式解决依赖的时候，它会用到依赖的深度。当使用上述提到的依赖归类技术的时候，会把依赖推入整个树的更深一层。当在选择用pom归类依赖或者用父<acronym>POM</acronym>的<sgmltag>dependenctManagement</sgmltag>的时候，需要留意这一点。</para>
      </note>
    </section>

    <section id="sect-multi-vs-inherit">
      <title>多模块 vs. 继承</title>

      <para>继承于一个父项目和被一个多模块项目管理是有区别的。一个父项目是指它把所有的值传给它的子项目。一个多模块项目只是说它管理一组子模块，或者说一组子项目。多模块关系从上层往下定义。当建立一个多模块项目的时候，你告诉一个项目它的构建需要包含指定的模块。多模块构建用来将模块聚集到一个单独的构建中。父子关系是从叶节点往上定义的。父子关系更多的是处理一个特定项目的定义。当你给一个子项目关联一个父项目的时候，你告诉Maven该项目的<acronym>POM</acronym>起源于另一个项目。</para>

      <para>为了展示选择继承还是多模块的决策过程，考虑如下的两个例子：用来生成本书的Maven项目，以及一个包含很多逻辑上同组模块的假想项目。</para>

      <section>
        <title>简单项目</title>

        <para>首先，我们看一下maven-book项目。它的继承和多模块关系如<xref
        linkend="fig-maven-book" />所示。</para>

        <figure id="fig-maven-book">
          <title>maven-book 多模块 vs. 继承</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="figs/web/pom_book-example.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>当我们构建你正阅读的Maven书的时候，我们在名为<varname>maven-book</varname>的项目下运行<command>mvn
        package</command>。该多模块项目包含两个子模块：<varname>book-examples</varname>和<varname>book-chapters</varname>。两者都共享同样的父项目，它们只通过同为<varname>maven-book</varname>子项目的方式关联。<varname>book-examples</varname>构建了可下载的本书样例的<acronym>ZIP</acronym>和<acronym>TGZ</acronym>存档文件。当我们在<filename>book-examples/</filename>目录使用<command>mvn
        package</command>运行<varname>book-examples</varname>的构建的时候，它完全不知道它是<varname>maven-book</varname>项目的一部分。<varname>book-examples</varname>完全不关心<varname>maven-book</varname>，它知道的是它的父项目是最顶层的<varname>sonatype</varname>
        <acronym>POM</acronym>，它自身创建样例的归档文件。该例中，<varname>maven-book</varname>的存在只是为了方便聚集模块构建。</para>

        <para>该些书的项目没有定义一个父项目。所有这个三个项目：<varname>maven-book</varname>，<varname>book-examples</varname>，<varname>book-chapters</varname>和都继承同一个共享的“团体”父项目——<varname>sonatype</varname>。这是一种采用Maven的组织中常见的实践，一些组织定义一个顶层的团体<acronym>POM</acronym>，作为一个默认的父项目为其它项目服务，而不是让每个项目默认去扩展超级<acronym>POM</acronym>。在这个书本样例中，并不是一定要让<varname>book-examples</varname>和<varname>book-chapters</varname>共享同样的父<acronym>POM</acronym>，它们是完全不同的两个项目，拥有完全不同的而依赖，不同的构建配置，使用极为不同的插件创建你正阅读的内容。“团体”<acronym>POM</acronym>能让组织有机会自定义一些Maven的默认行为，提供一些组织特定的信息，如配置部署设置和构建profile。</para>
      </section>

      <section>
        <title>多模块企业级项目</title>

        <para>让我们看一下另一个例子，它提供了现实项目中继承和多模块关系存在的更准确的画面。<xref
        linkend="fig-multi-module" />展示了类似于典型企业应用中的一组项目。有一个的公司顶层<acronym>POM</acronym>，其<varname>artifactId</varname>值为<varname>sonatype</varname>。有一个名为<varname>big-system</varname>的多模块项目，引用了子模块<varname>server-side</varname>和<varname>client-side</varname>。</para>

        <figure id="fig-multi-module">
          <title>企业级多模块 vs. 继承</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="figs/web/pom_real_multi.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>这里到底是怎么回事呢？让我们尝试着给这一组混乱的箭头解构。首先，看一下<varname>big-system</varname>。这个<varname>big-system</varname>可能就是你将要运行<command>mvn
        package</command>以构建并测试整个系统的地方。<varname>big-system</varname>引用了子模块<varname>client-side</varname>和<varname>server-side</varname>。这两个项目都管理了大量运行在服务端或者客户端的代码。让我们看一下<varname>server-side</varname>项目。在<varname>server-side</varname>下面有一个名为<varname>server-lib</varname>的项目和一个名为<varname>web-apps</varname>的多模块项目。在<varname>web-apps</varname>下面有两个Java
        web应用：<varname>client-web</varname>和<varname>admin-web</varname>。</para>

        <para>让我们从<varname>client-web</varname>和<varname>admin-web</varname>到<varname>web-apps</varname>开始讨论父子关系。由于这两个web应用都用同样的web应用框架实现（假设是Wicket），两个项目都共享同样的一组核心依赖。对Servlet
        <acronym>API</acronym>，<acronym>JSP</acronym>
        <acronym>API</acronym>，和Wicket的依赖可以放到<varname>web-apps</varname>项目中。<varname>client-web</varname>和<varname>admin-web</varname>都需要依赖<varname>server-lib</varname>，它就可以定义为一个<varname>web-apps</varname>和<varname>server-lib</varname>之间的依赖。因为<varname>client-web</varname>和<varname>admin-web</varname>通过继承<varname>web-apps</varname>共享了如此多的配置，它们的<acronym>POM</acronym>很小，只包含定义符，父项目声明和最终构建名称。</para>

        <para>本例中，使用父子关系的最主要原因是为了给一组逻辑关联的项目共享依赖和通用配置。所有<varname>big-system</varname>下的项目都通过子模块与其它项目关联，但是并不是所有子模块都被配置成指回该父项目。所有模块都是子模块是为了方便，要构建整个系统，只要到<varname>big-system</varname>项目目录下运行<command>mvn
        package</command>。再仔细看下上图，你会发现在<varname>server-side</varname>和<varname>big-system</varname>之间没有父子关联。这是为什么？<acronym>POM</acronym>继承十分有用，但它可能被滥用。当然在需要共享依赖和配置的时候，父子关联需要被使用。但当两个项目截然不同的时候使用父子关联是不明智的。举个例子，<varname>server-side</varname>和<varname>client-side</varname>项目。在系统中，让<varname>server-side</varname>和<varname>client-side</varname>都从<varname>big-system</varname>继承通用的<acronym>POM</acronym>是可能的，但一旦这两个子项目的重大分歧出现，你就需要费脑子一方面将构建配置抽离到<varname>big-system</varname>中，另一方面又需要不影响其它的子项目。即使<varname>server-side</varname>和<varname>client-side</varname>同时依赖于Log4J，它们也可能拥有截然不同的插件配置。</para>

        <para>有时候基于风格和经验，为了允许项目如<varname>server-side</varname>和<varname>client-side</varname>保持完全独立，少量的重复配置是最小的代价。设计一组继承了五六层POM的第三方项目永远都不是一个好主意。这样的配置下，你可能不再需要在多个地方重复Log4J依赖，但你会需要查看五六个POM来弄清Maven如何计算出你的有效<acronym>POM</acronym>。所有的这些的新的复杂度只是为了避免五行依赖声明。在Maven中，有一种“Maven方式”，但是也有很多其它方式完成同样的事情。这都可归结为一种偏好和风格。大部分情况下，如果你的子模块定义了往回的父项目引用，不会出什么问题，但是你的Maven使用情况一直在变。</para>
      </section>

      <section>
        <title>原型父项目</title>

        <para>如<xref
        linkend="fig-multi-proto" />的例子所示，这是又一种假想的创造性的方式，使用继承和多模块构建达到重用依赖的目的。<figure
            id="fig-multi-proto">
            <title>为特定的项目使用父项目作为“原型”</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="figs/web/pom_protos.png" />
              </imageobject>
            </mediaobject>
          </figure>在该例中，你有两个截然不同的系统：<varname>system-a</varname>和<varname>system-b</varname>，各自定义独立的应用。<varname>system-a</varname>定义了两个模块<varname>a-lib</varname>和<varname>a-swing</varname>。<varname>system-a</varname>和<varname>a-lib</varname>两者都定义了顶层的<varname>sonatype</varname>
        <acronym>POM</acronym>作为父项目，但<varname>a-swing</varname>项目定义了<varname>swing-proto</varname>作为它的父项目。在该系统中，<varname>swing-proto</varname>为所有Swing应用程序提供了一个基础<acronym>POM</acronym>，而<varname>struts-proto</varname>为所有Struts
        2 web应用程序提供了一个基础<acronym>POM</acronym>。s<varname>onatype</varname>
        <acronym>POM</acronym>提供了高层的信息如<varname>groupId</varname>，组织信息和构建profile，<varname>struts-proto</varname>定义了所有创建struts应用需要的依赖。如果你的开发根据不同的应用有不同的特征，每类应用又需要遵循同样一组规则，那么这里介绍的方法很有用。如果你正创建很多struts应用，但是它们很少相互关联，你可能只需要在<varname>struts-proto</varname>中定义所有通用的东西。这种方式的缺点是有不能在<varname>system-a</varname>和<varname>system-b</varname>项目层次中使用父子关系来共享如开发人员和其它构建配置信息。一个项目只能有一个父项目。</para>

        <para>这种方法的另外一个缺点是，一旦你有一个项目需要“破坏该模型”，你需要重写父<acronym>POM</acronym>，或者想办法将自定义信息提取到一个共享的父项目中，而不让这些自定义信息影响所有子项目。总得来说，为特定的项目“类型”使用<acronym>POM</acronym>作为原型不是一种推荐的做法。</para>
      </section>
    </section>
  </section>
</chapter>
