<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="writing-plugins">
  <title>编写插件</title>

  <section>
    <title>简介</title>

    <para>虽然本章介绍的是高级话题,关于编写Maven插件，但不要被吓到。当对于其所有理论和复杂性来说，基本的概念还是比较容易理解的，而编写插件的方法也十分易懂。在你阅读本章之后，你将能更好的掌握编写Maven插件所涉及的内容。</para>
  </section>

  <section>
    <title>Maven编程</title>

    <para>本书的绝大部分都在讲述使用Maven，在这本关于Maven的书中，你还没看到太多关于定制Maven的样例代码。事实上，到目前为止这样的代码还没有。这原是设计的目的，99%的Maven用户将从来不需要编写自定义插件来定制Maven；有大量的可配置的插件可用，除非你有特别的单独需求，你没有理由自己去编写一个新的插件。而在那一小部分编写自定义插件的人中，也只有更少的人需要去查看Maven的源码以自定义Maven核心组件。如果你确实需要自定义Maven的行为，那么你可以编写一个插件。修改核心Maven代码与修改操作系统的TCP/IP堆栈一样，远远超出了大部分开发人员的范围，这对于大部分Maven用户来说过于抽象。</para>

    <para>另一方面，如果你想开始编写自定义插件，你就需要学习一些Maven的内部原理：它如何管理软件组件？什么是一个插件？我如何能够自定义生命周期？本节将解答其中的一些问题，并介绍一些Maven设计核心的概念。学习如何编写Maven插件同时也是学习定制Maven本身一种很好的方式。如果你想了解如何开始探究Maven背后的代码，那么你已经找到了正确的出发点。</para>

    <section>
      <title>什么是反转控制？</title>

      <para>Maven的心脏是一个名为Plexus的反转控制（IoC）框架。它做什么呢？这是一个用来管理及关联组件的系统。虽然有一篇Martin
      Fowler编写的关于Ioc的权威论文，但这个概念和术语在过去的一些年中已经被大量的重载，因此找出一个关于此概念的良好定义已经变得非常困难，很多定义都是自我指认的（或者对于上述论文的简单引用）。这里我们将通过一个比喻来简要介绍反转控制和依赖注入，而不是简单的援引维基百科。</para>

      <para>假设你有一系列的组件需要装配在一起。当你考虑组件的时候，将其想象成立体声音响组件而非软件组件。想象一下有一些音响组件接通了一个Playstation
      3和一个机顶盒，后者又需要连接一个苹果电视盒以及一个50英寸的平板液晶电视。你从电子产品商店将所有这些东西带回家，并购买了一些电缆准备用来连接这些电器。你将所有组件拆开，将其放到正确的位置，然后开始连接同轴电缆，数字输入设备，立体声控制设备，以及网线等等。从你的家庭娱乐中心后退一步，然后打开电视机，你已经完成了依赖注入，你刚才正处在一个反转控制容器中。</para>

      <para>那么，你到底需要做什么？你的Playstation 3和一个Java Bean都提供接口。Playstation
      3有两个输入：电源和网络，以及一个电视输出。你的Java
      Bean有三个属性：power，network，和tvOutput。当你打开Playstation
      3盒子的时候，它并不会提供关于连接所有不同种类电视的详细图片和指令，当你查看你的Java
      Bean的时候，它也只是提供了一组属性，而不是创建和管理整个系统组件的显式的方法。在一个如Plexus的IoC容器中，你负责通过简单的提供输入输出接口来声明组件之间的关系。你不需要初始化对象，Plexus会帮你完成；你的应用程序的代码不用去管理组件的状态，Plexus负责。虽然这听起来非常俗套，不过这里还是要说，当你启动Maven的时候，实际上是启动Plexus来管理一个带有很多相互关联组件的系统，就像你的家庭影音系统一样。</para>

      <para>那么，使用Ioc容器的优点是什么呢？购买离散的音响组件的优点是什么？如果一个组件坏了，你可以放一个Playstation
      3的替代品，而不用花20,000美元去重新购买整个系统。如果你对电视机不满意，你可以在不影响CD播放器的情况下将电视换掉。对你来说最重要的是，你的音响组件现在花费更低，但功能更强，且更稳定，因为制造商现在根据一组通用的输入输出来制造组件，他们能够更加的关注组件本身。反转控制和依赖注入提倡分解以及标准的形成。软件产业喜欢自己给新的想法命名，但依赖注入和反转控制实际上只是对于分解及可交换体系的重新命名。如果你真的想要好好了解DI和IoC，你可以学习一下Model
      T，Cotton Gin，以及19世纪末期形成的一个铁路系统标准。</para>
    </section>

    <section>
      <title>Plexus简介</title>

      <para>用Java实现的<acronym>IoC</acronym>容器中，最重要的一个功能是称作依赖注入的机制。<acronym>IoC</acronym>的基本想法是将对象的创建和管理从代码中剥离，并将控制放到<acronym>IoC</acronym>框架手中。在一个面向接口编程的应用程序中使用依赖注入，你创建的组件可以不与任何特定的接口实现绑定。你的程序也针对接口编程并通过配置Plexus来将正确的实现连接到正确的组件。虽然你的代码都是与接口打交道，但你仍然可以通过一个定义组件的<acronym>XML</acronym>文件来获得类和组件相互依赖的信息。换句话说，你可以编写独立的组件，然后你可以通过一个<acronym>XML</acronym>文件来定义组件应当如何被装配在一起。在Plexus的情形中，定义系统组件的<acronym>XML</acronym>文档位于<filename>META-INF/plexus/components.xml</filename>。</para>

      <para>在一个Java
      <acronym>IoC</acronym>容器中，有很多中方法将依赖值注入到一个组件对象中：构造器，set方法，或者字段注入。虽然Plexus提供全部这三种依赖注入技术，Maven只使用其中的两种：字段注入和set方法注入。</para>

      <variablelist>
        <varlistentry>
          <term>构造器注入</term>

          <listitem>
            <para>构造器注入是指当对象实例被创建的时候，通过对象的构造方法填入对象的值。例如，如果你有类对象<classname>Person</classname>，其构造方法是<methodname>Person(String
            name, Job
            job)</methodname>，你就可以通过该构造器传入<varname>name</varname>和<varname>job</varname>的值。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>set方法注入</term>

          <listitem>
            <para>set方法注入是指使用Java
            Bean属性的set方法来填入对象依赖。例如，如果你有一个带有<varname>name</varname>和<varname>job</varname>属性的<classname>Person</classname>对象，一个使用set方法注入的<acronym>IoC</acronym>容器会使用无参构造器创建一个<classname>Person</classname>的实例，之后，它会继续调用<methodname>setName()</methodname>和<methodname>setJob()</methodname>方法。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>字段注入</term>

          <listitem>
            <para>构造器和set方法注入都依赖于公共方法。而使用字段注入的时候，<acronym>IoC</acronym>容器通过直接设置对象字段的值来填入组件依赖。例如，如果你有一个带有<varname>name</varname>和<varname>job</varname>字段的<classname>Person</classname>对象，你的<acronym>IoC</acronym>容器会直接设置这两个字段来填入依赖（如：<code>person.name
            = "Thomas"; person.job = job;</code>）。</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section>
      <title>为什么使用Plexus?</title>

      <para>目前Spring是最流行的IoC容器。它影响了Java的“生态系统”，迫使如Sun
      Microsystems之类的公司让出更多的对于开源社区的控制，并通过提供一个更易插入的，面向组件的“总线”来帮助开发一些标准。但是Spring不是唯一的开源IoC容器。事实上有很多IoC容器（如<ulink
      url="http://www.picocontainer.org/">PicoContainer</ulink>）。</para>

      <para>很多年以前，当Maven被创建的时候，Spring并不是一个成熟的选项。最初的Maven提交者团队更熟悉Plexus因为正是他们发明了Plexus，因此他们决定使用Plexus做为Ioc容器。虽然它没有Spring
      Framework流行，但并不是说它的功能没那么强大。而且，事实上它是由创建Maven的同一个人发明的，这使其更适合Maven。阅读本章之后你会了解Plexus如何工作。如果你使用过一个IoC容器你会看到Plexus和你使用的另外一个IoC容器的相似性和差异性。</para>

      <note>
        <para>Maven基于Plexus并不意味着Maven社区是“反Spring”的（我们在本书中包含了整整的一章关于Spring样例的内容，Spring项目的一部分也转移到Maven作为构建平台）。由于“你们为什么不用Spring”这个问题经常出现，因此在这里解释这个问题。我们知道，Spring是一个明星，我们并不拒绝它，但为人们介绍Plexus仍然是我们持续要做的工作：软件产业中，更多的选择总是好事。</para>
      </note>
    </section>

    <section>
      <title>什么是插件？</title>

      <para>一个Maven插件是包含了一个插件描述符和一个或者多个Mojo的Maven构件。一个Mojo可以被认为是Maven中的一个目标，每一个目标对应了一个Mojo。<varname>compiler:compile</varname>目标对应了Maven
      Compiler插件的<classname>CompilerMojo</classname>类，<varname>jar:jar</varname>目标对应了Maven
      Jar插件的<classname>JarMojo</classname>类。当你编写自己的插件的时候，你在一个单独的插件构件中将一组相互关联的Mojo（或者目标）归类。</para>

      <para><footnote id="foot-mojo-def">
          <para>“mojo.”美国传统英语字典，第四版。Houghton Mifflin公司，2004，Answer.com 02 Mar.
          2008. <ulink
          url="http://www.answers.com/topic/mojo-1">http://www.answers.com/topic/mojo-1</ulink></para>
        </footnote></para>

      <note>
        <para>Mojo?什么是Mojo?词mojo<footnoteref
        linkend="foot-mojo-def" />被定义为“一种神奇的魔力或咒语”，“一个护身符，通常是一个包含了一个或多个神奇物件的法兰绒小包”，以及“个人魅力；吸引力”。Maven使用术语Mojo因为这是一个对于Pojo（Plan-old
        Java Object）的玩笑。</para>
      </note>

      <para>Mojo不仅仅是Maven中的一个目标，它是一个由Plexus管理的组件，可以引用其它Plexus组件。</para>
    </section>
  </section>

  <section>
    <title>插件描述符</title>

    <para>Maven插件包含了一个告诉Maven各种Mojo和插件配置的路线图。这就是插件描述符，它位于<acronym>JAR</acronym>文件中的<filename>META-INF/maven/plugin.xml</filename>。当Maven载入一个插件的时候，它读取该<acronym>XML</acronym>文件，初始化并配置插件对象，使Mojo被包含在插件中，供Maven使用。</para>

    <para>当你编写自定义Maven插件的时候，你几乎不需要编写插件描述符。在<xref
    linkend="lifecycle" />中，绑定到<varname>maven-plugin</varname>打包类型的生命周期目标显示，<varname>plugin:descriptor</varname>目标被绑定到了<varname>generate-resources</varname>生命周期阶段。该目标根据插件源码中的注解生成一个插件描述符。本章后面，你会看到如何注解Mojo，并且你会了解这些注解最终如何成为<filename>META-INF/maven/plugin.xml</filename>文件的内容。</para>

    <para><xref linkend="ex-plugin-desc" />展示了Maven
    Zip插件的描述符。该插件简单的对输出目录进行zip压缩并归档。一般来说，你不需要编写自定义插件从Maven创建归档，你可以使用Maven
    Assembly插件，该插件能够以多种格式帮助生成分发归档。仔细阅读下面的插件描述符以了解其包含的内容：</para>

    <!--TODO: Reference Assembly Plugin Chapter-->

    <example id="ex-plugin-desc">
      <title>插件描述符</title>

      <programlisting language="xml">&lt;plugin&gt;
  &lt;description&gt;&lt;/description&gt;
  &lt;groupId&gt;com.training.plugins&lt;/groupId&gt;
  &lt;artifactId&gt;maven-zip-plugin&lt;/artifactId&gt;
  &lt;version&gt;1-SNAPSHOT&lt;/version&gt;
  &lt;goalPrefix&gt;zip&lt;/goalPrefix&gt;
  &lt;isolatedRealm&gt;false&lt;/isolatedRealm&gt;
  &lt;inheritedByDefault&gt;true&lt;/inheritedByDefault&gt;
  &lt;mojos&gt;
    &lt;mojo&gt;
      &lt;goal&gt;zip&lt;/goal&gt;
      &lt;description&gt;Zips up the output directory.&lt;/description&gt;
      &lt;requiresDirectInvocation&gt;false&lt;/requiresDirectInvocation&gt;
      &lt;requiresProject&gt;true&lt;/requiresProject&gt;
      &lt;requiresReports&gt;false&lt;/requiresReports&gt;
      &lt;aggregator&gt;false&lt;/aggregator&gt;
      &lt;requiresOnline&gt;false&lt;/requiresOnline&gt;
      &lt;inheritedByDefault&gt;true&lt;/inheritedByDefault&gt;
      &lt;phase&gt;package&lt;/phase&gt;
      &lt;implementation&gt;com.training.plugins.ZipMojo&lt;/implementation&gt;
      &lt;language&gt;java&lt;/language&gt;
      &lt;instantiationStrategy&gt;per-lookup&lt;/instantiationStrategy&gt;
      &lt;executionStrategy&gt;once-per-session&lt;/executionStrategy&gt;
      &lt;parameters&gt;
        &lt;parameter&gt;
          &lt;name&gt;baseDirectory&lt;/name&gt;
          &lt;type&gt;java.io.File&lt;/type&gt;
          &lt;required&gt;false&lt;/required&gt;
          &lt;editable&gt;true&lt;/editable&gt;
          &lt;description&gt;Base directory of the project.&lt;/description&gt;
        &lt;/parameter&gt;
        &lt;parameter&gt;
          &lt;name&gt;buildDirectory&lt;/name&gt;
          &lt;type&gt;java.io.File&lt;/type&gt;
          &lt;required&gt;false&lt;/required&gt;
          &lt;editable&gt;true&lt;/editable&gt;
          &lt;description&gt;Directory containing the build files.&lt;/description&gt;
        &lt;/parameter&gt;
      &lt;/parameters&gt;
      &lt;configuration&gt;
        &lt;buildDirectory implementation="java.io.File"&gt;${project.build.directory}&lt;/buildDirectory&gt;
        &lt;baseDirectory implementation="java.io.File"&gt;${basedir}&lt;/baseDirectory&gt;
      &lt;/configuration&gt;
      &lt;requirements&gt;
        &lt;requirement&gt;
          &lt;role&gt;org.codehaus.plexus.archiver.Archiver&lt;/role&gt;
          &lt;role-hint&gt;zip&lt;/role-hint&gt;
          &lt;field-name&gt;zipArchiver&lt;/field-name&gt;
        &lt;/requirement&gt;
      &lt;/requirements&gt;
    &lt;/mojo&gt;
  &lt;/mojos&gt;
  &lt;dependencies&gt;
    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
    &lt;version&gt;1.3.2&lt;/version&gt;
  &lt;/dependencies&gt;
&lt;/plugin&gt;
</programlisting>
    </example>

    <para>该插件描述符有三个部分：插件的顶层配置，包含如<sgmltag>groupId</sgmltag>和<sgmltag>artifactId</sgmltag>之类的元素；mojo声明；以及依赖声明。让我们仔细解释一下每一部分。</para>

    <section>
      <title>顶层插件描述符元素</title>

      <para><sgmltag>plugin</sgmltag>元素中顶层的配置元素有：</para>

      <variablelist>
        <varlistentry>
          <term>description</term>

          <listitem>
            <para>该元素包含了插件的简短描述。在Zip插件的情况中，该描述为空。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>groupId, artifactId, version</term>

          <listitem>
            <para>就像Maven中的任何其它构件一样，插件也需要唯一的坐标。groupId,
            artifactId,和version用来在Maven仓库中定位插件。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>goalPrefix</term>

          <listitem>
            <para>该元素（目标前缀）用来设置某个特定插件用来引用目标的前缀。如果你看一下Compiler插件的描述符，你会看到<varname>goalPrefix</varname>的值为<varname>compile</varname>，如果你看一下Jar插件的描述符，你会看到<varname>goalPrefix</varname>为<varname>jar</varname>。为自定义插件选择一个独一无二的前缀非常重要。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>isolatedRealm (不赞成使用)</term>

          <listitem>
            <para>该遗留属性不再被Maven使用。它的存在是为了给旧的插件提供向后兼容性。早期版本的Maven使用它提供一种在单独<classname>ClassLoader</classname>中载入插件依赖的机制。Maven扩展使用了<ulink
            url="http://www.codehaus.org">Codehaus</ulink>社区中一个名为<ulink
            url="http://classworlds.codehaus.org/">ClassWorlds</ulink>的项目，创建由<classname>ClassRealm</classname>对象建模的<classname>ClassLoader</classname>对象层次结构。尽管忽略该属性，永远将其设置成<varname>false</varname>。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>inheritedByDefault</term>

          <listitem>
            <para>如果inheritedByDefault（缺省继承）被设置成true，所有在父项目配置的该插件的mojo会在子项目中生效。如果你配置一个mojo在父项目中特定的阶段执行，并且该插件inheritedByDefault属性的值为true，这段执行会被子项目继承。如果inheritedByDefault没有被设置成true，那么定义在父项目中的目标执行不会被子项目继承。</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section>
      <title>Mojo配置</title>

      <para>接下来是每个Mojo的声明。plugin元素包含一个名为mojos的元素，它为每个插件中的mojo元素包含一个mojo元素。每个mojo元素包含如下的配置元素：</para>

      <variablelist>
        <varlistentry>
          <term>goal</term>

          <listitem>
            <para>这是目标的名称。如果你在运行<varname>compiler:compile</varname>目标，<varname>compiler</varname>就是插件的<varname>goalPrefix</varname>，<varname>compile</varname>就是目标的名称。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>description</term>

          <listitem>
            <para>目标的简要描述，当用户使用Help插件生成插件文档的时候，该描述会被显示。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>requiresDirectInvocation</term>

          <listitem>
            <para>如果你将其设置成<varname>true</varname>，那么该目标就只能由用户在命令行显示的执行。如果有人想要将该目标绑定到一个生命周期阶段，Maven会打印错误信息。该元素默认值是<varname>false</varname>。</para>

            <!--TODO: Might want some justification.-->
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>requiresProject</term>

          <listitem>
            <para>指定该目标不能在项目外部运行。目标需要一个带有<acronym>POM</acronym>的项目。<varname>requiresProject</varname>默认的值为<varname>true</varname>。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>requiresReports</term>

          <listitem>
            <para>如果你正创建一个插件，它依赖于报告，那么你就需要将<varname>requiresReports</varname>设置成<varname>true</varname>。例如，如果你创建一个插件用来聚合许多报告的信息，那么就需要将<varname>requiresReports</varname>设置成<varname>true</varname>。该元素默认的值为<varname>false</varname>。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>aggregator</term>

          <listitem>
            <para>当Mojo描述符的<varname>aggregator</varname>设置成<varname>true</varname>的时候，那么该目标只会在Maven执行的时候运行一次，提供该配置是为了让开发人员能够对一系列构建进行总结；例如，创建一个插件来概述构建中所有项目的一类报告。一个<varname>aggregator</varname>设置成<varname>true</varname>的目标应该只在Maven构建的顶层项目中运行。<varname>aggregator</varname>默认值是<varname>false</varname>。aggregator在未来版本的Maven中很有可能被弃用。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>requiresOnline</term>

          <listitem>
            <para>指定当Maven在离线模式（-o命令行选项）的时候该目标不能运行。如果一个目标依赖于网络资源，你就需要将该元素设置成<varname>true</varname>，那么如果在离线模式下运行，Maven就会输出错误信息。该元素默认值是<varname>false</varname>。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>inheritedByDefault</term>

          <listitem>
            <para>如果<varname>inheritedByDefault</varname>被设置成<varname>true</varname>，在父项目中配置的mojo就会同样在子项目中生效。如果你配置一个mojo在父项目中特定的阶段执行，并且该插件inheritedByDefault属性的值为true，这段执行会被子项目继承。如果inheritedByDefault没有被设置成true，那么定义在父项目中的目标执行不会被子项目继承。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>phase</term>

          <listitem>
            <para>如果用户没有为该目标绑定一个阶段，那么该元素定义一个mojo默认的阶段。如果你没有不指定phase元素，Maven就会要求用户在<acronym>POM</acronym>中显式的指定一个阶段。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>implementation</term>

          <listitem>
            <para>该元素告诉Maven需要为该Mojo初始化什么类。这是一个Plexus组件属性（在Plexus
            <classname>ComponentDescriptor</classname> 中定义）。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>language</term>

          <listitem>
            <para>Maven Mojo默认的语言是<varname>java</varname>。该配置控制Plexus
            <classname>ComponentFactory</classname>初始化该Mojo组件。本章关注于使用Java编写Maven插件，但是你也可以使用其它很多语言来编写Maven插件，如Groovy,
            Beanshell,和Ruby。如果你使用这其中的一种语言来编写插件，那么就需要设置language元素的值。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>instantiationStrategy</term>

          <listitem>
            <para>该属性是一个Plexus组件配置属性，它告诉Plexus如何创建和管理组件实例。在Maven中，所有mojo的<varname>instantiationStrategy</varname>都被配置成<varname>per-lookup</varname>，每次Maven从Plexus获取该mojo的时候，一个新的实例被创建。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>executionStrategy</term>

          <listitem>
            <para>executionStrategy告诉Maven什么时候，怎样运行一个Mojo。可用的值是<varname>once-per-session</varname>和<varname>always</varname>。老实说，任何值都是可用的，这个特殊的属性并不做什么事情，它是从早期Maven设计中遗留下来的。在未来版本的Maven中该属性很有可能被弃用。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>parameters</term>

          <listitem>
            <para>该元素描述Mojo的所有参数。参数名称是什么？参数类型是什么？是否是必须的？每个参数拥有如下的元素：</para>

            <variablelist>
              <varlistentry>
                <term>name</term>

                <listitem>
                  <para>参数名（如 <varname>baseDirectory</varname>）</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>type</term>

                <listitem>
                  <para>参数类型（Java类）（如<classname>java.io.File</classname>）</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>required</term>

                <listitem>
                  <para>参数是否是必须的？如果为<varname>true</varname>，那么当目标运行的时候该参数不能为null。</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>editable</term>

                <listitem>
                  <para>如果一个参数不是可编辑的（如果<varname>editable</varname>被设置成<varname>false</varname>），那么该参数的值就不能在<acronym>POM</acronym>中设置。例如，如果插件描述符定义了<varname>buildDirectory</varname>的值为<varname>${basedir}</varname>，那么在<acronym>POM</acronym>中该值就不能被重写。</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>description</term>

                <listitem>
                  <para>当生成插件文档的时候（使用Help插件），该插件的简短描述。</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>configuration</term>

          <listitem>
            <para>该元素为所有Mojo参数提供默认值。本例中为Mojo参数<varname>baseDir</varname>和<varname>buildDirectory</varname>提供了默认值，这里，属性implementation指定了参数的类型（本例中是<classname>java.io.File</classname>），而其元素值包含了一个硬编码的默认值，或者一个Maven属性引用。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>requirements</term>

          <listitem>
            <para>这是一个描述符十分有趣的地方。一个mojo是一个由Plexus管理的组件，而且，由于该原因，它就有机会引用Plexus管理的其它组件。该元素能让你定义对于其它Plexus组件的依赖。</para>

            <!--TODO: Insert an XREF to an example?-->
          </listitem>
        </varlistentry>
      </variablelist>


      <para>虽然你的确应该能够读懂插件描述符，但你几乎从不需要去手工的编写一个描述符文件。插件描述符会根据Mojo的一组注解自动的生成。</para>
    </section>

    <section>
      <title>插件依赖</title>

      <para>最后，插件描述符像Mave项目一样声明了一组依赖。当Maven使用插件的时候，它会在运行插件之前之前下载所有需要的依赖。在本例中，该插件依赖于Jakarta
      Commons IO 版本 1.3.2 。</para>
    </section>
  </section>

  <section id="writing-plugins-intro">
    <title>编写自定义插件</title>

    <para>在你编写自定义插件的时候，你实际上是要编写一系列的Mojo（目标）。每个Mojo是一个单独的Java类，它包含了一系列注解来告诉Maven如何生成插件描述符。在编写Mojo类之前，你需要使用正确的打包类型和POM来创建一个Maven项目。</para>

    <section>
      <title>创建一个插件项目</title>

      <para>要创建一个插件项目，你应该使用Maven
      Archetype插件。以下的命令会创建一个插件，其<varname>groupId</varname>是<varname>org.sonatype.mavenbook.plugins</varname>，<varname>artifactId</varname>是<varname>first-maven-plugin</varname>：</para>

      <screen>$ <command>mvn archetype:create \
  -DgroupId=org.sonatype.mavenbook.plugins \
  -DartifactId=first-maven-plugin \
  -DarchetypeGroupId=org.apache.maven.archetypes \
  -DarchetypeArtifactId=maven-archetype-mojo</command></screen>

      <para>Archetype插件会创建一个名为my-first-plugin的目录，其包含了如下的POM：</para>

      <example>
        <title>一个插件项目的POM</title>

        <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.plugins&lt;/groupId&gt;
  &lt;artifactId&gt;first-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;maven-plugin&lt;/packaging&gt;
  &lt;name&gt;first-maven-plugin Maven Mojo&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.maven&lt;/groupId&gt;
      &lt;artifactId&gt;maven-plugin-api&lt;/artifactId&gt;
      &lt;version&gt;2.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting>
      </example>

      <para>在一个插件项目的POM中最重要的元素是打包类型，其值为<varname>maven-plugin</varname>。该打包类型会定制Maven的生命周期，使其包含创建插件描述符必要的目标。插件生命周期在<xref
      linkend="sect-plugin-lifecycle" />中介绍，它和Jar生命周期类似，但有三个例外：<varname>plugin:descriptor</varname>被绑定到<varname>generate-resources</varname>阶段，<varname>plugin:addPluginArtifactMetadata</varname>被添加到<varname>package</varname>阶段，<varname>plugin:updateRegistry</varname>被添加到<varname>install</varname>阶段。</para>

      <para>插件项目的POM中另一个重要的部分是，它有一个对于Maven Plugin
      API的依赖。该项目依赖于<varname>maven-plugin-api</varname>的2.0版本，同时它也有一个测试范围的JUnit依赖。</para>
    </section>

    <section>
      <title>一个简单的Java Mojo</title>

      <para>本章，我们将介绍一个用Java编写的Maven
      Mojo。你项目中每一个Mojo都要实现<classname>org.apache.maven.plugin.Mojo</classname>接口，下例中的<classname>Mojo</classname>通过扩展<classname>org.apache.maven.plugin.AbstractMojo</classname>类实现了该接口。在我们深入Mojo的代码之前，让我们花一些时间看一下Mojo接口。Mojo提供过了如下的方法：</para>

      <variablelist>
        <varlistentry>
          <term><methodname>void setLog( org.apache.maven.monitor.logging.Log
          log )</methodname></term>

          <listitem>
            <para>每一个Mojo实现都必须提供一种方法让插件能够和某个特定目标的过程相交流。该目标成功了么？或者，是否在运行目标的时候遇到了问题？当Maven加载并运行Mojo的时候，它会调用<methodname>setLog()</methodname>方法，为Mojo实例提供正确的日志目标，以让你在自定义插件中使用。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>protected Log getLog()</methodname></term>

          <listitem>
            <para>Maven会在Mojo运行之前调用<methodname>setLog()</methodname>方法，然后你的Mojo就可以通过调用<methodname>getLog()</methodname>获得日志对象。你的Mojo应该去调用这个<classname>Log</classname>对象的方法，而不是直接将输出打印到标准输出或者控制台。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>void execute() throws
          org.apache.maven.plugin.MojoExecutionException</methodname></term>

          <listitem>
            <para>轮到运行你目标的时候，Maven就会调用该方法。</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Mojo接口只关心两件事情：目标运行结果的日志记录，以及运行一个目标。当你编写自定义插件的时候，你会要扩展<classname>AbstractMojo</classname>。<classname>AbstractMojo</classname>处理<varname>setLog()</varname>和<varname>getLog()</varname>的实现，并包含一个抽象的<methodname>execute()</methodname>方法。在你扩展<classname>AbstractMojo</classname>的时候，你所需要做的只是实现<methodname>execute()</methodname>方法。<xref
      linkend="ex-simple-echomojo" />展示了一个简单的Mojo实现，它只是打印一条简单的信息到控制台。</para>

      <example id="ex-simple-echomojo">
        <title>一个简单的EchoMojo</title>

        <programlisting language="java">package org.sonatype.mavenbook.plugins;

import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;

/**
 * Echos an object string to the output screen.
 * @goal echo
 */
public class EchoMojo extends AbstractMojo
{
    /**
     * Any Object to print out.
     * @parameter expression="${echo.message}" default-value="Hello Maven World..."
     */
    private Object message;

    public void execute()
        throws MojoExecutionException, MojoFailureException
    {
        getLog().info( message.toString() );
    }
}
</programlisting>
      </example>

      <para>如果你在前一节中创建的项目的<varname>${basedir}</varname>下，按照路径<filename>src/main/java/<filename>org/sonatype/mavenbook/mojo/EchoMojo.java</filename></filename>创建该Mojo，然后运行<command>mvn
      install</command>，你就可以在命令行直接调用该目标。</para>

      <screen>$ <command>mvn org.sonatype.mavenbook.plugins:first-maven-plugin:1.0-SNAPSHOT:echo</command></screen>

      <para>这一长串命令行是<command>mvn</command>后面加上<varname>groupId:artifactId:version:goal</varname>。在你运行该命令之后你应该会看到一个包含了目标echo信息的输出：“Hello
      Maven World”。如果你想要自定义该信息，你可以如下在命令行传入信息参数：</para>

      <screen>$ <command>mvn org.sonatype.mavenbook.plugins:first-maven-plugin:1.0-SNAPSHOT:echo \
             -Decho.message="The Eagle has Landed"</command></screen>

      <para>仍然按照前一条命令运行<classname>EchoMojo</classname>，会得到这样的输出：“The Eagle has
      Landed”。</para>
    </section>

    <section>
      <title>配置插件前缀</title>

      <para>在命令行声明groupId，artifactId，version和goal十分麻烦。为了处理这个问题，Maven为插件分配了前缀。你可以使用插件前缀jar，然后使用命令<command>mvn
      jar:jar</command>，而非：</para>

      <screen>$ mvn org.apache.maven.plugins:maven-jar-plugin:2.2:jar</screen>

      <para>Maven是如何解析<varname>jar:jar</varname>至<varname>org.apache.mven.plugins:maven-jar:2.3</varname>的呢？Maven查看Maven仓库中的一个文件然后获得一些列含有特定groupId的插件。默认情况下，Maven被配置成从两个组寻找插件：<varname>org.apache.maven.plugins</varname>和<varname>org.codehaus.mojo</varname>。当你指定一个新的插件前缀如<command>mvn
      hibernate3:hbm2ddl</command>的时候，Maven会为了正确的插件前缀扫描仓库元数据。首先，Maven会扫描<varname>org.apache.maven.plugins</varname>组来查找插件前缀<varname>hibernate3</varname>。如果它没有在这个组中找到该插件前缀，它就会接着扫描<varname>org.codehaus.mojo</varname>组的元数据。</para>

      <para>当Maven针对某个特定的groupId扫描元数据的时候，它从Maven仓库获取一个XML文件，该文件包含了这个组中构件的元数据。该XML文件对于每个遵循参考实现的仓库来说都是明确的，如果你不在使用一个自定义仓库，你就能在你的本地Maven仓库（<filename>~/.m2/repository</filename>）路径<filename>org/apache/maven/plugins/maven-metadata-central.xml</filename>下看到组<varname>org.apache.maven.plugins</varname>的Maven元数据。<xref
      linkend="ex-maven-metadata" />展示了这样一个XML文件的代码片段。</para>

      <example id="ex-maven-metadata">
        <title>Maven插件组的Maven元数据</title>

        <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;metadata&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;name&gt;Maven Clean Plugin&lt;/name&gt;
      &lt;prefix&gt;clean&lt;/prefix&gt;
      &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;
    &lt;/plugin&gt;
    &lt;plugin&gt;
      &lt;name&gt;Maven Compiler Plugin&lt;/name&gt;
      &lt;prefix&gt;compiler&lt;/prefix&gt;
      &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
    &lt;/plugin&gt;
    &lt;plugin&gt;
      &lt;name&gt;Maven Surefire Plugin&lt;/name&gt;
      &lt;prefix&gt;surefire&lt;/prefix&gt;
      &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
    &lt;/plugin&gt;
    ...
  &lt;/plugins&gt;
&lt;/metadata&gt;</programlisting>
      </example>

      <para>正如你在<xref
      linkend="ex-maven-metadata" />中所看到的，你本地仓库的<filename>maven-metadata-central.xml</filename>文件能帮助你运行<command>mvn
      surefire:test</command>。Maven扫描<varname>org.apache.maven.plugins</varname>和<varname>org.codehaus.mojo</varname>：<varname>org.apache.maven.plugins</varname>中的插件被认为是核心Maven插件，而<varname>org.codehaus.mojo</varname>中的被认为是额外的插件。Apache
      Maven项目管理<varname>org.apache.maven.plugins</varname>组，而另外一个独立的开源社区管理Codehaus
      Mojo项目。如果你想要发布插件到你自己的groupId下，你就需要让Maven自动扫描你的groupId以获得插件前缀，你就可以通过Maven
      settings自定义Maven需要扫描的插件组。</para>

      <para>如果你想要通过<varname>first:echo</varname>命令就能运行<varname>first-maven-plugin</varname>的echo目标，如所示，添加<varname>org.sonatype.mavenbook.plugins</varname>
      groupId至你的<filename>~/.m2/settings.xml</filename>文件中。这会让Maven优先扫描<varname>org.sonatype.mavenbook.plugins</varname>插件组。</para>

      <example id="ex-plugin-groups">
        <title>在Maven Settings中自定义插件组</title>

        <programlisting language="xml">&lt;settings&gt;
  ...
  &lt;pluginGroups&gt;
    &lt;pluginGroup&gt;org.sonatype.mavenbook.plugins&lt;/pluginGroupd&gt;
  &lt;/pluginGroups&gt;
&lt;/settings&gt;</programlisting>
      </example>

      <para>你可以在任何目录运行<command>mvn
      first:echo</command>，并看到Maven正确解析了目标前缀。这样子行得通是因为我们遵循了Maven插件的命名约定。如果你的插件有一个artifactId，并且它遵循模式<varname>maven-first-plugin</varname>，或者<varname>first-maven-plugin</varname>。Maven就会自动为你的插件赋予前缀<varname>first</varname>。换句话说，当Maven
      Plugin插件为你的插件生成插件描述符的时候，你不需要显式的为你的项目设定<varname>goalPrefix</varname>，<varname>当你的artifactId符合如下模式的时候，plugin:descriptor</varname>目标会从你插件的artifactId中抽取前缀。</para>

      <itemizedlist>
        <listitem>
          <para><varname>${prefix}-maven-plugin</varname>, OR</para>
        </listitem>

        <listitem>
          <para><varname>maven-${prefix}-plugin</varname></para>
        </listitem>
      </itemizedlist>

      <para>如果你想要显式的设定插件前缀，你需要配置Maven Plugin插件。Maven
      Plugin插件被用来构建插件描述符，并在打包和加载阶段运行一些插件特定的任务。Maven
      Plugin插件可以像其它任何插件一样在build元素下配置。要为你的插件设置插件前缀，在项目<varname>first-maven-plugin</varname>的pom.xml中添加如下的build元素：</para>

      <example id="ex-plugin-prefix">
        <title>Configuring a Plugin Prefix</title>

        <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.plugins&lt;/groupId&gt;
  &lt;artifactId&gt;first-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;maven-plugin&lt;/packaging&gt;
  &lt;name&gt;first-maven-plugin Maven Mojo&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-plugin-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.3&lt;/version&gt;
        &lt;configuration&gt;
          &lt;goalPrefix&gt;blah&lt;/goalPrefix&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.maven&lt;/groupId&gt;
      &lt;artifactId&gt;maven-plugin-api&lt;/artifactId&gt;
      &lt;version&gt;2.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting>
      </example>

      <para><xref
      linkend="ex-plugin-prefix" />设置了插件前缀为<varname>blah</varname>。如果在<filename>~/.m2/settings.xml</filename>中的<sgmltag>pluginGroups</sgmltag>下添加了<varname>org.sonatype.mavenbook.plugins</varname>元素，你就应该能够在任何目录通过<command>mvn
      blah：echo</command>命令运行<classname>EchoMojo</classname>。</para>
    </section>

    <section>
      <title>插件中的日志</title>

      <para>Maven通过在运行Mojo之前调用<methodname>setLog()</methodname>来连接你的Mojo至日志提供程序。该提供程序提供了一个<classname>org.apache.maven.monitor.logging.Log</classname>的实现。该类暴露了一些你可以用来和用户交流信息的方法。这个<classname>Log</classname>类提供了很多日志级别，与<ulink
      url="http://logging.apache.org/">Log4J</ulink>提供的API十分类似。每个级别：debug，info，error，warn，都有一系列可用的方法。为了节省时间，我们只列出了debug级别的方法：</para>

      <variablelist>
        <varlistentry>
          <term><methodname>void debug( CharSequence message
          )</methodname></term>

          <listitem>
            <para>打印信息至debug日志级别。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>void debug( CharSequence message, Throwable t
          )</methodname></term>

          <listitem>
            <para>打印信息至debug日志级别，并包含一个<classname>Throwable</classname>（<classname>Exception</classname>或者<classname>Error</classname>）的堆栈信息。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>void debug( Throwable t )</methodname></term>

          <listitem>
            <para>打印一个<classname>Throwable</classname>（<classname>Exception</classname>或者<classname>Error</classname>）的堆栈信息。</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>每个级别暴露同样的一组方法。这四个日志级别服务于不同的目的。debug级别是为了调试目的，人们用来观察mojo运行的详细情况。你应该使用debug日志级别来提供Mojo运行尽可能详细的细节，但你从不应该去假设用户会看到debug级别信息。info级别是为了生成一些正常操作的信息。如果你构建一个插件使用编译器来编译代码，你可能就需要打印编译的输出至屏幕。</para>

      <para>warn日志级别用来记录一些非预期的，但你的Mojo还能够处理的事件和错误。如果你试图运行编译Ruby源码的插件，而实际上没有可用的Ruby源码，你就需要打印一个警告信息，然后继续运行。警告（warn）不是致命的，但是错误（error）就是一些终止程序运行的情况。对于那些完全非预期的错误情况，这里有error日志级别。如果你不再能够继续运行一个Mojo，你就需要使用error。如果你在编写一个Mojo编译Java源码，但编译器不可用，你就需要打印一条信息到error级别，然后传递一条异常，以让Maven能够输出给用户。你应该假设用户能够看到大多数的info信息，以及所有的error信息。</para>
    </section>

    <section>
      <title>Mojo类注解</title>

      <para>在<varname>first-maven-plugin</varname>中，我们并没有编写插件描述符，我们依赖于Maven从源码生成插件描述符。该描述符根据你插件项目的POM信息以及<classname>EchoMojo</classname>类上一系列的注解生成。<classname>EchoMojo</classname>仅仅声明了一个<classname>@goal</classname>注解，这里有一个注解的列表，你可以将其用到Mojo实现上。</para>

      <para><variablelist>
          <varlistentry>
            <term>@goal &lt;goalName&gt;</term>

            <listitem>
              <para>这是唯一必需的注解，它给予目标一个在插件中唯一的名称。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@requiresDependencyResolution &lt;requireScope&gt;</term>

            <listitem>
              <para>标记该mojo在可以运行之前，需要特定范围（或者一个暗指的范围）的依赖。支持的范围有compile，runtime，和test。如果该注解有一个值为test，那么就是告诉Maven，除非测试范围的所有依赖都被正确解析了，否则该mojo不能运行。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@requiresProject (true|false)</term>

            <listitem>
              <para>标记该mojo必须在一个项目中运行，默认为true。这一点插件类型和骨架类型（archetype）相反，后者默认为false。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@requiresReports (true|false)</term>

            <listitem>
              <para>如果你正创建一个依赖于报告的项目，你就需要将<varname>requiresReports</varname>设置成true。该注解默认的值是false。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@aggregator (true|false)</term>

            <listitem>
              <para>一个<varname>aggregator</varname>设置成true的Mojo在Maven运行的时候只会被执行一次，有了该选项，插件开发者就可以汇总一系列构建的输出；例如，创建一个插件用来汇总一次构建包含的所有项目的报告。<varname>aggregator</varname>设置成true的目标只针对Maven构建的顶层项目运行。该注解默认的值是false。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@requiresOnline (true|false)</term>

            <listitem>
              <para>当该注解的值是true的时候，Maven在脱机模式运行的时候该目标运行就会失败。Maven会抛出一个错误。默认值：false。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@requiresDirectInvocation</term>

            <listitem>
              <para>当设置成true的时候，只有当用户显式的从命令行触发的时候，该插件才能得以执行。如果有人试图将其绑定到一个生命周期阶段，Maven就会抛出一个错误。默认值是false。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@phase &lt;phaseName&gt;</term>

            <listitem>
              <para>该注解指定目标默认的生命周期阶段。如果你将该目标的执行配置到了pom.xml而且没有指定一个阶段。Maven就会使用该注解的值将其绑定到一个默认的阶段。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@execute [goal=goalName|phase=phaseName
            [lifecycle=lifecycleId]]</term>

            <listitem>
              <para>该注解有很多种使用方式。如果提供了一个阶段，Maven就会执行一个平行的生命周期（直到指定的阶段）。这个单独执行的结果可以通过Maven属性<varname>${executedProperty}</varname>供插件使用。</para>

              <para>第二种使用该注解的方式是使用<varname>prefix:goal</varname>标记指定一个显式的目标。当你仅仅指定一个目标的时候，Maven会在一个平行的环境中执行该目标，不会影响当前的Maven构建。</para>

              <para>第三种使用该注解的方式是，使用一个生命周期定义文件，并指定这个生命周期的一个阶段。</para>

              <programlisting language="java">@execute phase="package" lifecycle="zip"
@execute phase="compile"
@execute goal="zip:zip"</programlisting>
            </listitem>
          </varlistentry>
        </variablelist></para>

      <para>如果你看一下<classname>EchoMojo</classname>的源码，你会注意到Maven并没有使用Java
      5的标准注解。而是使用了<ulink url="http://commons.apache.org/attributes/">Commons
      Attributes</ulink>。在注解成为Java语言的一部分之前，Commons
      Attributes为Java程序员提供了一种使用注解的方式。为什么Maven不使用Java 5的注解呢？这是因为Maven是针对Java
      5之前的<acronym>JVM</acronym>设计的。因为Maven必须支持Java比较老的版本，所以它不能使用任何Java
      5的新特性。</para>
    </section>

    <section>
      <title>当Mojo失败的时候</title>

      <para>Mojo中的<methodname>execute()</methodname>方法抛出两个异常，<classname>MojoExecutionException</classname>和<classname>MojoFailureException</classname>。这两个异常的区别既微妙又重要，这要看当目标运行“失败”的时候发生了什么。一个<classname>MojoExecutionException</classname>应该是一个致命的异常，发生了一些不可恢复的错误。如果有什么事情导致构建完全终止，你就需要抛出一个<classname>MojoExecutionException</classname>；比如说你正试图往磁盘写数据，但没有可用空间，或者，你试图发布构件到一个远程仓库，但是连接不了远程服务器。如果没有机会继续构建，就抛出一个<classname>MojoExecutionException</classname>；发生了一些严重的事情，你希望停止构建并让用户看到“BUILD
      ERROR”信息。</para>

      <para>而<classname>MojoFailureException</classname>就相对没有那么严重，一个目标可以失败，但它可能并不是Maven构建的世界末日。一个单元测试可以失败，或者MD5校验和可以失败；两者都是潜在的问题，但是你不会想要抛出一个异常去终止整个构建。在这种情况下，你可以抛出一个<classname>MojoFailureException</classname>。当Maven遇到项目失败的时候，他会提供不同的“弹性”设置。如下所述：</para>

      <para>当你运行一个Maven构建的时候，它会包含一系列的项目，每个项目可以成功或者失败。你可以三种可选的失败模式：</para>

      <variablelist>
        <varlistentry>
          <term>mvn -ff</term>

          <listitem>
            <para>最快失败模式：Maven会在遇到第一个失败的时候失败（停止）。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>mvn -fae</term>

          <listitem>
            <para>最后失败模式：Maven会在构建最后失败（停止）。如果Maven
            refactor中一个失败了，Maven会继续构建其它项目，并在构建最后报告失败。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>mvn -fn</term>

          <listitem>
            <para>从不失败模式：Maven从来不会为一个失败停止，也不会报告失败。</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>如果你正在运行一个持续集成构建，无论单个项目构建成败与否都要继续构建，你可能想要忽略失败。作为一个插件开发者，你必须根据你某个特定的条件来判断使用<classname>MojoExecutionException</classname>还是<classname>MojoFailureExeception</classname>。</para>
    </section>
  </section>

  <section>
    <title>Mojo参数</title>

    <para>通过参数配置Mojo，和<methodname>execute()</methodname>方法及Mojo注解相比同样重要。本节讲述有关Mojo参数的配置和主题。</para>

    <section>
      <title>为Mojo参数提供值</title>

      <para>在EchoMojo中我们使用如下的注解声明了message参数。</para>

      <programlisting language="java">/**
 * Any Object to print out.
 * @parameter
 *       expression="${echo.message}"
 *       default-value="Hello Maven World"
 */
private Object message;
</programlisting>

      <para>该参数的默认表达式是<varname>${echo.message}</varname>，意思是Maven会使用<varname>echo.message</varname>属性的值来设置message的值。如果<varname>echo.message</varname>属性的值是null，<classname>@parameter</classname>注解的default-value属性就会被使用。除了使用<varname>echo.message</varname>属性，我们也可以在项目的POM中配置EchoMojo的message参数的值。</para>

      <para>有很多中方式可以填充<classname>EchoMojo</classname>的message参数的值。首先我们可以从命令行传入一个值（假设你已经将<varname>org.sonatype.mavenbook.plugins</varname>添加到你的<sgmltag>pluginGroups</sgmltag>中）：</para>

      <screen>$ mvn first:echo -Decho.message="Hello Everybody"</screen>

      <para>我们也可以通过在POM或者settings.xml中设定一个属性来指定该message参数的值：</para>

      <programlisting language="xml">&lt;project&gt;
  ...
  &lt;properties&gt;
    &lt;echo.message&gt;Hello Everybody&lt;/echo.message&gt;
  &lt;/properties&gt;
&lt;/project&gt;
</programlisting>

      <para>该参数还可以直接通过配置插件来进行配置。如果我们想要直接自定义message参数，我们可以使用如下的build配置。下面的配置绕开了echo.message属性，而是在插件配置中填充Mojo参数：</para>

      <programlisting language="xml">&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.sonatype.mavenbook.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;first-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;configuration&gt;
          &lt;message&gt;Hello Everybody!&lt;/message&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;</programlisting>

      <para>如果我们想要在一个生命周期的不同阶段中运行<classname>EchoMojo</classname>两次，并且希望每次运行都能自定义message参数，我们可以在如下在POM中的execution级别配置这个参数值：</para>

      <programlisting language="xml">&lt;build&gt;
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.sonatype.mavenbook.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;first-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;first-execution&lt;/id&gt;
            &lt;phase&gt;generate-resources&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;echo&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;message&gt;The Eagle has Landed!&lt;/message&gt;
            &lt;/configuration&gt;
          &lt;/execution&gt;
          &lt;execution&gt;
            &lt;id&gt;second-execution&lt;/id&gt;
            &lt;phase&gt;validate&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;echo&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;message&gt;${project.version}&lt;/message&gt;
            &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/build&gt;</programlisting>

      <para>虽然上面的配置样例看起来有些啰嗦，但它展示了Maven的弹性。在前面的配置样例中，我们将<classname>EchoMojo</classname>同时绑定到了默认Maven生命周期的<varname>validate</varname>和<varname>generate-resources</varname>阶段。第一次执行被绑定到了<varname>generate-resources</varname>，它为message参数提供了字符串值“The
      Eagle has
      Landed!”。第二次运行则被绑定到了<varname>validate</varname>阶段，它提供了一个属性引用<varname>${project.version}</varname>。当你为该项目运行<command>mvn
      install</command>的时候，你会看到<varname>first:echo</varname>目标执行了两次，并打印了不同的信息。</para>
    </section>

    <section>
      <title>多值的Mojo参数</title>

      <para>插件的参数可以接受多于一个的值。看一下<xref
      linkend="ex-plugin-multivalue" />中的<classname>ZipMojo</classname>。参数<varname>includes</varname>和<varname>excludes</varname>都是多值的<classname>String</classname>数组，它们为一个创建ZIP文件的组件指定了包含和排除模式。</para>

      <example id="ex-plugin-multivalue">
        <title>一个带有多值参数的插件</title>

        <programlisting language="java">package org.sonatype.mavenbook.plugins

/**
 * Zips up the output directory.
 * @goal zip
 * @phase package
 */
public class ZipMojo extends AbstractMojo
{
    /**
     * The Zip archiver.
     * @parameter expression="${component.org.codehaus.plexus.archiver.Archiver#zip}"
     */
    private ZipArchiver zipArchiver;

    /**
     * Directory containing the build files.
     * @parameter expression="${project.build.directory}"
     */
    private File buildDirectory;

    /**
     * Base directory of the project.
     * @parameter expression="${basedir}"
     */
    private File baseDirectory;

    /**
     * A set of file patterns to include in the zip.
     * @parameter alias="includes"
     */
    private String[] mIncludes;

    /**
     * A set of file patterns to exclude from the zip.
     * @parameter alias="excludes"
     */
    private String[] mExcludes;

    public void setExcludes( String[] excludes ) { mExcludes = excludes; }

    public void setIncludes( String[] includes ) { mIncludes = includes; }

    public void execute()
        throws MojoExecutionException
    {
        try {
            zipArchiver.addDirectory( buildDirectory, includes, excludes );
            zipArchiver.setDestFile( new File( baseDirectory, "output.zip" ) );
            zipArchiver.createArchive();
        } catch( Exception e ) {
            throw new MojoExecutionException( "Could not zip", e );
        }
    }
}
</programlisting>

        <para>要配置一个多值的Mojo参数，你应该为这类参数使用一组元素。如果这个多值参数的名称是includes，你就可以使用一个includes元素，它包含一组include子元素。如果这个多值参数的名称是excludes，你就应该使用带有exclude子元素的excludes元素。要配置<classname>ZipMojo</classname>使其忽略所有以.txt及波浪号结尾的文件，你可以使用如下的插件配置。</para>
      </example>

      <programlisting language="xml">&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.sonatype.mavenbook.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;zip-maven-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;excludes&gt;
            &lt;exclude&gt;**/*.txt&lt;/exclude&gt;
            &lt;exclude&gt;**/*~&lt;/exclude&gt;
          &lt;/excludes&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</programlisting>
    </section>

    <section>
      <title>依赖于一个Plexus组件</title>

      <para>一个Mojo是一个由名为Plexus的Ioc容器管理的组件。Mojo可以通过使用<classname>@parameter或</classname><classname>@component</classname>注解声明Mojo参数，然后依赖于其它Plexu管理的组件。<xref
      linkend="ex-plugin-multivalue" />展示了<classname>ZipMojo</classname>使用<classname>@parameter</classname>注解依赖于一个Plexus组件，该依赖也可以使用<classname>@component</classname>注解来声明。</para>

      <example>
        <title>依赖于一个Plexus组件</title>

        <programlisting language="java">/**
 * The Zip archiver.
 * @component role="org.codehaus.plexus.archiver.Archiver" roleHint="zip"
 */
private ZipArchiver zipArchiver;</programlisting>
      </example>

      <para>当Maven初始化该Mojo的时候，它会尝试通过指定的role和role
      hint来获取Plexus组件。在该例中，这个Mojo关联到一个ZipArchiver组件，后者能帮助<classname>ZipMojo</classname>创建ZIP文件。</para>

      <!--TODO: OK, we need more here.  How do I get my hands on components?  How to a bundle components?-->
    </section>

    <section>
      <title>Mojo参数注解</title>

      <para>除非你坚持要手工编写自己的插件描述符，否则你完全不需要编写那个XML文件。Maven
      Plugin插件有一个<varname>plugin:descriptor</varname>目标绑定到了generate-resources阶段。该目标根据Mojo的注解生成插件描述符。要配置Mojo参数，你应该使用下列的注解，将其声明到私有成员变量上。你也可以在公有setter方法上使用这些注解，但Maven插件一般的约定是直接注解私有成员变量。</para>

      <variablelist>
        <varlistentry>
          <term>@parameter [alias="someAlias"]
          [expression="${someExpression}"] [default-value="value"]</term>

          <listitem>
            <para>标记一个私有字段（或者一个setter方法）为一个参数。<varname>alias</varname>提供该参数的名称。如果没有<varname>alias</varname>，Maven会使用变量名为参数名。<varname>expression</varname>是一个Maven用来计算并获值的一个表达式。通常这个表达式只是一个属性引用如<varname>${echo.message}</varname>。<varname>default-value</varname>是当表达式不能求得值，POM的插件配置中也没有显式提供时，Mojo会使用的值。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>@required</term>

          <listitem>
            <para>如果使用了该注解，那么在该Mojo运行前该参数就必须要有一个可用的值。如果Maven试图运行该Mojo的时候该参数的值为null，Maven就会抛出一个错误。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>@readonly</term>

          <listitem>
            <para>如果使用该注解，用户就不能从POM直接配置这个参数。你就需要parameter注解的expression属性。例如，如果你想要确保一个特定参数的值永远是POM中finalName属性的值，你就可以使用表达式<varname>${build.finalName}</varname>，并添加这个<classname>@readOnly</classname>注解。这样，用户就只能通过更改POM中<varname>finalName</varname>的值来更改这个参数的值。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>@component</term>

          <listitem>
            <para>告诉Maven使用Plexus组件填充该字段。一个正确的<classname>@component</classname>注解值如下：</para>

            <programlisting language="java">@component role="org.codehaus.plexus.archiver.Archiver" roleHint="zip"
</programlisting>

            <para>该配置的效果是可以从Plexus获得<classname>ZipArchiver</classname>组件。<classname>ZipArchiver</classname>是一个对应role
            hint为<varname>zip</varname>的Archiver组件。除了@component注解，你也可以使用@parameter注解和一个expression属性，如：</para>

            <programlisting language="java">@parameter expression="${component.org.codehaus.plexus.archiver.Archiver#zip}"
</programlisting>

            <para>虽然两种注解的效果一样，但对于配置Plexus组件依赖来说，<classname>@component</classname>注解是更推荐的方式。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>@deprecated</term>

          <listitem>
            <para>该参数以过期，不再推荐使用。用户可以继续配置该参数，但会得到一条警告信息。</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>

  <section>
    <title>插件和Maven生命周期</title>

    <para>在<xref
    linkend="lifecycle" />中，你学习了生命周期可以通过打包类型定制。一个插件可以同时引入一个新的打包类型，并自定义该生命周期。在本节中，我们将会学习如果通过一个自定义的Maven插件来自定义生命周期。你同时也会看到如何让Mojo在平行的生命周期中执行。</para>

    <section>
      <title>执行平行的生命周期</title>

      <para>让我们假设你编写了一些目标，它们依赖于前一个构建的输出。也许<classname>ZipMojo</classname>目标只有在拥有归档输出的前提下才能运行。你可以使用Mojo类的<classname>@execute</classname>注解来指定这样的前置目标。该注解会让Maven生成一个平行的构建，并在这个平行的Maven实例中执行一个目标或者生命周期，该运行并不会影响当前构建。也许你编写了一个Mojo，它每天只运行一次，它首先会运行<command>mvn
      install</command>，然后将所有的输出打包至某种自定义的分发格式。你的Mojo描述符可以告诉Maven，在运行这个自定义Mojo之前，你想要运行默认生命周期的所有直到install的阶段，然后以属性<varname>${executedProject}</varname>的形式将项目结果暴露给你的Mojo。然后你就可以在进行某种后期处理之前引用那个项目的属性。</para>

      <para>另一种可能性是，你有一个目标做一些与默认生命周期完全无关的工作。让我们考虑这样一个例子，你有一个目标使用LAME将WAV文件转换成MP3，但在这之前你需要运行一个生命周期，将MIDI文件转换成WAV。（你可以用Maven做任何事，这里的例子并没有太“离谱”）你已经创建了一个“midi-sound”生命周期，现在你想要包含midi-sound生命周期install阶段的输出，而现在你自己的web应用项目的打包类型是war。由于你的项目在war打包类型生命周期运行，你需要让mojo能够fork一个完全独立的，使用midi-sound的生命周期。你可以通过在你的mojo上添加注解<varname>@execute
      lifecycle="midi-source" phase="install"</varname>来达到这样的目的。</para>

      <variablelist>
        <varlistentry>
          <term>@execute goal="&lt;goal&gt;"</term>

          <listitem>
            <para>会在执行当前目标之前运行声明的目标。目标名称使用<varname>prefix:goal</varname>标记指定。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>@execute phase="&lt;phase&gt;"</term>

          <listitem>
            <para>在执行当前生命周期之前，fork出另一个构建生命周期（直到指定的阶段）。如果没有指定生命周期，Maven会使用当前构建的生命周期。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>@execute lifecycle="&lt;lifecycle&gt;"
          phase="&lt;phase&gt;"</term>

          <listitem>
            <para>会执行给定的生命周期。自定义的生命周期可以在<filename>META-INF/maven/lifecycle.xml</filename>中定义。</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section>
      <title>创建自定义的生命周期</title>

      <para>自定义生命周期必须在插件项目的<filename>META-INF/maven/lifecycle.xml</filename>文件中定义。你可以引入这个定义在<filename>src/main/resources</filename>下的<filename>META-INF/maven/lifecycle.xml</filename>文件。以下的<filename>lifecycle.xml</filename>声明了一个名为<varname>zipcycle</varname>的生命周期，它在<varname>package</varname>阶段包含了一个<varname>zip</varname>目标。</para>

      <para><example>
          <title>在lifecycle.xml中自定义生命周期</title>

          <programlisting language="xml">&lt;lifecycles&gt;
  &lt;lifecycle&gt;
    &lt;id&gt;zipcycle&lt;/id&gt;
    &lt;phases&gt;
      &lt;phase&gt;
        &lt;id&gt;package&lt;/id&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;goals&gt;
              &lt;goal&gt;zip&lt;/goal&gt;
            &lt;/goals&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/phase&gt;
    &lt;/phases&gt;
  &lt;/lifecycle&gt;
&lt;/lifecycles&gt;
</programlisting>
        </example></para>

      <para>如果你想要在另一个构建中运行这个<varname>zipcycle</varname>生命周期，你可以创建一个<classname>ZipForkMojo</classname>，然后使用<classname>@execute</classname>注解来告诉Maven，当<classname>ZipForkMojo</classname>运行的时候，逐步通过<varname>zipcycle</varname>生命周期的阶段。</para>

      <para><example>
          <title>在Mojo中Fork一个自定义生命周期</title>

          <programlisting language="java">/**
 * Forks a zip lifecycle.
 * @goal zip-fork
 * @execute lifecycle="zipcycle" phase="package"
 */
public class ZipForkMojo extends AbstractMojo
{
  public void execute()
    throws MojoExecutionException
  {
    getLog().info( "doing nothing here" );
  }
}
</programlisting>
        </example></para>

      <para>运行<classname>ZipForkMojo</classname>的时候会fork出另一个生命周期。如果你配置了你插件的前缀为zip，运行<varname>zip-fork</varname>会得到类似于如下输出的结果：</para>

      <screen>$ mvn zip:zip-fork
[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'zip'.
[INFO] ----------------------------------------------------------------------------
[INFO] Building Maven Zip Forked Lifecycle Test
[INFO]    task-segment: [zip:zip-fork]
[INFO] ----------------------------------------------------------------------------
[INFO] Preparing zip:zip-fork
[INFO] [site:attach-descriptor]
[INFO] [zip:zip]
[INFO] Building zip: ~/maven-zip-plugin/src/projects/zip-lifecycle-test/target/output.zip
[INFO] [zip:zip-fork]
[INFO] doing nothing here
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 1 second
[INFO] Finished at: Sun Apr 29 16:10:06 CDT 2007
[INFO] Final Memory: 3M/7M
[INFO] ------------------------------------------------------------------------
</screen>

      <para>调用<varname>zip-fork</varname>会衍生出另外一个生命周期，Maven运行<varname>zipcycle</varname>生命周期，然后从<classname>ZipFormMojo</classname>的execute方法打印信息。</para>
    </section>

    <section>
      <title>覆盖默认生命周期</title>

      <para>你已经创建了自己的生命周期，并能在一个Mojo中将其衍生使用。下一个你可能要问的问题是，如何覆盖默认的生命周期。如何如何创建定制的生命周期并将其绑定到项目上？在<xref
      linkend="lifecycle" />中，我们看到了项目的打包类型定义了项目的生命周期。所有打包类型都有差异；war绑定不同的目标到package阶段，自定义的生命周期如来自Israfil
      Flex
      3的swf绑定不同的目标到compile阶段。在你创建自定义生命周期的时候，你可以通过为插件提供一些Plexus配置，将生命周期绑定到特定的打包类型。</para>

      <para>要为新的生命周期定义新的打包类型，你需要配置Plexus中的<classname>LifecycleMapping</classname>组件。在你的插件项目中，在src/main/resources下创建一个<filename>META-INF/plexus/components.xml</filename>文件。在这个components.xml中添加如<xref
      linkend="ex-override-lifecycle" />的内容。在<varname>role-hint</varname>下设置打包类型的名称，在pheases中设置包含所有需要绑定目标的坐标（省略version）。多个目标可以用逗号分隔，绑定到同一个阶段。</para>

      <para><example id="ex-override-lifecycle">
          <title>覆盖默认生命周期</title>

          <programlisting language="xml">&lt;component-set&gt;
  &lt;components&gt;
    &lt;component&gt;
      &lt;role&gt;org.apache.maven.lifecycle.mapping.LifecycleMapping&lt;/role&gt;
      &lt;role-hint&gt;zip&lt;/role-hint&gt;
      &lt;implementation&gt;org.apache.maven.lifecycle.mapping.DefaultLifecycleMapping&lt;/implementation&gt;
      &lt;configuration&gt;
        &lt;phases&gt;
          &lt;process-resources&gt;org.apache.maven.plugins:maven-resources-plugin:resources&lt;/process-resources&gt;
          &lt;compile&gt;org.apache.maven.plugins:maven-compiler-plugin:compile&lt;/compile&gt;
          &lt;package&gt;org.sonatype.mavenbook.plugins:maven-zip-plugin:zip&lt;/package&gt;
        &lt;/phases&gt;
      &lt;/configuration&gt;
    &lt;/component&gt;
  &lt;/components&gt;
&lt;/component-set&gt;
</programlisting>
        </example></para>

      <para>如果你创建了一个插件，它定义了新的打包类型和定制的生命周期，Maven在将你的插件添加到项目POM中并设置extensions元素为true之前，对你插件的定义一概不知。只有在那之后，Maven才会扫描你的插件，而不仅仅只是运行Mojo，它会查找<filename>META-INF/plexus</filename>下的<filename>components.xml</filename>文件，然后它会在你的项目中使新的打包类型可用。</para>

      <para><example>
          <title>作为一个Extension配置一个插件</title>

          <programlisting language="xml">&lt;project&gt;
  ...
  &lt;build&gt;
    ...
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;com.training.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-zip-plugin&lt;/artifactId&gt;
        &lt;extensions&gt;true&lt;/extensions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>一旦你添加了插件，并将extensions元素设置成true，你就可以使用这个定制的打包类型，你的项目就能运行关联到该打包类型的定制生命周期。</para>
    </section>
  </section>
</chapter>
