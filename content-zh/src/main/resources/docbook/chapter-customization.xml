<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter>
  <title>定制一个Maven项目</title>

  <section>
    <title>介绍</title>

    <para>本章在上一章所介绍信息的基础上进行开发。 你将创建一个由 Maven Archetype
    插件生成的项目，添加一些依赖和一些源代码，并且根据你的需要定制项目。本章最后，你将知道如何使用 Maven 开始创建真正的项目。</para>

    <section>
      <title>下载本章样例</title>

      <para>本章我们将开发一个和 Yahoo! Weather web
      服务交互的实用程序。虽然没有样例源码你也应该能够理解这个开发过程，但还是推荐你下载本章样例源码以作为参考。
      本章的样例项目包含在本书的样例代码中，你可以从两个地方下载，<ulink
      url="http://www.sonatype.com/book/mvn-examples-1.0.zip">http://www.sonatype.com/book/mvn-examples-1.0.zip</ulink>
      或者 <ulink
      url="http://www.sonatype.com/book/mvn-examples-1.0.tar.gz">http://www.sonatype.com/book/mvn-examples-1.0.tar.gz</ulink>
      。解压存档文件至任意目录，然后到 <filename>ch04/</filename> 目录。 在
      <filename>ch04/</filename> 目录你会看到一个名为
      <filename>simple-weather</filename> 的目录，它包含了本章开发出来的 Maven
      项目。如果你想要在浏览器里看样例代码，访问 <ulink
      url="http://www.sonatype.com/book/examples-1.0">http://www.sonatype.com/book/examples-1.0</ulink>
      ，然后点击 <filename>ch04/</filename> 目录。</para>
    </section>
  </section>

  <section>
    <title>定义Simple Weather项目</title>

    <para>在定制本项目之前，让我们退后一步，讨论下这个 simple weather 项目。 这个 simple weather 项目是什么？
    它是一个被设计成用来示范一些 Maven 特征的样例。 它能代表一类你可能需要构建的应用程序。 这个 simple weather
    是一个基本的命令行驱动的应用程序，它接受邮政编码输入，然后从 Yahoo! Weather <acronym>RSS</acronym>
    源获取数据，然后解析数据并把结果打印到标准输出。 我们选择该项目是有许多因素的。 首先，它很直观；用户通过命令行提供输入，程序读取邮政编码，对
    Yahoo! Weather 提交请求，之后解析结果，格式化之后输入到屏幕。 这个样例是个简单的
    <function>main()</function> 函数加上一些相关支持的类；没有企业级框架需要介绍或解释，只有
    <acronym>XML</acronym> 解析和一些日志语句。 其次，它提供很好的机会来介绍一些有趣的类库，如 Velocity, Dom4j
    和 Log4j。 虽然本书集中于 Maven ，但我们不会回避那些介绍有趣工具的机会。
    最后，这是一个能在一章内介绍，开发及部署的样例。</para>

    <section>
      <title>Yahoo! Weather RSS</title>

      <para>在开始构建这个应用之前，你需要了解一下 Yahoo! Weather <acronym>RSS</acronym>
      源。该服务是基于以下条款提供的：</para>

      <blockquote>
        <para>“该数据源免费提供给个人和非营利性组织，作为个人或其它非商业用途。 我们要求你提供给 Yahoo! Weather
        连接你数据源应用的权限。”</para>
      </blockquote>

      <para>换句话说，如果你考虑集成该数据源到你的商业 web 站点上，请再仔细考虑考虑，该数据源可作为个人或其它非商业性用途。
      本章我们提倡的使用是个人教育用途。 要了解更多的 Yahoo! Weather 服务条款，请参考 Yahoo! Weather API 文档：
      <ulink
      url="http://developer.yahoo.com/weather/">http://developer.yahoo.com/weather/</ulink>
      。</para>
    </section>
  </section>

  <section>
    <title>创建Simple Weather项目</title>

    <para>首先，让我们用 Maven Archetype 插件创建这个 simple weather 项目的基本轮廓。
    运行下面的命令，创建新项目：<screen><command>$ mvn archetype:create -DgroupId=org.sonatype.mavenbook.ch04 \
                                         -DartifactId=simple-weather \
                                         -DpackageName=org.sonatype.mavenbook \
                                         -Dversion=1.0
</command>[INFO] [archetype:create]
[INFO] artifact org.apache.maven.archetypes:maven-archetype-quickstart: \
       checking for updates from central
[INFO] ------------------------------------------------------------------
[INFO] Using following parameters for creating Archetype: \
       maven-archetype-quickstart:RELEASE
[INFO] ------------------------------------------------------------------
[INFO] Parameter: groupId, Value: org.sonatype.mavenbook.ch04
[INFO] Parameter: packageName, Value: org.sonatype.mavenbook
[INFO] Parameter: basedir, Value: ~/examples
[INFO] Parameter: package, Value: org.sonatype.mavenbook
[INFO] Parameter: version, Value: 1.0
[INFO] Parameter: artifactId, Value: simple-weather
[INFO] *** End of debug info from resources from generated POM ***
[INFO] Archetype created in dir: ~/examples/simple-weather</screen></para>

    <para>在 Maven Archetype 插件创建好了这个项目之后，进入到 simple-weather 目录，看一下
    <filename>pom.xml</filename>。你会看到如下的 <acronym>XML</acronym> 文档：</para>

    <example>
      <title>simple-wheather 项目的初始 <acronym>POM</acronym></title>

      <programlisting>&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.ch04&lt;/groupId&gt;
  &lt;artifactId&gt;simple-weather&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;name&gt;simple-weather2&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</programlisting>
    </example>

    <para>请注意我们给 <varname>archetype:create</varname> 目标传入了
    <varname>version</varname> 参数。它覆写了默认值 <literal>1.0-SNAPSHOT</literal>
    。本项目中，正如你从 <filename>pom.xml</filename> 的 <varname>version</varname>
    元素看到的，我们正在开发 <varname>simple-weather</varname> 项目的 <literal>1.0</literal>
    版本。</para>
  </section>

  <section>
    <title>定制项目信息</title>

    <para>在开始编写代码之前，让我们先定制一些项目的信息。 我们想要做的是添加一些关于项目许可证，组织以及项目相关开发人员的一些信息。
    这些都是你期望能在大部分项目中看到的标准信息。下面的文档展示了提供组织信息，许可证信息和开发人员信息的 <acronym>XML</acronym>
    。</para>

    <example id="ex-custom-org-info">
      <title>为 pom.xml 添加组织，法律和开发人员信息</title>

      <programlisting>&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
...

  &lt;name&gt;simple-weather&lt;/name&gt;
  &lt;url&gt;http://www.sonatype.com&lt;/url&gt;

  &lt;licenses&gt;
    &lt;license&gt;
      &lt;name&gt;Apache 2&lt;/name&gt;
      &lt;url&gt;http://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt;
      &lt;distribution&gt;repo&lt;/distribution&gt;
      &lt;comments&gt;A business-friendly OSS license&lt;/comments&gt;
    &lt;/license&gt;
  &lt;/licenses&gt;

  &lt;organization&gt;
    &lt;name&gt;Sonatype&lt;/name&gt;
    &lt;url&gt;http://www.sonatype.com&lt;/url&gt;
  &lt;/organization&gt;

  &lt;developers&gt;
    &lt;developer&gt;
      &lt;id&gt;jason&lt;/id&gt;
      &lt;name&gt;Jason Van Zyl&lt;/name&gt;
      &lt;email&gt;jason@maven.org&lt;/email&gt;
      &lt;url&gt;http://www.sonatype.com&lt;/url&gt;
      &lt;organization&gt;Sonatype&lt;/organization&gt;
      &lt;organizationUrl&gt;http://www.sonatype.com&lt;/organizationUrl&gt;
      &lt;roles&gt;
        &lt;role&gt;developer&lt;/role&gt;
      &lt;/roles&gt;
      &lt;timezone&gt;-6&lt;/timezone&gt;
    &lt;/developer&gt;
  &lt;/developers&gt;
...
&lt;/project&gt;
</programlisting>
    </example>

    <para><xref linkend="ex-custom-org-info" /> 中的省略号是为了使代码清单变得简短。 当你在
    <filename>pom.xml</filename> 中看到 <varname>project</varname> 元素的开始标签后面跟着
    “…” 或者在 <varname>project</varname> 元素的结束标签前有 “…” ，这说明我们没有展示整个
    <filename>pom.xml</filename>
    文件。在上述情况中，<varname>licenses</varname>，<varname>organization</varname> 和
    <varname>developers</varname> 元素是加在 <varname>dependencies</varname>
    元素之前的。</para>
  </section>

  <section>
    <title>添加新的依赖</title>

    <para>Simple weather 应用程序必须要完成以下三个任务：从 Yahoo! Weather 获取
    <acronym>XML</acronym> 数据，解析 <acronym>XML</acronym>
    数据，打印格式化的输出至标准输出。为了完成这三个任务，我们需要为项目的 <filename>pom.xml</filename> 引入一些新的依赖。
    为了解析来自 Yahoo! 的 <acronym>XML</acronym> 响应，我们将会使用 Dom4J 和 Jaxen
    ，为了格式化这个命令行程序的输出，我们将会使用 Velocity ，我们还需要加入对 Log4j 的依赖，用来做日志。加入这些依赖之后，我们的
    dependencies 元素就成了以下模样：<example>
        <title>添加 Dom4J, Jaxen, Velocity 和 Log4J 作为依赖</title>

        <programlisting>&lt;project&gt;
  [...]
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;log4j&lt;/groupId&gt;
      &lt;artifactId&gt;log4j&lt;/artifactId&gt;
      &lt;version&gt;1.2.14&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;dom4j&lt;/groupId&gt;
      &lt;artifactId&gt;dom4j&lt;/artifactId&gt;
      &lt;version&gt;1.6.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;jaxen&lt;/groupId&gt;
      &lt;artifactId&gt;jaxen&lt;/artifactId&gt;
      &lt;version&gt;1.1.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;velocity&lt;/groupId&gt;
      &lt;artifactId&gt;velocity&lt;/artifactId&gt;
      &lt;version&gt;1.5&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  [...]
&lt;/project&gt;</programlisting>
      </example><parameter>正如你从上面所看到的，我们在范围为 <varname>test</varname> 的 JUnit
    依赖基础上又加了四个依赖元素。如果你把这些依赖添加到项目的 <filename>pom.xml</filename> 文件然后运行
    <command>mvn install</command> ，你会看到 Maven 下载这些依赖及其它传递性依赖到你的本地 Maven 仓库。
    我们如何找这些依赖呢？我们都“知道”适当的 <varname>groupId</varname> 和
    <varname>artifactId</varname> 的值吗？有些依赖 (像 Log4J)
    被广泛使用，以至于每次你需要使用它们的时候你都会记得它们的 <varname>groupId</varname> 和
    <varname>artifactId</varname>。 而 Velocity， Dom4J 和 Jaxen 是通过一个十分有用的站点
    <ulink
    url="http://www.mvnrepository.com">http://www.mvnrepository.com</ulink>
    来定位的。 该站点提供了针对 Maven 仓库的搜索接口，你可以用它来搜索依赖。 你可以自己测试一下，载入 <ulink
    url="http://www.mvnrepository.com">http://www.mvnrepository.com</ulink>
    然后搜索一些常用的类库，如 Hibernate 或者 Spring Framework 。当你在这上面搜索构件时，它会显示一个
    <varname>artifactId</varname> 和所有 Maven 中央仓库所知道的版本。
    点击某个特定的版本后，它会载入一个页面，这个页面就包括了你需要复制到你自己项目 <filename>pom.xml</filename>
    中的依赖元素。 你经常会发现某个特定的类库拥有多于一个的 <varname>groupId</varname>，这个时候你需要通过 <ulink
    url="http://www.mvnrepository.com">mvnrepository.com</ulink>
    来帮助确定你到底需要怎样配置你的依赖。 </parameter></para>
  </section>

  <section>
    <title>Simple Weather源码</title>

    <para>Simple Weather 命令行应用程序包含五个 Java 类。</para>

    <variablelist>
      <varlistentry>
        <term><classname>org.sonatype.mavenbook.weather.Main</classname></term>

        <listitem>
          <para>这个类包含了一个静态的 <methodname>main()</methodname> 函数，即系统的入口。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><classname>org.sonatype.mavenbook.weather.Weather</classname></term>

        <listitem>
          <para><classname>Weather</classname> 类是个很简单的 Java
          Bean，它保存了天气报告的地点和其它一些关键元素，如气温和湿度。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><classname>org.sonatype.mavenbook.weather.YahooRetriever</classname></term>

        <listitem>
          <para><classname>YahooRetriever</classname> 连接到 Yahoo! Weather
          并且返回来自数据源数据的 <classname>InputStream</classname> 。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><classname>org.sonatype.mavenbook.weather.YahooParser</classname></term>

        <listitem>
          <para><classname>YahooParser</classname> 解析来自 Yahoo! Weather 的
          <acronym>XML</acronym>，返回 <classname>Weather</classname> 对象。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><classname>org.sonatype.mavenbook.weather.WeatherFormatter</classname></term>

        <listitem>
          <para><classname>WeatherFormatter</classname> 接受
          <classname>Weather</classname> 对象，创建
          <classname>VelocityContext</classname> ，根据 Velocity 模板生成结果。</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>这里我们不是想要详细阐述样例中的代码，但解释一下程序中使之运行的核心代码还是必要的。
    我们假设大部分读者已经下载的本书的源码，但也不会忘记那些按着书一步一步往下看的读者。 本小节列出了
    <varname>simple-weather</varname>
    项目的类，这些类都放在同一个包下面，<package>org.sonatype.mavenbook.weather</package> 。</para>

    <para>让我们删掉由 <varname>archetype:create</varname> 生成
    <classname>App</classname> 类和 <classname>AppTest</classname> 类，然后加入我们新的包。在
    Maven 项目中，所有项目的源代码都存储在 <filename>src/main/java</filename> 目录。
    在新项目的基础目录下，运行下面的命令：</para>

    <screen>$ <command>cd src/test/java/org/sonatype/mavenbook</command>
$ <command>rm AppTest.java</command>
$ <command>cd ../../../../../..</command>
$ <command>cd src/main/java/org/sonatype/mavenbook</command>
$ <command>rm App.java</command>
$ <command>mkdir weather</command>
$ <command>cd weather</command></screen>

    <para>你已经创建了一个新的包 <package>org.sonatype.mavenbook.weather</package> 。
    现在，我们需要把那些类放到这个目录下面。 用你最喜欢的编辑器，创建一个新文件，名字为
    <filename>Weather.java</filename>，内容如下：</para>

    <example>
      <title>Simple Weather 的 Weather 模型对象</title>

      <programlisting language="java">package org.sonatype.mavenbook.weather;


public class Weather {
  private String city;
  private String region;
  private String country;
  private String condition;
  private String temp;
  private String chill;
  private String humidity;
    
  public Weather() {}

  public String getCity() { return city; }
  public void setCity(String city) { this.city = city; }

  public String getRegion() { return region; }
  public void setRegion(String region) { this.region = region; }

  public String getCountry() { return country; }
  public void setCountry(String country) { this.country = country; }

  public String getCondition() { return condition; }
  public void setCondition(String condition) { this.condition = condition; }

  public String getTemp() { return temp; }
  public void setTemp(String temp) { this.temp = temp; }
         
  public String getChill() { return chill; }
  public void setChill(String chill) { this.chill = chill; }

  public String getHumidity() { return humidity; }
  public void setHumidity(String humidity) { this.humidity = humidity; }
}
</programlisting>
    </example>

    <para><classname>Weather</classname> 类定义了一个简单的 bean ，用来存储由 Yahoo! Weather
    数据源解析出来的天气信息。天气数据源提供了丰富的信息，从日出日落时间，到风速和风向。 为了让这个例子保持简单，
    <classname>Weather</classname> 模型对象只保存温度，湿度和当前天气情况的文字描述等信息。</para>

    <para>在同一目录下，创建 <filename>Main.java</filename>
    文件。<classname>Main</classname> 这个类有一个静态的 <function>main()</function>
    函数——样例程序的入口。</para>

    <example>
      <title>Simple Weather 的 Main 类</title>

      <programlisting language="java">package org.sonatype.mavenbook.weather;

import java.io.InputStream;

import org.apache.log4j.PropertyConfigurator;


public class Main {

  public static void main(String[] args) throws Exception {
    // Configure Log4J
    PropertyConfigurator.configure(Main.class.getClassLoader()
                                       .getResource("log4j.properties"));

    // Read the Zip Code from the Command-line (if none supplied, use 60202)
    int zipcode = 60202;
    try {
      zipcode = Integer.parseInt(args[0]);
    } catch( Exception e ) {}

    // Start the program
    new Main(zipcode).start();
  }

  private int zip;

  public Main(int zip) {
    this.zip = zip;
  }

  public void start() throws Exception {
    // Retrieve Data
    InputStream dataIn = new YahooRetriever().retrieve( zip );

    // Parse Data
    Weather weather = new YahooParser().parse( dataIn );

    // Format (Print) Data
    System.out.print( new WeatherFormatter().format( weather ) );
  }
}
</programlisting>
    </example>

    <para>上例中的 <function>main()</function> 函数通过获取 classpath 中的资源文件来配置 Log4J
    ，之后它试图从命令行读取邮政编码。 如果在读取邮政编码的时候抛出了异常，程序会设置默认邮政编码为 60202 。 一旦有了邮政编码，它初始化一个
    <classname>Main</classname> 对象，调用该对象的 <function>start()</function> 方法。而
    <function>start()</function> 方法会调用 <classname>YahooRetriever</classname>
    来获取天气的 <acronym>XML</acronym> 数据。 <classname>YahooRetriever</classname>
    返回一个 <classname>InputStreem</classname> ，传给
    <classname>YahooParser</classname> 。 <classname>YahooParser</classname> 解析
    <acronym>XML</acronym> 数据并返回 <classname>Weather</classname> 对象。
    最后，<classname>WeatherFormatter</classname> 接受一个
    <classname>Weather</classname> 对象并返回一个格式化的 <classname>String</classname>
    ，打印到标准输出。</para>

    <para>在相同目录下创建文件 <filename>YahooRetriever.java</filename> ，内容如下：</para>

    <example>
      <title>Simple Weather 的 YahooRetriever 类</title>

      <programlisting language="java">package org.sonatype.mavenbook.weather;

import java.io.InputStream;
import java.net.URL;
import java.net.URLConnection;

import org.apache.log4j.Logger;

public class YahooRetriever {

  private static Logger log = Logger.getLogger(YahooRetriever.class);

  public InputStream retrieve(int zipcode) throws Exception {
    log.info( "Retrieving Weather Data" );
    String url = "http://weather.yahooapis.com/forecastrss?p=" + zipcode;
    URLConnection conn = new URL(url).openConnection();
    return conn.getInputStream();
  }
}
</programlisting>
    </example>

    <para>这个简单的类打开一个连接到 Yahoo! Weather API 的
    <classname>URLConnection</classname> 并返回一个
    <classname>InputStream</classname> 。 我们还需要在该目录下创建文件
    <filename>YahooParser.java</filename> 用以解析这个数据源。</para>

    <example>
      <title>Simple Weather 的 YahooParser 类</title>

      <programlisting language="java">package org.sonatype.mavenbook.weather;

import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;

import org.apache.log4j.Logger;
import org.dom4j.Document;
import org.dom4j.DocumentFactory;
import org.dom4j.io.SAXReader;

public class YahooParser {

  private static Logger log = Logger.getLogger(YahooParser.class);

  public Weather parse(InputStream inputStream) throws Exception {
    Weather weather = new Weather();
  
    log.info( "Creating XML Reader" );
    SAXReader xmlReader = createXmlReader();
    Document doc = xmlReader.read( inputStream );

    log.info( "Parsing XML Response" );
    weather.setCity( doc.valueOf("/rss/channel/y:location/@city") );
    weather.setRegion( doc.valueOf("/rss/channel/y:location/@region") );
    weather.setCountry( doc.valueOf("/rss/channel/y:location/@country") );
    weather.setCondition( doc.valueOf("/rss/channel/item/y:condition/@text") );
    weather.setTemp( doc.valueOf("/rss/channel/item/y:condition/@temp") );
    weather.setChill( doc.valueOf("/rss/channel/y:wind/@chill") );
    weather.setHumidity( doc.valueOf("/rss/channel/y:atmosphere/@humidity") );
  
    return weather;
  }

  private SAXReader createXmlReader() {
    Map&lt;String,String&gt; uris = new HashMap&lt;String,String&gt;();
        uris.put( "y", "http://xml.weather.yahoo.com/ns/rss/1.0" );
        
    DocumentFactory factory = new DocumentFactory();
    factory.setXPathNamespaceURIs( uris );
        
    SAXReader xmlReader = new SAXReader();
    xmlReader.setDocumentFactory( factory );
    return xmlReader;
  }
}
</programlisting>
    </example>

    <para><classname>YahooParser</classname> 是本例中最复杂的类，我们不会深入 Dom4J 或者 Jaxen
    的细节，但是这个类还是需要一些解释。<classname>YahooParser</classname> 的
    <methodname>parse()</methodname> 方法接受一个 <classname>InputStrem</classname>
    然后返回一个 <classname>Weather</classname> 对象。 为了完成这一目标，它需要用 Dom4J 来解析
    <acronym>XML</acronym> 文档。因为我们对 Yahoo! Weather <acronym>XML</acronym>
    命名空间的元素感兴趣，我们需要用 <methodname>createXmlReader()</methodname>
    方法创建一个包含命名空间信息的 <classname>SAXReader</classname> 。 一旦我们创建了这个 reader
    并且解析了文档，得到了返回的 <classname>org.dom4j.Document</classname> ，只需要简单的使用 XPath
    表达式来获取需要的信息，而不是遍历所有的子元素。 本例中 Dom4J 提供了 <acronym>XML</acronym> 解析功能，而 Jaxen
    提供了 XPath 功能。</para>

    <para>我们已经创建了 <classname>Weather</classname> 对象，我们需要格式化输出以供人阅读。
    在同一目录中创建一个名为 <filename>WeatherFormatter.java</filename> 的文件。</para>

    <example>
      <title>Simple Weather 的 WeatherFormatter 类</title>

      <programlisting language="java">package org.sonatype.mavenbook.weather;

import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StringWriter;

import org.apache.log4j.Logger;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.Velocity;

public class WeatherFormatter {

  private static Logger log = Logger.getLogger(WeatherFormatter.class);

  public String format( Weather weather ) throws Exception {
    log.info( "Formatting Weather Data" );
    Reader reader = 
      new InputStreamReader( getClass().getClassLoader()
                                 .getResourceAsStream("output.vm"));
    VelocityContext context = new VelocityContext();
    context.put("weather", weather );
    StringWriter writer = new StringWriter();
    Velocity.evaluate(context, writer, "", reader);
    return writer.toString();
  }
}
</programlisting>
    </example>

    <para><classname>WeatherFormatter</classname> 使用 Veloticy
    来呈现一个模板。<methodname>format()</methodname> 方法接受一个
    <classname>Weather</classname> bean 然后返回格式化好的
    <classname>String</classname> 。<methodname>format()</methodname>
    方法做的第一件事是从 classpath 载入名字为 <filename>output.vm</filename> 的 Velocity 模板。
    然后我们创建一个 <classname>VelocityContext</classname> ，它需要一个
    <classname>Weather</classname> 对象来填充。
    一个<classname>StringWriter</classname>被创建用来存放模板生成的结果数据。通过调用
    <methodname>Velocity.evaluate()</methodname> ，给模板赋值，结果作为 String 返回。</para>

    <para>在我们能够运行该样例程序之前，我们需要往 classpath 添加一些资源。</para>
  </section>

  <section>
    <title>添加资源</title>

    <para>本项目依赖于两个 classpath 资源： <classname>Main</classname> 类通过 classpath 资源
    <filename>log4j.preoperties</filename> 来配置 Log4J ，
    <classname>WeatherFormatter</classname> 引用了一个在 classpath 中的名为
    <filename>output.vm</filename> 的 Velocity 模板。这两个资源都需要在默认包中（或者 classpath
    的根目录）。</para>

    <para>为了添加这些资源，我们需要在项目的基础目录下创建一个新的目录——
    <filename>src/main/resources</filename>。 由于任务
    <varname>archetype:create</varname>
    没有创建这个目录，我们需要通过在项目的基础目录下运行下面的命令来创建它：</para>

    <screen>$ <command>cd src/main</command>
$ <command>mkdir resources</command>
$ <command>cd resources</command></screen>

    <para>在这个资源目录创建好之后，我们可以加入这两个资源。首先，往目录 <filename>resources</filename> 加入文件
    <filename>log4j.properties</filename>。</para>

    <example>
      <title>Simple Weather 的 Log4J 配置文件</title>

      <programlisting language="java"># Set root category priority to INFO and its only appender to CONSOLE.
log4j.rootCategory=INFO, CONSOLE

# CONSOLE is set to be a ConsoleAppender using a PatternLayout.
log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender
log4j.appender.CONSOLE.Threshold=INFO
log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout
log4j.appender.CONSOLE.layout.ConversionPattern=%-4r %-5p %c{1} %x - %m%n</programlisting>
    </example>

    <para>这个 <filename>log4j.properties</filename> 文件简单配置了 Log4J ，使其使用
    <classname>PatternLayout</classname> 往标准输出打印所有日志信息。 最后，我们需要创建
    <filename>output.vm</filename> ，它是这个命令行程序用来呈现输出的 Velocity 模板。 在
    <filename>resources</filename> 目录创建 <filename>output.vm</filename>
    。</para>

    <example>
      <title>Simple Weather 的 Output Velocity 模板</title>

      <programlisting>*********************************
 Current Weather Conditions for:
  ${weather.city}, ${weather.region}, ${weather.country}
  
 Temperature: ${weather.temp}
   Condition: ${weather.condition}
    Humidity: ${weather.humidity}
  Wind Chill: ${weather.chill}
*********************************
</programlisting>

      <para>这个模板包含了许多对名为 <varname>weather</varname> 的变量的引用。 这个
      <varname>weather</varname> 变量是传给 <classname>WeatherFormatter</classname>
      的 那个 <classname>Weather</classname> bean，
      <varname>${weather.temp}</varname> 语法简化的表示获取并显示 <varname>temp</varname>
      这个bean属性的值。 现在我们已经在正确的地方有了我们项目的所有代码，我们可以使用 Maven 来运行这个样例。</para>
    </example>
  </section>

  <section>
    <title>运行Simple Weather项目</title>

    <para>使用来自 <ulink url="http://mojo.codehaus.org">Codehaus Mojo 项目</ulink>
    的 Exec 插件，我们可以运行这个程序。在项目的基础目录下运行以下命令，以运行该程序的 <classname>Main</classname>
    类。</para>

    <screen>$ <command>mvn install</command>
$ <command>mvn exec:java -Dexec.mainClass=org.sonatype.mavenbook.weather.Main</command>
...
[INFO] [exec:java]
0    INFO  YahooRetriever  - Retrieving Weather Data
134  INFO  YahooParser  - Creating XML Reader
333  INFO  YahooParser  - Parsing XML Response
420  INFO  WeatherFormatter  - Formatting Weather Data
*********************************
 Current Weather Conditions for:
  Evanston, IL, US
  
 Temperature: 45
   Condition: Cloudy
    Humidity: 76
  Wind Chill: 38
*********************************
...</screen>

    <para>我们没有为 <classname>Main</classname> 类提供命令行参数，因此程序按照默认的邮编执行——60202。
    正如你能看到的，我们已经成功的运行了 SImple Weather 命令行工具，从 Yahoo! Weather
    获取了一些数据，解析了结果，并且通过 Velocity 格式化了结果数据。 我们仅仅写了项目的源代码，往
    <filename>pom.xml</filename> 添加了一些最少的配置。 注意我们这里没有引入“构建过程”。 我们不需要定义如何或哪里让
    Java 编译器编译我们的源代码，我们不需要指导构建系统在运行样例程序的时候如何定位二进制文件， 我们所需要做的是包含一些依赖，用来定位合适的
    Maven 坐标。</para>

    <section>
      <title>Maven Exec 插件</title>

      <para>Exec 插件允许你运行 Java 类和其它脚本。 它不是 Maven 核心插件，但它可以从 <ulink
      url="http://www.codehaus.org">Codehaus</ulink> 的 <ulink
      url="http://mojo.codehaus.org">Mojo</ulink> 项目得到。想要查看 Exec
      插件的完整描述，运行：</para>

      <screen>$ <command>mvn help:describe -Dplugin=exec -Dfull</command></screen>

      <para>这会列出所有 Maven Exec 插件可用的目标。 Help 插件同时也会列出 Exec 插件的有效参数，如果你想要定制 Exec
      插件的行为，传入命令行参数，你应该使用 <varname>help:describe</varname> 提供的文档作为指南。 虽然 Exec
      插件很有用，在开发过程中用来运行测试之外，你不应该依赖它来运行你的应用程序。 想要更健壮的解决方案，使用 Maven Assembly
      插件，它在<xref linkend="section-custom-packaged" />中被描述。</para>
    </section>

    <section>
      <title>浏览你的项目依赖</title>

      <para>Exec 插件让我们能够在不往 classpath 载入适当的依赖的情况下，运行这个程序。
      在任何其它的构建系统能够中，我们必须复制所有程序依赖到类似于 <filename>lib/</filename> 的目录，这个目录包含一个
      <acronym>JAR</acronym> 文件的集合。 那样，我们就必须写一个简单的脚本，在 classpath
      中包含我们程序的二进制代码和我们的依赖。 只有那样我们才能运行 <command>java
      org.sonatype.mavenbook.weather.Main</command> 。 Exec 能做这样的工作是因为 Maven
      已经知道如何创建和管理你的 classpath 和你的依赖。</para>

      <para>了解你项目的 classpath 包含了哪些依赖是很方便也很有用的。这个项目不仅包含了一些类库如 Dom4J， Log4J，
      Jaxen， 和 Velocity，它同时也引入了一些传递性依赖。 如果你需要找出 classpath 中有什么，你可以使用 Maven
      Dependency 插件来打印出已解决依赖的列表。 要打印出 Simple Weather 项目的这个列表，运行
      <varname>dependency:resolve</varname> 目标。</para>

      <screen>$ <command>mvn dependency:resolve</command>
...
[INFO] [dependency:resolve]
[INFO] 
[INFO] The following files have been resolved: 
[INFO]    com.ibm.icu:icu4j:jar:2.6.1 (scope = compile)
[INFO]    commons-collections:commons-collections:jar:3.1 (scope = compile)
[INFO]    commons-lang:commons-lang:jar:2.1 (scope = compile)
[INFO]    dom4j:dom4j:jar:1.6.1 (scope = compile)
[INFO]    jaxen:jaxen:jar:1.1.1 (scope = compile)
[INFO]    jdom:jdom:jar:1.0 (scope = compile)
[INFO]    junit:junit:jar:3.8.1 (scope = test)
[INFO]    log4j:log4j:jar:1.2.14 (scope = compile)
[INFO]    oro:oro:jar:2.0.8 (scope = compile)
[INFO]    velocity:velocity:jar:1.5 (scope = compile)
[INFO]    xalan:xalan:jar:2.6.0 (scope = compile)
[INFO]    xerces:xercesImpl:jar:2.6.2 (scope = compile)
[INFO]    xerces:xmlParserAPIs:jar:2.6.2 (scope = compile)
[INFO]    xml-apis:xml-apis:jar:1.0.b2 (scope = compile)
[INFO]    xom:xom:jar:1.0 (scope = compile)
</screen>

      <para>正如你能看到的，我们项目拥有一个很大的依赖集合。 虽然我们只是为四个类库引入了直接的依赖，看来我们实际共引入了15个依赖。
      Dom4J 依赖于 Xerces 和 XML 解析器 API ，Jaxen 依赖于 Xalan，后者也就在 classpath 中可用了。
      Dependency 插件将会打印出最终的你项目编译所基于的所有依赖的组合。 如果你想知道你项目的整个依赖树，你可以运行
      <varname>dependency:tree</varname> 目标。</para>

      <screen>$ <command>mvn dependency:tree</command>
...
[INFO] [dependency:tree]
[INFO] org.sonatype.mavenbook.ch04:simple-weather:jar:1.0
[INFO] +- log4j:log4j:jar:1.2.14:compile
[INFO] +- dom4j:dom4j:jar:1.6.1:compile
[INFO] |  \- xml-apis:xml-apis:jar:1.0.b2:compile
[INFO] +- jaxen:jaxen:jar:1.1.1:compile
[INFO] |  +- jdom:jdom:jar:1.0:compile
[INFO] |  +- xerces:xercesImpl:jar:2.6.2:compile
[INFO] |  \- xom:xom:jar:1.0:compile
[INFO] |     +- xerces:xmlParserAPIs:jar:2.6.2:compile
[INFO] |     +- xalan:xalan:jar:2.6.0:compile
[INFO] |     \- com.ibm.icu:icu4j:jar:2.6.1:compile
[INFO] +- velocity:velocity:jar:1.5:compile
[INFO] |  +- commons-collections:commons-collections:jar:3.1:compile
[INFO] |  +- commons-lang:commons-lang:jar:2.1:compile
[INFO] |  \- oro:oro:jar:2.0.8:compile
[INFO] +- org.apache.commons:commons-io:jar:1.3.2:test
[INFO] \- junit:junit:jar:3.8.1:test
...</screen>

      <para>如果你还不满足，或者想要查看完整的依赖踪迹，包含那些因为冲突或者其它原因而被拒绝引入的构件，打开 Maven
      的调试标记运行：</para>

      <screen>$ <command>mvn install -X</command>
...
[DEBUG] org.sonatype.mavenbook.ch04:simple-weather:jar:1.0 (selected for null)
[DEBUG]   log4j:log4j:jar:1.2.14:compile (selected for compile)
[DEBUG]   dom4j:dom4j:jar:1.6.1:compile (selected for compile)
[DEBUG]     xml-apis:xml-apis:jar:1.0.b2:compile (selected for compile)
[DEBUG]   jaxen:jaxen:jar:1.1.1:compile (selected for compile)
[DEBUG]     jaxen:jaxen:jar:1.1-beta-6:compile (removed - causes a cycle in the graph)
[DEBUG]     jaxen:jaxen:jar:1.0-FCS:compile (removed - causes a cycle in the graph)
[DEBUG]     jdom:jdom:jar:1.0:compile (selected for compile)
[DEBUG]     xml-apis:xml-apis:jar:1.3.02:compile (removed - nearer found: 1.0.b2)
[DEBUG]     xerces:xercesImpl:jar:2.6.2:compile (selected for compile)
[DEBUG]     xom:xom:jar:1.0:compile (selected for compile)
[DEBUG]       xerces:xmlParserAPIs:jar:2.6.2:compile (selected for compile)
[DEBUG]       xalan:xalan:jar:2.6.0:compile (selected for compile)
[DEBUG]       xml-apis:xml-apis:1.0.b2.
[DEBUG]       com.ibm.icu:icu4j:jar:2.6.1:compile (selected for compile)
[DEBUG]   velocity:velocity:jar:1.5:compile (selected for compile)
[DEBUG]     commons-collections:commons-collections:jar:3.1:compile (selected for compile)
[DEBUG]     commons-lang:commons-lang:jar:2.1:compile (selected for compile)
[DEBUG]     oro:oro:jar:2.0.8:compile (selected for compile)
[DEBUG]   junit:junit:jar:3.8.1:test (selected for test)
</screen>

      <para>从调试输出我们看到一些依赖管理系统工作的内部信息。 你在这里看到的是项目的依赖树。 Maven
      正打印出你项目的所有的依赖，以及这些依赖的依赖（还有依赖的依赖的依赖）的完整的 Maven 坐标。 你能看到
      <varname>simple-weather</varname> 依赖于 <varname>jaxen</varname> ，
      <varname>jaxen</varname> 依赖于 <varname>xom</varname> ，
      <varname>xom</varname> 接着依赖于 <varname>icu4j</varname> 。从该输出你能看到 Maven
      正在创建一个依赖图，排除重复，解决不同版本之间的冲突。 如果你的依赖有问题，通常在
      <varname>dependency:tree</varname> 所生成的列表基础上更深入一点会有帮助；开启调试输出允许你看到 Maven
      工作时的依赖机制。</para>
    </section>
  </section>

  <section>
    <title>编写单元测试</title>

    <para>Maven 内建了对单元测试的支持，测试是 Maven 默认生命周期的一部分。让我们给 Simple Weather
    项目添加一些单元测试。 首先，在 <filename>src/test/java</filename> 下面创建包
    <package>org.sonatype.mavenbook.weather</package>。</para>

    <screen>$ <command>cd src/test/java</command>
$ <command>cd org/sonatype/mavenbook</command>
$ <command>mkdir -p weather/yahoo</command>
$ <command>cd weather/yahoo</command></screen>

    <para>目前，我们将会创建两个单元测试。 第一个单元测试会测试 <classname>YahooParser</classname>
    ，第二个会测试 <classname>WeatherFormatter</classname>。 在 weather
    包中，创建一个带有一以下内容的文件，名称为 <filename>YahooParserTest.java</filename> 。</para>

    <example>
      <title>Simple Weather 的 YahooParserTest 单元测试</title>

      <programlisting language="java">package org.sonatype.mavenbook.weather.yahoo;

import java.io.InputStream;

import junit.framework.TestCase;

import org.sonatype.mavenbook.weather.Weather;
import org.sonatype.mavenbook.weather.YahooParser;

public class YahooParserTest extends TestCase {

  public YahooParserTest(String name) {
    super(name);
  }
 
  public void testParser() throws Exception {
    InputStream nyData = 
      getClass().getClassLoader().getResourceAsStream("ny-weather.xml");
    Weather weather = new YahooParser().parse( nyData );
    assertEquals( "New York", weather.getCity() );
    assertEquals( "NY", weather.getRegion() );
    assertEquals( "US", weather.getCountry() );
    assertEquals( "39", weather.getTemp() );
    assertEquals( "Fair", weather.getCondition() );
    assertEquals( "39", weather.getChill() );
    assertEquals( "67", weather.getHumidity() );
  }
}
</programlisting>
    </example>

    <para><classname>YahooParserTest</classname> 继承了 JUnit 定义的
    <classname>TestCase</classname> 类。 它遵循了 JUnit 测试的惯例模式：一个构造函数接受一个单独的
    <classname>String</classname> 参数并调用父类的构造函数，还有一系列以“test”开头的公有方法，做为单元测试被调用。
    我们定义了一个单独的测试方法， <methodname>testParser</methodname> ，通过解析一个值已知的
    <acronym>XML</acronym> 文档来测试 <classname>YahooParser</classname> 。 测试
    <acronym>XML</acronym> 文档命名为 <filename>ny-weather.xml</filename> ，从
    classpath 载入。我们将在<xref linkend="sect-custom-test-resource" />添加测试资源。 在我们这个
    Maven 项目的目录布局中，文件 <filename>ny-weather.xml</filename> 可以从包含测试资源的目录——
    <filename>${basedir}/src/test/resources</filename> ——中找到，路径为
    <filename>org/sonatype/mavenbook/weather/yahoo/ny-weather.xml</filename> 。
    该文件作为一个 <classname>InputStream</classname> 被读入，传给
    <classname>YahooParser</classname> 的 <methodname>parse()</methodname> 方法。
    <methodname>parse()</methodname> 方法返回一个 <classname>Weather</classname>
    对象，该对象通过一系列 由 <classname>TestCase</classname> 定义的
    <methodname>assertEquals()</methodname> 调用而被测试。</para>

    <para>在同一目录下创建一个名为 <filename>WeatherFormatterTest.java</filename>
    的文件。</para>

    <example>
      <title>Simple Weather 的 WeatherFormatterTest 单元测试</title>

      <programlisting language="java">package org.sonatype.mavenbook.weather.yahoo;

import java.io.InputStream;

import org.apache.commons.io.IOUtils;

import org.sonatype.mavenbook.weather.Weather;
import org.sonatype.mavenbook.weather.WeatherFormatter;
import org.sonatype.mavenbook.weather.YahooParser;

import junit.framework.TestCase;

public class WeatherFormatterTest extends TestCase {

  public WeatherFormatterTest(String name) {
    super(name);
  }

  public void testFormat() throws Exception {
    InputStream nyData = 
      getClass().getClassLoader().getResourceAsStream("ny-weather.xml");
    Weather weather = new YahooParser().parse( nyData );
    String formattedResult = new WeatherFormatter().format( weather );
    InputStream expected = 
      getClass().getClassLoader().getResourceAsStream("format-expected.dat");
    assertEquals( IOUtils.toString( expected ).trim(), formattedResult.trim() );
  }
}
</programlisting>
    </example>

    <para>该项目中的第二个单元测试测试 <classname>WeatherFormatter</classname>。 和
    <classname>YahooParserTest</classname>
    一样，<classname>WeatherFormatter</classname> 同样也继承 JUnit 的
    <classname>TestCase</classname> 类。 这个单独的测试通过单元测试的 classpath 从
    <filename>${basedir}/src/test/resources</filename> 的
    <filename>org/sonatype/mavenbook/weather/yahoo</filename> 目录读取同样的测试资源文件。
    我们将会在<xref linkend="sect-custom-test-resource" />添加测试资源。
    <classname>WeatherFormatterTest</classname> 首先调用
    <classname>YahooParser</classname> 解析出 <classname>Weather</classname>
    对象，然后用 <classname>WeatherFormatter</classname> 格式化这个对象。 我们的期望输出被存储在一个名为
    <filename>format-expected.dat</filename> 的文件中，该文件存放在和
    <filename>ny-weather.xml</filename> 同样的目录中。 要比较测试输出和期望输出，我们将期望输出作为
    <classname>InputStream</classname> 读入，然后使用 Commons IO 的
    <classname>IOUtils</classname> 类来把文件转化为 <classname>String</classname> 。
    然后使用 <methodname>assertEquals()</methodname> 比较这个 String 和测试输出。</para>
  </section>

  <section>
    <title>添加测试范围依赖</title>

    <para>在类 <classname>WeatherFormatterTest</classname> 中我们用了一个来自于 Apache
    Commons IO 的工具—— <classname>IOUtils</classname> 类。
    <classname>IOUtils</classname> 提供了许多很有帮助的静态方法，能帮助让很多工作摆脱繁琐的 I/O
    操作。在这个单元测试中我们使用了 <methodname>IOUtils.toString()</methodname> 来复制 classpath
    中资源 <filename>format.expected.dat</filename> 中的数据至
    <classname>String</classname>。 不用 Commons IO 我们也能完成这件事情，但是那需要额外的六七行代码来处理像
    <classname>InputStreamReader</classname> 和
    <classname>StringWriter</classname> 这样的对象。我们使用 Commons IO 的主要原因是，能有理由添加对
    Commons IO 的测试范围依赖。</para>

    <para>测试范围依赖是一个只在测试编译和测试运行时在 classpath 中有效的依赖。如果你的项目是以
    <varname>war</varname> 或者 <varname>ear</varname>
    形式打包的，测试范围依赖就不会被包含在项目的打包输出中。 要添加一个测试范围依赖，在你项目的
    <varname>dependencies</varname> 小节中添加如下 <varname>dependency</varname>
    元素。</para>

    <example>
      <title>添加一个测试范围依赖</title>

      <programlisting language="xml">&lt;project&gt;
  ...
  &lt;dependencies&gt;
    ...
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
      &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
      &lt;version&gt;1.3.2&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    ...
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting>
    </example>

    <para>当你往 <filename>pom.xml</filename> 中添加了这个依赖以后，运行 <command>mvn
    dependency:resolve</command> 你会看到 <varname>commons-io</varname>
    出现在在依赖列表中，范围是 <varname>test</varname> 。 在我们可以运行该项目的单元测试之前，我们还需要做一件事情。
    那就是创建单元测试依赖的 classpath 资源。测试范围依赖将在 9.4.1节 “依赖范围” 中详细解释。</para>
  </section>

  <section id="sect-custom-test-resource">
    <title>添加单元测试资源</title>

    <para>一个单元测试需要访问针对测试的一组资源。 通常你需要在测试 classpath 中存储一些包含期望结果的文件，以及包含模拟输入的文件。
    在本项目中，我们为 <classname>YahooParserTest</classname> 准备了一个名为
    <filename>ny-weather.xml</filename> 的测试 <acronym>XML</acronym> 文档，还有一个名为
    <filename>format-expected.dat</filename> 的文件，包含了
    <classname>WeatherFormatter</classname> 的期望输出。</para>

    <para>要添加测试资源，你需要创建目录 <filename>src/test/resources</filename> 。 这是 Maven
    寻找测试资源的默认目录。 在你的项目基础目录下运行下面的命令以创建该目录。</para>

    <screen>$ <command>cd src/test</command>
$ <command>mkdir resources</command>
$ <command>cd resources</command></screen>

    <para>当你创建好这个资源目录之后，在资源目录下创建一个名为 <filename>format-expected.dat</filename>
    的文件。</para>

    <example>
      <title>Simple Weather 的 WeatherFormatterTest 期望输出</title>

      <programlisting>*********************************
 Current Weather Conditions for:
  New York, NY, US
  
 Temperature: 39
   Condition: Fair
    Humidity: 67
  Wind Chill: 39
*********************************
</programlisting>
    </example>

    <para>这个文件应该看起来很熟悉了，它和你用 Maven Exec 插件运行 Simple Weather
    项目得到的输出是一样的。你需要在资源目录添加的第二个文件是 <filename>ny-weather.xml</filename> 。</para>

    <example>
      <title>Simple Weather 的 YahooParserTest XML 输入</title>

      <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes" ?&gt;
&lt;rss version="2.0" xmlns:yweather="http://xml.weather.yahoo.com/ns/rss/1.0" 
     xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#"&gt;
 &lt;channel&gt;
 &lt;title&gt;Yahoo! Weather - New York, NY&lt;/title&gt;
 &lt;link&gt;http://us.rd.yahoo.com/dailynews/rss/weather/New_York__NY/&lt;/link&gt;
 &lt;description&gt;Yahoo! Weather for New York, NY&lt;/description&gt;
 &lt;language&gt;en-us&lt;/language&gt;
 &lt;lastBuildDate&gt;Sat, 10 Nov 2007 8:51 pm EDT&lt;/lastBuildDate&gt;

 &lt;ttl&gt;60&lt;/ttl&gt;
 &lt;yweather:location city="New York" region="NY" country="US" /&gt;
 &lt;yweather:units temperature="F" distance="mi" pressure="in" speed="mph" /&gt;
 &lt;yweather:wind chill="39" direction="0" speed="0" /&gt;
 &lt;yweather:atmosphere humidity="67" visibility="1609" pressure="30.18" 
                      rising="1" /&gt;
  &lt;yweather:astronomy sunrise="6:36 am" sunset="4:43 pm" /&gt;
  &lt;image&gt;
 &lt;title&gt;Yahoo! Weather&lt;/title&gt;

 &lt;width&gt;142&lt;/width&gt;
 &lt;height&gt;18&lt;/height&gt;
 &lt;link&gt;http://weather.yahoo.com/&lt;/link&gt;
 &lt;url&gt;http://l.yimg.com/us.yimg.com/i/us/nws/th/main_142b.gif&lt;/url&gt;
 &lt;/image&gt;
 &lt;item&gt;
 &lt;title&gt;Conditions for New York, NY at 8:51 pm EDT&lt;/title&gt;

  &lt;geo:lat&gt;40.67&lt;/geo:lat&gt;
 &lt;geo:long&gt;-73.94&lt;/geo:long&gt;
  &lt;link&gt;http://us.rd.yahoo.com/dailynews/rss/weather/New_York__NY/\&lt;/link&gt;
 &lt;pubDate&gt;Sat, 10 Nov 2007 8:51 pm EDT&lt;/pubDate&gt;
 &lt;yweather:condition text="Fair" code="33" temp="39" 
                     date="Sat, 10 Nov 2007 8:51 pm EDT" /&gt;
 &lt;description&gt;&lt;![CDATA[
&lt;img src="http://l.yimg.com/us.yimg.com/i/us/we/52/33.gif" /&gt;&lt;br /&gt;
 &lt;b&gt;Current Conditions:&lt;/b&gt;&lt;br /&gt;
 Fair, 39 F&lt;BR /&gt;&lt;BR /&gt;
 &lt;b&gt;Forecast:&lt;/b&gt;&lt;BR /&gt;
  Sat - Partly Cloudy. High: 45 Low: 32&lt;br /&gt;
  Sun - Sunny. High: 50 Low: 38&lt;br /&gt;
 &lt;br /&gt;
 ]]&gt;&lt;/description&gt;
 &lt;yweather:forecast day="Sat" date="10 Nov 2007" low="32" high="45" 
                    text="Partly Cloudy" code="29" /&gt;

&lt;yweather:forecast day="Sun" date="11 Nov 2007" low="38" high="50" 
                   text="Sunny" code="32" /&gt;
  &lt;guid isPermaLink="false"&gt;10002_2007_11_10_20_51_EDT&lt;/guid&gt;
 &lt;/item&gt;
&lt;/channel&gt;
&lt;/rss&gt;</programlisting>
    </example>

    <para>该文件包含了一个给 <classname>YahooParserTest</classname> 用的
    <acronym>XML</acronym> 文档。有了这个文件，我们不用从 Yahoo! Weather 获取
    <acronym>XML</acronym> 响应就能测试 <classname>YahooParser</classname> 了。</para>
  </section>

  <section id="section-custom-exec">
    <title>执行单元测试</title>

    <para>既然你的项目已经有单元测试了，那么让它们运行起来吧。 你不必为了运行单元测试做什么特殊的事情，
    <varname>test</varname> 阶段是 Maven 生命周期中常规的一部分。 当你运行 <command>mvn
    package</command> 或者 <command>mvn install</command> 的时候你也运行了测试。 如果你想要运行到
    <varname>test</varname> 阶段为止的所有生命周期阶段，运行 <command>mvn test</command>
    。</para>

    <screen>$ <command>mvn test</command>
...
[INFO] [surefire:test]
[INFO] Surefire report directory: ~/examples/simple-weather/target/surefire-reports

-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running org.sonatype.mavenbook.weather.yahoo.WeatherFormatterTest
0    INFO  YahooParser  - Creating XML Reader
177  INFO  YahooParser  - Parsing XML Response
239  INFO  WeatherFormatter  - Formatting Weather Data
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.547 sec
Running org.sonatype.mavenbook.weather.yahoo.YahooParserTest
475  INFO  YahooParser  - Creating XML Reader
483  INFO  YahooParser  - Parsing XML Response
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.018 sec

Results :

Tests run: 2, Failures: 0, Errors: 0, Skipped: 0
</screen>

    <para>从命令行运行 <command>mvn test</command> 使 Maven 执行到
    <literal>test</literal> 阶段为止的所有生命周期阶段。 Maven Surefire 插件有一个
    <literal>test</literal> 目标，该目标被绑定在了 <literal>test</literal> 阶段。
    <literal>test</literal> 目标执行项目中所有能在 <filename>src/test/java</filename>
    找到的并且文件名与 <filename>**/Test*.java</filename>，
    <filename>**/*Test.java</filename> 和
    <filename>**/*TestCase.java</filename> 匹配的所有单元测试。 在本例中，你能看到 Surefire 插件的
    <literal>test</literal> 目标执行了 <classname>WeatherFormatterTest</classname>
    和 <classname>YahooParserTest</classname> 。 在 Maven Surefire 插件执行 JUnit
    测试的时候，它同时也在 <filename>${basedir}/target/surefire-reports</filename> 目录下生成
    <acronym>XML</acronym> 和常规文本报告。
    如果你的测试失败了，你可以去查看这个目录，里面有你单元测试生成的异常堆栈信息和错误信息。</para>

    <section>
      <title>忽略测试失败</title>

      <para>通常，你会开发一个带有很多失败单元测试的系统。
      如果你正在实践测试驱动开发(<acronym>TDD</acronym>)，你可能会使用测试失败来衡量你离项目完成有多远。
      如果你有失败的单元测试，但你仍然希望产生构建输出，你就必须告诉 Maven 让它忽略测试失败。 当 Maven
      遇到一个测试失败，它默认的行为是停止当前的构建。 如果你希望继续构建项目，即使 Surefire 插件遇到了失败的单元测试，你就需要设置
      Surefire 的 <varname>testFailureIgnore</varname> 这个配置属性为
      <literal>true</literal>。</para>

      <example>
        <title>忽略单元测试失败</title>

        <programlisting language="xml">&lt;project&gt;
  [...]
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;testFailureIgnore&gt;true&lt;/testFailureIgnore&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
  [...]
&lt;/project&gt;</programlisting>
      </example>

      <para>该插件文档 (<ulink
      url="http://maven.apache.org/plugins/maven-surefire-plugin/test-mojo.html">http://maven.apache.org/plugins/maven-surefire-plugin/test-mojo.html</ulink>)
      说明，这个参数声明为一个表达式：</para>

      <example>
        <title>插件参数表达式</title>

        <programlisting>
       testFailureIgnore  Set this to true to ignore a failure during testing. Its use is NOT RECOMMENDED, but quite convenient on occasion.

    * Type: boolean
    * Required: No
    * Expression: ${maven.test.failure.ignore}
       </programlisting>
      </example>

      <para>这个表达式可以从命令行通过 <varname>-D</varname> 参数设置。</para>

      <screen>$ <command>mvn test -Dmaven.test.failure.ignore=true</command></screen>
    </section>

    <section>
      <title>跳过单元测试</title>

      <para>你可能想要配置 Maven 使其完全跳过单元测试。
      可能你有一个很大的系统，单元测试需要花好多分钟来完成，而你不想在生成最终输出前等单元测试完成。
      你可能正工作在一个遗留系统上面，这个系统有一系列的失败的单元测试，你可能仅仅想要生成一个 <acronym>JAR</acronym>
      而不是去修复所有的单元测试。 Maven 提供了跳过单元测试的能力，只需要使用 Surefire 插件的
      <varname>skip</varname> 参数。 在命令行，只要简单的给任何目标添加
      <varname>maven.test.skip</varname> 属性就能跳过测试：</para>

      <screen>$ mvn install -Dmaven.test.skip=true
...
[INFO] [compiler:testCompile]
[INFO] Not compiling test sources
[INFO] [surefire:test]
[INFO] Tests are skipped.
...</screen>

      <para>当 Surefire 插件到达 <varname>test</varname> 目标的时候，如果
      <varname>maven.test.skip</varname> 设置为 <literal>true</literal>
      ，它就会跳过单元测试。 另一种配置 Maven 跳过单元测试的方法是给你项目的 <filename>pom.xml</filename>
      添加这个配置。 你需要为你的 <sgmltag>build</sgmltag> 添加 <sgmltag>plugin</sgmltag>
      元素。</para>

      <example>
        <title>跳过单元测试</title>

        <programlisting language="xml">&lt;project&gt;
  [...]
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;skip&gt;true&lt;/skip&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
  [...]
&lt;/project&gt;</programlisting>
      </example>
    </section>
  </section>

  <section id="section-custom-packaged">
    <title>构建一个打包好的命令行应用程序</title>

    <para>在 <xref linkend="section-custom-exec" />，我们使用 Maven Exec 插件运行了
    Simple Weather 应用程序。虽然 Maven Exec 能运行程序并且产生输出，你不能就把 Maven 当成是你程序运行的容器。
    如果你把这个命令行程序分发给其他人，你大概就需要分发一个 <acronym>JAR</acronym> 或者一个
    <acronym>ZIP</acronym> 存档文件或者 <acronym>TAR</acronym> 压缩过的
    <acronym>GZIP</acronym> 文件。下面的小节介绍了使用 Maven Assembly 插件的预定义装配描述符生成一个可分发的
    <acronym>JAR</acronym> 文件的过程，该文件包含了项目的二进制文件和所有的依赖。</para>

    <para>Maven Assembly 插件是一个用来创建你应用程序特有分发包的插件。 你可以使用 Maven Assembly
    插件以你希望的任何形式来装配输出，只需定义一个自定义的装配描述符。 后面的章节我们会说明如何创建一个自定义装配描述符，为 Simple
    Weather 应用程序生成一个更复杂的存档文件。 本章我们将会使用预定义的
    <varname>jar-with-dependencies</varname> 格式。 要配置 Maven Assembly 插件， 我们需要在
    <filename>pom.xml</filename> 中的 build 配置中添加如下的 <sgmltag>plugin</sgmltag>
    配置。</para>

    <example>
      <title>配置 Maven 装配描述符</title>

      <programlisting language="xml">&lt;project&gt;
  [...]
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;descriptorRefs&gt;
            &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;
          &lt;/descriptorRefs&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
  [...]
&lt;/project&gt;</programlisting>
    </example>

    <para>添加好这些配置以后，你可以通过运行 <command>mvn assembly:assembly</command>
    来构建这个装配。</para>

    <screen>$ <command>mvn install assembly:assembly</command>
...
[INFO] [jar:jar]
[INFO] Building jar: ~/examples/simple-weather/target/simple-weather-1.0.jar
[INFO] [assembly:assembly]
[INFO] Processing DependencySet (output=)
[INFO] Expanding: \
       .m2/repository/dom4j/dom4j/1.6.1/dom4j-1.6.1.jar into \
       /tmp/archived-file-set.1437961776.tmp
[INFO] Expanding: .m2/repository/commons-lang/commons-lang/2.1/commons-lang-2.1.jar \
       into /tmp/archived-file-set.305257225.tmp
... (Maven Expands all dependencies into a temporary directory) ...
[INFO] Building jar: \
       ~/examples/simple-weather/target/simple-weather-1.0-jar-with-dependencies.jar
</screen>

    <para>在
    <filename>target/simple-weather-1.0-jar-with-dependencies.jar</filename>
    装配好之后， 我们可以在命令行重新运行 <classname>Main</classname> 类。在你项目的基础目录下运行以下命令：</para>

    <screen>$ <command>cd target</command>
$ <command>java -cp simple-weather-1.0-jar-with-dependencies.jar org.sonatype.mavenbook.weather.Main 10002</command>
0    INFO  YahooRetriever  - Retrieving Weather Data
221  INFO  YahooParser  - Creating XML Reader
399  INFO  YahooParser  - Parsing XML Response
474  INFO  WeatherFormatter  - Formatting Weather Data
*********************************
 Current Weather Conditions for:
  New York, NY, US
  
 Temperature: 44
   Condition: Fair
    Humidity: 40
  Wind Chill: 40
*********************************</screen>

    <para><varname>jar-with-dependencies</varname> 格式创建一个包含所有 simple-weather
    项目的二进制代码以及所有依赖解压出来的二进制代码的 <acronym>JAR</acronym> 文件。 这个略微非常规的格式产生了一个 9 MiB
    大小的 <acronym>JAR</acronym> 文件，包含了大概 5290 个类。 但是它确实给那些使用 Maven
    开发的应用程序提供了一个易于分发的格式。本书的后面，我们会说明如何创建一个自定义的装配描述符来生成一个更标准的分发包。</para>
  </section>
</chapter>
