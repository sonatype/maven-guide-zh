<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="multimodule-web-spring">
  <title>多模块企业级项目</title>

  <section id="multimodule-web-spring-intro">
    <title>简介</title>

    <para>本章，我们创建一个多模块项目，它<indexterm class="startofrange" id="enterprise1a">
        <primary>multimodule project (example)</primary>

        <secondary>multimodule enterprise project</secondary>
      </indexterm><indexterm class="startofrange" id="enterprise1b">
        <primary>Web applications</primary>

        <secondary>multimodule enterprise project example</secondary>
      </indexterm><indexterm class="startofrange" id="enterprise1c">
        <primary>enterprise project, multimodule (example)</primary>
      </indexterm>从<xref linkend="multimodule" />和<xref
    linkend="web" />的样例演化成一个使用了Spring Framework和Hibernate创建的，从Yahoo!
    Weather信息源读取数据，包含一个简单web应用和一个命令行工具的项目。<xref
    linkend="customizing" />中开发的<varname>simple-weather</varname>代码将会和<xref
    linkend="web" />中开发的<varname>simple-weather</varname>项目结合。在创建这个多模块项目的过程中，我们将会探索Maven并且讨论用不同方式来创建模块化项目以鼓励重用。</para>

    <section>
      <title>下载本章样例</title>

      <para>该样例中开发的多模块项目包含了<xref linkend="customizing" />和<xref
      linkend="web" />中项目的修改的版本，我们不会再使用Maven
      Archetype插件来生成这个多模块项目。我们强烈建议当你在阅读本章内容的时候，下载样例代码作为一个补充参考。本章的样例项目包含在本书的样例代码中，你可以从两个地方下载，<ulink
      url="http://www.sonatype.com/book/mvn-examples-1.0.zip">http://www.sonatype.com/book/mvn-examples-1.0.zip</ulink>或者<ulink
      url="http://www.sonatype.com/book/mvn-examples-1.0.tar.gz">http://www.sonatype.com/book/mvn-examples-1.0.tar.gz</ulink>。解开存档文件至任意目录，然后到<filename>ch07/</filename>目录。在<filename>ch07/</filename>目录你会看到一个名为<filename>simple-parent/</filename>的目录，它包含了本章开发出来的多模块Maven项目。在这个<filename>simple-parent/</filename>项目目录中，你会看到一个<filename>pom.xml</filename>，以及五个子模块目录<filename>simple-model/</filename>，<filename>simple-persist/</filename>，<filename>simple-command/</filename>，<filename>simple-weather/</filename>和<filename>simple-webapp/</filename>。如果你想要在浏览器里看样例代码，访问<ulink
      url="http://www.sonatype.com/book/examples-1.0">http://www.sonatype.com/book/examples-1.0</ulink>，然后点击<filename>ch07/</filename>目录。</para>
    </section>

    <section>
      <title>多模块企业级项目</title>

      <para>展示一个巨大企业级项目的复杂度远远超出了本书的范围。这样的项目的特征有，多数据库，与外部系统的集成，子项目通过部门来划分。这些项目通常跨越了数千行代码，牵涉了数十或数百软件开发者的努力。虽然这样的完整样例超出了本书的范围，我们仍然可以为你提供一个能让你想起大型企业应用的样例项目。在小结中我们提议了一些在本章描述之外的模块化可能性。</para>

      <para>本章，我们将会看一个多模块Maven项目，它将产生两个应用程序：一个对于Yahoo!
      Weather信息源的命令行查询工具，以及查询同样信息源的一个web应用。两个应用都会将查询结果存储到一个内嵌数据库中。都允许用户从内嵌数据库中获取历史天气数据。都会重用应用程序逻辑，并且共享一个持久化类库。本章样例基于在<xref
      linkend="customizing" />中介绍的Yahoo! Weather解析代码构建。该项目被划分成如<xref
      linkend="fig-multimodule-web-spring-projects" />所示的五个子项目。</para>

      <figure id="fig-multimodule-web-spring-projects">
        <title>多模块企业级应用的模块关系</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="figs/web/multimodule-web-spring_projects.png"
                       scalefit="1" width="8in" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>在<xref
      linkend="fig-multimodule-web-spring-projects" />中，你能看到simple-parent有五个子模块，它们分别是：</para>

      <variablelist>
        <varlistentry>
          <term>simple-model</term>

          <listitem>
            <para>该模块定义了一个简单的对象模型，对从Yashoo!
            Weather信息源返回的数据建模。该对象模型包含了<classname>Weather</classname>，<classname>Condition</classname>，<classname>Atmosphere</classname>，<classname>Location</classname>，和<classname>Wind</classname>对象。当我们的应用程序解析Yahoo!
            Weather信息源的时候，<varname>simple-weather</varname>中定义的解析器会解析<acronym>XML</acronym>并创建供应用程序使用的<classname>Weather</classname>对象。该项目还包含了使用Hibernate
            3标注符标注的模型对象，它们在<varname>simple-persist</varname>的逻辑中被用来映射每个模型对象至关系数据库中对应的表。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>simple-weather</term>

          <listitem>
            <para>该模块包含了所有用来从Yahoo!
            Weather数据源获取数据并解析结果<acronym>XML</acronym>的逻辑。从数据源返回的<acronym>XML</acronym>被转换成<varname>simple-model</varname>中定义的模型对象。<varname>simple-weather</varname>有一个对<varname>simple-model</varname>的依赖。<varname>simple-weather</varname>定义了一个<classname>WeatherService</classname>对象，该对象会被<varname>simple-command</varname>和<varname>simple-webapp</varname>项目引用。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>simple-persist</term>

          <listitem>
            <para>该模块包含了一些数据访问对象(<acronym>DAO</acronym>)，这些对象将<classname>Weather</classname>对象存储在一个内嵌数据库中。这个多模块项目中的两个应用都会使用<varname>simple-persist</varname>中定义的<acronym>DAO</acronym>来将数据存储至内嵌数据库中。本项目中定义的<acronym>DAO</acronym>能理解并返回<varname>simple-model</varname>定义的模型对象。<varname>simple-persist</varname>有一个对<varname>simple-model</varname>的依赖，它也依赖于模型对象上的Hibernate标注。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>simple-webapp</term>

          <listitem>
            <para>这个web应用项目包含了两个Spring
            <acronym>MVC</acronym>控制器实现，控制器使用了<varname>simple-weather</varname>中定义的<classname>WeatherService</classname>，以及<varname>simple-persist</varname>中定义的<acronym>DAO</acronym>。<varname>simple-webapp</varname>有对于<varname>simple-weather</varname>和<varname>simple-persist</varname>的直接依赖；还有一个对于<varname>simple-model</varname>的传递性依赖。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>simple-command</term>

          <listitem>
            <para>该模块包含了一个用来查询Yahoo!
            Weather信息源的简单命令行工具。它包含了一个带有静态<methodname>main()</methodname>方法的类，与<varname>simple-weather</varname>中定义的<classname>WeatherService</classname>和<varname>simple-persist</varname>中定义的<acronym>DAO</acronym>交互。<varname>simple-command</varname>有对于<varname>simple-weather</varname>和<varname>simple-persist</varname>的直接依赖；还有一个对于<varname>simple-model</varname>的传递性依赖。</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>本章设计的项目一方面够简单，以能在一本书中介绍，又够复杂，能提供一组五个子模块。该样例有一个带有五个类的模型项目，带有两个服务类的持久化类库，带有五六个类的天气解析类库，但是一个现实系统可能有一个带有数百对象的模型项目，很多持久化类库，以及跨越多个部门的服务类库。虽然我们试图确保本例中的代码尽可能的直接以能在短时间内理解，但我们也不怕麻烦的以模块化的方式构建了这个项目。你可能会要看一下本章的样例，然后会认为Maven为我们这个只有五个类的模型项目带来了太多的复杂度。虽然使用Maven确实建议一定程度的模块化，但这里我们不怕麻烦的将样例项目弄得复杂，目的是展示Maven的多模块特性。</para>
    </section>

    <section>
      <title>本例中所用的技术</title>

      <para>本章样例中涉及了一些十分流行，但与Maven没有直接关系的而技术。这些技术是Spring
      Framework和Hibernate。Spring
      Framework是一个反转控制(<acronym>IoC</acronym>)容器，以及一组目的在于简化与各种<acronym>J2EE</acronym>类库交互的框架。使用Spring
      Framework作为应用程序开发的基础框架能让你访问很多有用的抽象接口，它们能简化与持久化框架如Hibernate或者iBatis的交互，以及企业<acronym>API</acronym>如<acronym>JDBC</acronym>，<acronym>JNDI</acronym>，和<acronym>JMS</acronym>。Spring
      Framework在过去一些年变得十分流行，作为对来自Sun微系统的重量级企业标准的替代。Hibernate是一个被广泛使用的对象-关系映射框架，能让你与关系数据库的交互就像它们是Java对象的集合一样。本例关注构建一个简单的web应用和一个命令行应用，它们使用Spring
      Framework为应用暴露了一组可重用的组件，使用Hibernate将天气数据持久化至内嵌数据库。</para>

      <para>我们决定包含对这些框架的参考以展示在使用Maven的时候如何使用这些技术构建项目。虽然本章中我们会大概介绍这些技术，但不是完整的解释这些技术。要了解更多关于Spring
      Framework的信息，请查看该项目的web站点：<ulink
      url="http://www.springframework.org/">http://www.springframework.org/</ulink>。要了解更多关于Hibernate和Hibernate标注的信息，请查看该项目的web站点：<ulink
      url="http://www.hibernate.org">http://www.hibernate.org</ulink>。本章使用了<acronym>HSQLDB</acronym>作为一个内嵌数据库；要了解更多的关于该数据库的信息，访问该项目的web站点：<ulink
      url="http://hsqldb.org/">http://hsqldb.org/</ulink>。</para>
    </section>
  </section>

  <section>
    <title>simple-parent项目</title>

    <para><varname>该simple-parent项目有一个</varname><indexterm
        class="startofrange" id="enterprise2a">
        <primary>simple parent project (example)</primary>

        <secondary>multimodule enterprise</secondary>
      </indexterm><indexterm class="startofrange" id="enterprise2b">
        <primary>multimodule project (example)</primary>

        <secondary>multimodule enterprise project</secondary>

        <tertiary>simple parent project</tertiary>
      </indexterm><indexterm class="startofrange" id="enterprise2c">
        <primary>Web applications</primary>

        <secondary>multimodule enterprise project example</secondary>

        <tertiary>simple parent project</tertiary>
      </indexterm><indexterm class="startofrange" id="enterprise2d">
        <primary>enterprise project, multimodule (example)</primary>

        <secondary>simple parent project</secondary>
      </indexterm> <filename>pom.xml</filename>
    ，它引用了五个子模块：<varname>simple-command</varname>，<varname>simple-model</varname>，<varname>simple-weather</varname>，<varname>simple-persist</varname>，和<varname>simple-webapp</varname>。顶层的<filename>pom.xml</filename>在<xref
    linkend="ex-multimodule-web-spring-parent" />中显示。</para>

    <example id="ex-multimodule-web-spring-parent">
      <title>simple-parent 项目的 POM</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
  &lt;artifactId&gt;simple-parent&lt;/artifactId&gt;
  &lt;packaging&gt;pom&lt;/packaging&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;name&gt;Chapter 7 Simple Parent Project&lt;/name&gt;
 
  &lt;modules&gt;
    &lt;module&gt;simple-command&lt;/module&gt;
    &lt;module&gt;simple-model&lt;/module&gt;
    &lt;module&gt;simple-weather&lt;/module&gt;
    &lt;module&gt;simple-persist&lt;/module&gt;
    &lt;module&gt;simple-webapp&lt;/module&gt;
  &lt;/modules&gt;

  &lt;build&gt;
    &lt;pluginManagement&gt;
      &lt;plugins&gt;
        &lt;plugin&gt;
          &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
          &lt;configuration&gt;
            &lt;source&gt;1.5&lt;/source&gt;
            &lt;target&gt;1.5&lt;/target&gt;
          &lt;/configuration&gt;
        &lt;/plugin&gt;
      &lt;/plugins&gt;
   &lt;/pluginManagement&gt; 
  &lt;/build&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;

</programlisting>
    </example>

    <para>注意这个父<acronym>POM</acronym>和<xref
    linkend="ex-multimodule-parent-pom" />中定义的父<acronym>POM</acronym>的相似度。这两个<acronym>POM</acronym>唯一真正不同的地方是子模块列表。前面的样例中只列出了两个子模块，而这里的父<acronym>POM</acronym>列出了五个子模块。下面的小节会详细讨论所有这五个子模块。因为我们的样例使用了Java标注，我们将编译器的目标配置成Java
    5 <acronym>JVM</acronym>。</para>
  </section>

  <section>
    <title>simple-model模块</title>

    <para>大多数企业项目需要做的第一件事情是建立对象模型。一个对象模型抓取了系统中一组核心的领域对象。一个银行系统可能会有包括<classname>Account</classname>，<classname>Customer</classname>，<classname>Transaction</classname>
    的对象模型。或者有一个对体育比赛比分建模的系统，有一个<classname>Team</classname>和一个<classname>Game</classname>对象。不管它是什么，你都需要将你系统中的概念建模成对象模型。在Maven项目中，将这个对象模型分割成单独的项目以被广泛引用，是一种常用的实践。在我们这个系统中，我们将每个对Yahoo!
    Weather数据源的查询建模成为<classname>Weather</classname>对象，它本身又引用了四个其它的对象。风向，风速等存储<classname>Wind</classname>在对象中。地址信息包括邮编，城市等信息存储在<classname>Location</classname>类中。大气信息如湿度，可见度，气压等存储在<classname>Atmosphere</classname>类中。而对环境，气温，以及观察日期的文本描述存储在<classname>Condition</classname>类中。</para>

    <figure>
      <title>天气数据的简单对象模型</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="figs/web/multimodule-web-spring_object-model.png"
                     scalefit="1" width="5in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>这个简单对象模型的<filename>pom.xml</filename>文件含有一个依赖需要一些解释。我们的对象模型<indexterm>
        <primary>Hibernate annotations</primary>
      </indexterm><indexterm>
        <primary>annotations (Hibernate)</primary>
      </indexterm>用Hibernate标注符标注了。我们用这些标注来映射模型对象至关系数据库中的表。这个依赖是<varname>org.hibernate:hibernate-annotations:3.3.0.ga</varname>。看一下<xref
    linkend="example_simple-model_pom.xml" />中显示的<filename>pom.xml</filename>，然后看接下来几个展示这些标注的例子。</para>

    <example id="example_simple-model_pom.xml">
      <title>simple-model 的 pom.xml</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
    &lt;artifactId&gt;simple-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;simple-model&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;name&gt;Simple Object Model&lt;/name&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-annotations&lt;/artifactId&gt;
      &lt;version&gt;3.3.0.ga&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-commons-annotations&lt;/artifactId&gt;
      &lt;version&gt;3.3.0.ga&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</programlisting>

      <para>在<filename>src/main/java/org/sonatype/mavenbook/weather/model</filename>中，有<filename>Weather.java</filename>，它是一个标注过的<classname>Weather</classname>型对象。这个<classname>Weather</classname>对象是一个简单的Java
      bean。这意味着它的私有成员变量如<varname>id</varname>, <varname>location</varname>,
      <varname>condition</varname>, <varname>wind</varname>,
      <varname>atmosphere</varname>, 和
      <varname>date</varname>，通过公共的getter和setter方法暴露，并且遵循这样的模式：如果一个属性名为<literal>name</literal>，那么会有一个公有的无参数方法<methodname>getName()</methodname>，还有一个带有一个参数的setter方法<methodname
      role="keep-together">setName(String
      name)</methodname>。我们只是展示了<varname>id</varname>属性的getter和setter方法，其它属性的getter和setter方法类似，所以这里跳过了，以节省篇幅。请看<xref
      linkend="example_weather_model_object" />。</para>
    </example>

    <example id="example_weather_model_object">
      <title>标注的Weather模型对象</title>

      <programlisting language="java">package org.sonatype.mavenbook.weather.model;

import javax.persistence.*;

import java.util.Date;

@Entity
@NamedQueries({
  @NamedQuery(name="Weather.byLocation", 
              query="from Weather w where w.location = :location")
})
public class Weather {

    @Id
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    private Integer id;

    @ManyToOne(cascade=CascadeType.ALL)
    private Location location;

    @OneToOne(mappedBy="weather",cascade=CascadeType.ALL)
    private Condition condition;

    @OneToOne(mappedBy="weather",cascade=CascadeType.ALL)
    private Wind wind;

    @OneToOne(mappedBy="weather",cascade=CascadeType.ALL)
    private Atmosphere atmosphere;

    private Date date;
    
    public Weather() {}

    public Integer getId() { return id; }
    public void setId(Integer id) { this.id = id; }

    // All getter and setter methods omitted...
}
</programlisting>
    </example>

    <para>在<classname>Weather</classname>类中，我们使用Hibernate标注以为<varname>simple-persist</varname>项目提供指导。这些标注由Hibernate用来将对象与关系数据库映射。尽管对HIberante标注的完整解释超出了本书的范围，这里<indexterm>
        <primary sortas="Entity annotation (Hibernate)">@Entity annotation
        (Hibernate)</primary>
      </indexterm>是一个为好奇者的简单解释。<classname>@Entity</classname>标注标记一个类为持久化对象。我们省略了这个类的<indexterm>
        <primary sortas="Table annotation (Hibernate)">@Table annotation
        (Hibernate)</primary>
      </indexterm><classname>@Table</classname>标注，因此Hibernate将会使用这个类的名字来映射表名。<indexterm>
        <primary sortas="NamedQueries annotation (Hibernate)">@NamedQueries
        annotation (Hibernate)</primary>
      </indexterm><classname>@NamedQueries</classname>注解定义了一个<varname>simple-persist</varname>中<classname>WeatherDAO</classname>使用的查询。<indexterm>
        <primary sortas="NamedQuery annotation (Hibernate)">@NamedQuery
        annotation (Hibernate)</primary>
      </indexterm><classname>@NamedQuery</classname>注解中的查询语句是用一个叫做<indexterm>
        <primary>HQL (Hibernate Query Language)</primary>
      </indexterm>Hibernate查询语言(<acronym>HQL</acronym>)编写的。每个成员变量的注解定义了这一列的类型，以及该列暗示的表关联关系。</para>

    <variablelist>
      <varlistentry>
        <term role="plain"><varname>Id</varname></term>

        <listitem>
          <para><varname>id</varname>属性用<classname>@Id</classname>进行标注。这标记<varname>id</varname>属性为一个包含数据库表主键的属性。<classname>@GeneratedValue</classname>控制新的主键值如何产生。该例中，我们使用<varname>IDENTITY</varname>
          <classname>GenerationType</classname>，它使用了下层数据库的主键生成设施。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term role="plain"><varname>Location</varname></term>

        <listitem>
          <para>每个<classname>Weather</classname>对象实例对应了一个<classname>Location</classname>对象。一个<classname>Location</classname>对象含有一个邮政编码，而<classname>@ManyToOne</classname>确认所有指向同一个<classname>Location</classname>对象的<classname>Weather</classname>对象引用了同样一个实例。<classname>@ManyToOne</classname>的<varname>cascade</varname>属性确保每次我们持久化一个<classname>Weather</classname>对象的时候也会持久化一个<classname>Location</classname>对象。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term role="plain"><varname>Condition</varname>,
        <varname>Wind</varname>, <varname>Atmosphere</varname></term>

        <listitem>
          <para>这些对象的每一个都作为<classname>@OneToOne</classname>而且<classname>CascadeType</classname>为<varname>ALL</varname>进行映射。这意味着每次我们保存一个<classname>Weather</classname>对象，我们将会往<varname>Weather</varname>表，<varname>Condition</varname>表，<varname>Wind</varname>表，和<varname>Atmosphere</varname>表，插入一行，</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term role="plain"><varname>Date</varname></term>

        <listitem>
          <para><varname>Date</varname>没有被标注，这以为着Hibernate将会使用所有列的默认值来定义该映射。列名将会是<literal>date</literal>，列的类型会是匹配<classname>Date</classname>对象的适当时间。</para>

          <note>
            <para>如果你有一个希望从表映射中忽略的属性，你可以使用<classname>@Transient</classname>标注这个属性。</para>
          </note>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>接着，看一下一个二级的模型对象，<classname>Condition</classname>，如<xref
    linkend="example_condition_model_object" />所示。这个类同样也存在于<filename>src/main/java/org/sonatype/mavenbook/weather/model</filename>。</para>

    <example id="example_condition_model_object">
      <title>simple-model 的 Condition 模型对象</title>

      <programlisting language="java">package org.sonatype.mavenbook.weather.model;

import javax.persistence.*;

@Entity
public class Condition {

    @Id
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    private Integer id;

    private String text;
    private String code;
    private String temp;
    private String date;

    @OneToOne(cascade=CascadeType.ALL)
    @JoinColumn(name="weather_id", nullable=false)
    private Weather weather;

    public Condition() {}

    public Integer getId() { return id; }
    public void setId(Integer id) { this.id = id; }

    // All getter and setter methods omitted...
}</programlisting>
    </example>

    <para>这个<classname>Condition</classname>类类似于<classname>Weather</classname>类。它被标注为一个<classname>@Entity</classname>，在<varname>id</varname>属性上也有相似的标注。<varname>text</varname>，<varname>code</varname>，<varname>temp</varname>，和<varname>date</varname>属性也都使用默认的列设置，<varname>weather</varname>属性使用了<classname>@OneToOne</classname>进行标注，而另一个标注通过一个名为<varname>weather_id</varname>的外键引用关联的<classname>Weather</classname>对象。</para>
  </section>

  <section>
    <title>simple-weather模块</title>

    <para>我们将要检查的下一个模块可以被认为是一个<indexterm class="startofrange"
        id="enterprise4a">
        <primary>multimodule project (example)</primary>

        <secondary>multimodule enterprise project</secondary>

        <tertiary>Simple Weather module of</tertiary>
      </indexterm><indexterm class="startofrange" id="enterprise4b">
        <primary>Web applications</primary>

        <secondary>multimodule enterprise project example</secondary>

        <tertiary>Simple Weather module of</tertiary>
      </indexterm><indexterm class="startofrange" id="enterprise4c">
        <primary>enterprise project, multimodule (example)</primary>

        <secondary>Simple Weather module of</secondary>
      </indexterm>“服务”。这个simple-weather模块包含了所有从Yahoo! Weather
    <acronym>RSS</acronym>数据源获取数据并解析的必要逻辑。虽然simple-weather只包含了三个Java类和一个JUnit测试，它还将展现为一个单独的组件，<classname>WeatherService</classname>，同时为简单web应用和简单命令行工具服务。通常来说一个企业级项目会包含一些<acronym>API</acronym>模块，这写模块包含了重要的业务逻辑，或者与外部系统交互的逻辑。一个银行系统可能有一个模块，从第三方数据提供者获取并解析数据，而一个显示赛事比分的系统可能会与一个提供实时篮球或足球比分的<acronym>XML</acronym>数据源进行交互。在<xref
    linkend="example_simple-weather_module_pom" />中，该模块封装了所有的网络活动，以及与Yahoo!
    Weather交互涉及的<acronym>XML</acronym>解析活动。其它依赖于该模块的项目只要简单的调用<classname>WeatherService</classname>的<methodname
    role="keep-together">retrieveForecast()</methodname>方法，该方法接受一个邮政编码作为参数，返回一个<classname>Weather</classname>对象。</para>

    <example id="example_simple-weather_module_pom">
      <title>simple-weather 模块的 POM</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
    &lt;artifactId&gt;simple-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;simple-weather&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;name&gt;Simple Weather API&lt;/name&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
      &lt;artifactId&gt;simple-model&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;log4j&lt;/groupId&gt;
      &lt;artifactId&gt;log4j&lt;/artifactId&gt;
      &lt;version&gt;1.2.14&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;dom4j&lt;/groupId&gt;
      &lt;artifactId&gt;dom4j&lt;/artifactId&gt;
      &lt;version&gt;1.6.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;jaxen&lt;/groupId&gt;
      &lt;artifactId&gt;jaxen&lt;/artifactId&gt;
      &lt;version&gt;1.1.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
      &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
      &lt;version&gt;1.3.2&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;

</programlisting>
    </example>

    <para>这个<varname>simple-weather</varname>
    <acronym>POM</acronym>扩展了<varname>simple-parent</varname>
    <acronym>POM</acronym>，设置打包方式为<varname>jar</varname>，然后添加了下列的依赖：</para>

    <variablelist>
      <varlistentry>
        <term><literal>org.sonatype.mavenbook.ch07:simple-model:1.0</literal></term>

        <listitem>
          <para><varname>simple-weather</varname>将Yahoo! Weather
          <acronym>RSS</acronym>数据源解析成一个<classname>Weather</classname>对象。
          它有一个对<varname>simple-model</varname>的直接依赖。.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>log4j:log4j:1.2.14</literal></term>

        <listitem>
          <para><varname>simple-weather</varname>使用Log4J类库来打印日志信息。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>dom4j:dom4j:1.6.1 and
        jaxen:jaxen:1.1.1</literal></term>

        <listitem>
          <para>这两个依赖都用来解析从Yahoo! Weather返回的<acronym>XML</acronym>。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>org.apache.commons:commons-io:1.3.2
        (scope=test)</literal></term>

        <listitem>
          <para>这个<literal>test</literal>范围的依赖是由<classname>YahooParserTest</classname>使用的。</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>接下来是<classname>WeatherService</classname>类，在<xref
    linkend="example_weatherservice_class" />中显示。这个类和<xref
    linkend="multimodule-weather-service" />中的WeatherService类看起来很像。虽然<classname>WeatherService</classname>名字一样，但与本章中的样例还是有细微的差别。这个版本的<methodname>retrieveForecast()</methodname>方法返回一个<classname>Weather</classname>对象，而格式就留给调用<classname>WeatherService</classname>的程序去处理。其它的主要变化是，<classname>YahooRetriever</classname>和<classname>YahooParser</classname>都是<classname>WeatherService</classname>
    bean的bean属性。</para>

    <example id="example_weatherservice_class">
      <title>WeatherService 类</title>

      <programlisting language="java">package org.sonatype.mavenbook.weather;

import java.io.InputStream;

import org.sonatype.mavenbook.weather.model.Weather;

public class WeatherService {

  private YahooRetriever yahooRetriever;
  private YahooParser yahooParser;

  public WeatherService() {}

  public Weather retrieveForecast(String zip) throws Exception {
    // Retrieve Data
    InputStream dataIn = yahooRetriever.retrieve(zip);

    // Parse DataS
    Weather weather = yahooParser.parse(zip, dataIn);

    return weather;
  }

  public YahooRetriever getYahooRetriever() {
    return yahooRetriever;
  }

  public void setYahooRetriever(YahooRetriever yahooRetriever) {
    this.yahooRetriever = yahooRetriever;
  }

  public YahooParser getYahooParser() {
    return yahooParser;
  }

  public void setYahooParser(YahooParser yahooParser) {
    this.yahooParser = yahooParser;
  }
}
</programlisting>
    </example>

    <para>最后，在这个项目中我们有一个由Spring Framework用来创建<indexterm>
        <primary>ApplicationContext (Spring Framework)</primary>
      </indexterm><classname>ApplicationContext</classname>的<acronym>XML</acronym>文件。首先，一些解释：两个应用程序，web应用和命令行工具，都需要和<classname>WeatherService</classname>类交互，而且它们都使用名字<varname>weatherService</varname>从Spring
    <classname>ApplicationContext</classname>获取此类的一个实例。我们的web应用使用一个与<classname>WeatherService</classname>实例关联的Spring
    <acronym>MVC</acronym>控制器，我们的命令行应用在静态<methodname>main()</methodname>方法中从<classname>ApplicationContext</classname>载入这个<classname>WeatherService</classname>。为了鼓励重用，我们已经在<filename>src/main/resources</filename>中包含了一个<filename>applicationContext-weather.xml</filename>文件，这样便在classpath中可用。依赖于<varname>simple-weather</varname>模块的模块可以使用Spring
    Framework中的<classname>ClasspathXmlApplicationContext</classname>载入这个Application
    Context。之后它们就能引用名为<varname>weatherService</varname>的<classname>WeatherService</classname>实例。</para>

    <example>
      <title>simple-weather模块的Spring Application Context</title>

      <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans 
             http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
    default-lazy-init="true"&gt;

    &lt;bean id="weatherService" 
             class="org.sonatype.mavenbook.weather.WeatherService"&gt;
      &lt;property name="yahooRetriever" ref="yahooRetriever"/&gt;
      &lt;property name="yahooParser" ref="yahooParser"/&gt;
    &lt;/bean&gt;    

    &lt;bean id="yahooRetriever" 
             class="org.sonatype.mavenbook.weather.YahooRetriever"/&gt;    

    &lt;bean id="yahooParser" 
             class="org.sonatype.mavenbook.weather.YahooParser"/&gt;
&lt;/beans&gt;</programlisting>
    </example>

    <para>该文档定义了三个bean：<varname>yahooParser</varname>，<varname>yahooRetriever</varname>，和<varname>weatherService</varname>。<varname>weatherService</varname>
    bean是<classname>WeatherService</classname>的一个实例，这个<acronym>XML</acronym>文档通过引用对应类的命名实例来填充<varname>yahooParser</varname>和<varname>yahooRetriever</varname>属性。可以将这个<filename>applicationContext-weather.xml</filename>文件看作是定义了这个多模块项目中一个子系统的架构。其它项目如<varname>simple-webapp</varname>和<varname>simple-command</varname>可以引用这个上下文，获取一个已经建立好与<classname>YahooRetriever</classname>和<classname>YahooParser</classname>实例关系的<classname>WeatherService</classname>实例。</para>
  </section>

  <section>
    <title>simple-persist模块</title>

    <para>该模块定义了两个简单的数据访问对象（DAO）。一个DAO<indexterm>
        <primary>DAO (Data Access Objects)</primary>
      </indexterm><indexterm class="startofrange" id="enterprise5a">
        <primary>multimodule project (example)</primary>

        <secondary>multimodule enterprise project</secondary>

        <tertiary>Simple Persist module of</tertiary>
      </indexterm><indexterm class="startofrange" id="enterprise5b">
        <primary>Web applications</primary>

        <secondary>multimodule enterprise project example</secondary>

        <tertiary>Simple Persist module of</tertiary>
      </indexterm><indexterm class="startofrange" id="enterprise5c">
        <primary>enterprise project, multimodule (example)</primary>

        <secondary>Simple Persist module of</secondary>
      </indexterm>是一个提供持久化操作接口的对象。在这个应用中我们使用了对象关系映射（ORM）框架Hibernate，DAO通常在对象旁边定义。在本项目中，我们定义两个DAO对象：<varname
    role="keep-together">WeatherDAO</varname>和<varname>LocationDAO</varname>。<varname>WeatherDAO</varname>类允许我们保存一个<varname>Weather</varname>对象至数据库，根据<literal>id</literal>获取一个<varname>Weather</varname>对象，获取匹配特定<varname>Location</varname>的<varname>Weather</varname>对象。<varname>LocationDAO</varname>有一个方法允许我们根据邮政编码获取<varname>Location</varname>对象。首先，让我们看一下<xref
    linkend="ex-simple-persist-POM" />中的<literal>simple-persist</literal>
    POM。</para>

    <example id="ex-simple-persist-POM">
      <title>simple-persist 的 POM</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
    &lt;artifactId&gt;simple-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;simple-persist&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;name&gt;Simple Persistence API&lt;/name&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
      &lt;artifactId&gt;simple-model&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate&lt;/artifactId&gt;
      &lt;version&gt;3.2.5.ga&lt;/version&gt;
      &lt;exclusions&gt;
        &lt;exclusion&gt;
          &lt;groupId&gt;javax.transaction&lt;/groupId&gt;
          &lt;artifactId&gt;jta&lt;/artifactId&gt;
        &lt;/exclusion&gt;
      &lt;/exclusions&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-annotations&lt;/artifactId&gt;
      &lt;version&gt;3.3.0.ga&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-commons-annotations&lt;/artifactId&gt;
      &lt;version&gt;3.3.0.ga&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.geronimo.specs&lt;/groupId&gt;
      &lt;artifactId&gt;geronimo-jta_1.1_spec&lt;/artifactId&gt;
      &lt;version&gt;1.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring&lt;/artifactId&gt;
      &lt;version&gt;2.0.7&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</programlisting>
    </example>

    <para>这个<acronym>POM</acronym>文件引用<varname>simple-parent</varname>作为一个父<acronym>POM</acronym>，它定义了一些依赖。<varname>simple-persist</varname>的<acronym>POM</acronym>中列出的依赖有：</para>

    <variablelist>
      <varlistentry>
        <term><literal>org.sonatype.mavenbook.ch07:simple-model:1.0</literal></term>

        <listitem>
          <para>就像<varname>simple-weather</varname>模块一样，这个持久化模块引用了<varname>simple-model</varname>中定义的核心模型对象。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>org.hibernate:hibernate:3.2.5.ga</literal></term>

        <listitem>
          <para>我们定义了一个对HIbernate版本3.2.5ga的依赖，但注意我们排除了Hibernate的一个依赖。这么做是因为<varname>javax.</varname><varname>transaction:</varname><varname>javax</varname><indexterm>
              <primary>dependencies</primary>

              <secondary>javax.transaction:javax (unavailable)</secondary>
            </indexterm><indexterm>
              <primary>javax.transaction:javax dependency
              (unavailable)</primary>
            </indexterm>依赖在公共Maven仓库中不可用。此依赖正好是Sun依赖中的一个，不能免费在中央Maven仓库中提供。为了避免烦人的信息告诉我们去下载非免费的依赖，我们简单的从Hibernate排除这个依赖然后添加一个geronimo-jta_1.1_spec依赖。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>org.apache.geronimo.specs:geronimo-jta_1.1_spec:1.1</literal></term>

        <listitem>
          <para>就像Servlet和JSP <acronym>API</acronym>，Apache
          Geronimo项目也根据Apache许可证友好的发布了一些认证过的企业级<acronym>API</acronym>。这意味着不管什么时候某个组件告诉你它依赖于<acronym>JDBC</acronym>，<acronym>JNDI</acronym>，和<acronym>JTA</acronym>
          <acronym>API</acronym>，你都可以查一下groupId为<varname>org.apache.geronimo.specs</varname>下的对应类库。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>org.springframework:spring:2.0.7</literal></term>

        <listitem>
          <para>这里包含了整个Spring Framework作为一个依赖<indexterm>
              <primary>Spring Framework</primary>
            </indexterm>。</para>

          <note>
            <para>只依赖于你正使用的Spring组件是一个很好的实践。Spring
            Framework项目很友好的创建了一些有针对性的构件如<varname>spring-hibernate3</varname>。</para>
          </note>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>为什么依赖于Spring呢？当和Hibernate集成的时候，Spring允许我们使用一些帮助类如<classname>HibernateDaoSupport</classname>。作为一个<classname>HibernateDaoSupport</classname>的样例，看一下<xref
    linkend="ex-persist-weatherdao-class" />中的<classname>WeatherDAO</classname>代码。</para>

    <example id="ex-persist-weatherdao-class">
      <title>simple-persist'的WeatherDAO类</title>

      <programlisting language="java">package org.sonatype.mavenbook.weather.persist;

import java.util.ArrayList;
import java.util.List;

import org.hibernate.Query;
import org.hibernate.Session;
import org.springframework.orm.hibernate3.HibernateCallback;
import org.springframework.orm.hibernate3.support.HibernateDaoSupport;

import org.sonatype.mavenbook.weather.model.Location;
import org.sonatype.mavenbook.weather.model.Weather;

public class WeatherDAO extends HibernateDaoSupport<co id="coDef-hibDao-1"
          linkends="coRef-hibDao-2" /> {

    public WeatherDAO() {}

    public void save(Weather weather) {<co id="coDef-hibDao-2"
          linkends="coRef-hibDao-2" />
      getHibernateTemplate().save( weather );
    }

    public Weather load(Integer id) {<co id="coDef-hibDao-3"
          linkends="coRef-hibDao-3" />
      return (Weather) getHibernateTemplate().load( Weather.class, id);
    }

    @SuppressWarnings("unchecked")
    public List&lt;Weather&gt; recentForLocation( final Location location ) {
      return (List&lt;Weather&gt;) getHibernateTemplate().execute(
        new HibernateCallback() {<co id="coDef-hibDao-4"
          linkends="coRef-hibDao-4" />
        public Object doInHibernate(Session session) {
          Query query = getSession().getNamedQuery("Weather.byLocation");
          query.setParameter("location", location);
          return new ArrayList&lt;Weather&gt;( query.list() );
        }
      });
    }
}</programlisting>
    </example>

    <para>就是这样。你已经编写了一个类，它能插入新的行，根据主键选取，以及能查找所有Weather表根据id连接Location表的结果。很显然，我们不能将书停在这里，然后花500页给你解释Hibernate的运作详情，但我们能做一些快速简单的解释：</para>

    <calloutlist>
      <callout arearefs="coDef-hibDao-1" id="coRef-hibDao-1">
        <para>继承<classname>HibernateDaoSupport</classname>的类。这个类会和Hibernate
        <classname>SessionFactory</classname>关联，后者将被用来创建Hibernate
        <classname>Session</classname>对象。在Hibernate中，每个操作都涉及<classname>Session</classname>对象，一个<classname>Session</classname>是访问下层数据库的中介，它也负责管理对<classname>DataSource</classname>的JDBC连接。继承<classname>HibernateDaoSupport</classname>也意味着我们能够使用<methodname>getHibernateTemplate()</methodname>访问<classname>HibernateTemplate</classname>。能使用<classname>HibernateTemplate</classname>完成的操作例子有……</para>
      </callout>

      <callout arearefs="coDef-hibDao-2" id="coRef-hibDao-2">
        <para><methodname>save()</methodname>方法接受一个<classname>Weather</classname>实例然后调用<classname>HibernateTemplate</classname>上的<methodname>save()</methodname>方法。<classname>HibernateTemplate</classname>简化了常见的HIbernate操作的调用，并别将所有数据库特有的异常转换成了运行时异常。这里我们调用<methodname>save()</methodname>，它往<classname>Weather</classname>表中插入一条新的记录。可选的操作有<methodname>update()</methodname>，它更新已存在的一行，或者<methodname>saveOrUpdate()</methodname>，它会根据Weather中的non-null
        id属性是否存在，执行保存或者更新。</para>
      </callout>

      <callout arearefs="coDef-hibDao-3" id="coRef-hibDao-3">
        <para><methodname>load()</methodname>方法，同样，也只是调用<classname>HibernateTemplate</classname>实例的方法。<classname>HibernateTemplate</classname>上的<methodname>load()</methodname>接受一个<classname>Class</classname>对象和一个<classname>Serializable</classname>对象。本例中，<classname>Serializable</classname>对应于要载入的<classname>Weather</classname>对象的<varname>id</varname>的值。</para>
      </callout>

      <callout arearefs="coDef-hibDao-4" id="coRef-hibDao-4">
        <para>最后一个方法<methodname>recentForLocation()</methodname>调用定义在<classname>Weather</classname>模型对象中的<classname>NamedQuery</classname>。如果你的记忆力足够好，你就知道<classname>Weather</classname>模型对象定义了一个命名查询"Weather.byLocation"，查询为"from
        Weather w where w.location =
        :location"。我们通过<classname>HibernateCallback</classname>中的Hibernate
        <classname>Session</classname>对象来载入<classname>NamedQuery</classname>，<classname>HibernateCallback</classname>由<classname>HibernateTemplate</classname>的<methodname>execute()</methodname>方法执行。在这个方法中你能看到我们填充了一个命名参数location，它来自于<methodname>recentForLocation()</methodname>方法的参数。</para>
      </callout>
    </calloutlist>

    <para>现在是时候阐明一些情况了。<classname>HibernateDaoSupport</classname>和<classname>HibernateTemplate</classname>是来自于Spring
    Framework的类。它们由Spring Framework创建，目的是减少编写Hibernate
    <acronym>DAO</acronym>对象的痛苦。为了支持这个<acronym>DAO</acronym>，我们需要在<varname>simple-persist</varname>的Spring
    <classname>ApplicationContext</classname>定义中做一些配置。<xref
    linkend="ex-persist-spring" />中显示的XML文档存储在<filename>src/main/resources</filename>，名为<filename
    role="keep-together">applicationContext-persist.xml</filename>。</para>

    <example id="ex-persist-spring">
      <title>simple-persist 的 Spring Application Context</title>

      <programlisting language="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans 
             http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"
    default-lazy-init="true"&gt;

    &lt;bean id="sessionFactory"
class="org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean"&gt;
        &lt;property name="annotatedClasses"&gt;
            &lt;list&gt;
                &lt;value&gt;org.sonatype.mavenbook.weather.model.Atmosphere&lt;/value&gt;
                &lt;value&gt;org.sonatype.mavenbook.weather.model.Condition&lt;/value&gt;
                &lt;value&gt;org.sonatype.mavenbook.weather.model.Location&lt;/value&gt;
                &lt;value&gt;org.sonatype.mavenbook.weather.model.Weather&lt;/value&gt;
                &lt;value&gt;org.sonatype.mavenbook.weather.model.Wind&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="hibernateProperties"&gt;
            &lt;props&gt;
                &lt;prop key="hibernate.show_sql"&gt;false&lt;/prop&gt;
                &lt;prop key="hibernate.format_sql"&gt;true&lt;/prop&gt;
                &lt;prop key="hibernate.transaction.factory_class"&gt;
                  org.hibernate.transaction.JDBCTransactionFactory
                &lt;/prop&gt;
                &lt;prop key="hibernate.dialect"&gt;
                  org.hibernate.dialect.HSQLDialect
                &lt;/prop&gt;
                &lt;prop key="hibernate.connection.pool_size"&gt;0&lt;/prop&gt;
                &lt;prop key="hibernate.connection.driver_class"&gt;
                  org.hsqldb.jdbcDriver
                &lt;/prop&gt;
                &lt;prop key="hibernate.connection.url"&gt;
                  jdbc:hsqldb:data/weather;shutdown=true
                &lt;/prop&gt;
                &lt;prop key="hibernate.connection.username"&gt;sa&lt;/prop&gt;
                &lt;prop key="hibernate.connection.password"&gt;&lt;/prop&gt;
                &lt;prop key="hibernate.connection.autocommit"&gt;true&lt;/prop&gt;
                &lt;prop key="hibernate.jdbc.batch_size"&gt;0&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="locationDAO" 
             class="org.sonatype.mavenbook.weather.persist.LocationDAO"&gt;
        &lt;property name="sessionFactory" ref="sessionFactory"/&gt;
    &lt;/bean&gt;
    
    &lt;bean id="weatherDAO" 
             class="org.sonatype.mavenbook.weather.persist.WeatherDAO"&gt;
        &lt;property name="sessionFactory" ref="sessionFactory"/&gt;
    &lt;/bean&gt;
 &lt;/beans&gt;</programlisting>
    </example>

    <para>在这个application
    context中，我们完成了一些事情。<acronym>DAO</acronym>从<varname>sessionFactory</varname>
    bean获取Hibernate
    <classname>Session</classname>对象。这个bean是一个<classname>AnnotationSessionFactoryBean</classname>的实例，并由一列<varname>annotatedClasses</varname>填充。注意这列标注类就是定义在我们<varname>simple-model</varname>模块中的那些类。接下来，<varname>sessionFactory</varname>通过一组Hibernate配置属性(<varname>hibernateProperties</varname>)配置。该例中，我们的Hibernate属性定义了许多设置：</para>

    <variablelist>
      <varlistentry>
        <term><literal>hibernate.dialect</literal></term>

        <listitem>
          <para>该设置控制如何生成数据库的<acronym>SQL</acronym>。由于我们正在使用<acronym>HSQLDB</acronym>数据库，我们的数据库方言设置成<classname>org.</classname><classname>hibernate.</classname><classname>dialect.</classname><classname>HSQLDialect</classname>。Hibernate有所有主流数据库的方言，如Oracle，MySQL，Postgres和SQL
          Server。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>hibernate.connection.*</literal></term>

        <listitem>
          <para>该例中，我们从Spring配置中配置<acronym>JDBC</acronym>连接属性。我们的应用被配置成运行在<filename
          role="keep-together">./data/weather</filename>目录下的<acronym>HSQLDB</acronym>上。在实际的企业应用中，你更可能会使用如<acronym>JNDI</acronym>的东西以从你的应用程序代码中抽出数据库配置。</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>最后，在这个bean定义文件中，两个<varname>simple-persist</varname>
    <acronym>DAO</acronym>对象被创建并给予了对于刚定义的<varname>sessionFactory</varname>
    bean的引用。就像<varname>simple-weather</varname>中的Spring application
    context，这个<filename>applicationContext-persist.xml</filename>文件定义了一个大型企业应用设计中一个子模块的架构。如果你曾经从事过大量持久化类的集合相关的工作，你可能会发现，这些与你应用程序独立的application
    context文件，能帮助你快速的理解所有类之间的关系。</para>

    <para><varname>simple-persist</varname>中还有最后一块不清楚的地方。本章后面，我们将看到<indexterm>
        <primary>Maven Hibernate3 plugin</primary>
      </indexterm><indexterm>
        <primary>Hibernate3 plugin</primary>
      </indexterm>如何使用Maven Hibernate3插件，根据标注的模型对象来生成数据库schema。为了使它正确工作，Maven
    Hibernate3插件需要读取<acronym>JDBC</acronym>连接配置参数，那一列标注的类，以及<filename>src/main/resources</filename>中名为<filename><indexterm>
        <primary>hibernate.cfg.xml file</primary>
      </indexterm>hibernate.cfg.xml</filename>文件的Hibernate配置。该文件（它重复了一些<filename>applicationContext-persist.xml</filename>中的配置）的目的是能让Maven
    Hibernate3插件能仅仅依靠标注就能生成数据定义语言（<acronym>DDL</acronym>）。如<xref
    linkend="ex-hibernate-cfg" />。</para>

    <example id="ex-hibernate-cfg">
      <title>simple-persist 的 hibernate.cfg.xml</title>

      <programlisting language="xml">&lt;!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;
        
&lt;hibernate-configuration&gt;
  &lt;session-factory&gt;
        
    &lt;!-- SQL dialect --&gt;
    &lt;property name="dialect"&gt;org.hibernate.dialect.HSQLDialect&lt;/property&gt;
    
    &lt;!-- Database connection settings --&gt;
    &lt;property name="connection.driver_class"&gt;org.hsqldb.jdbcDriver&lt;/property&gt;
    &lt;property name="connection.url"&gt;jdbc:hsqldb:data/weather&lt;/property&gt;
    &lt;property name="connection.username"&gt;sa&lt;/property&gt;
    &lt;property name="connection.password"&gt;&lt;/property&gt;
    &lt;property name="connection.shutdown"&gt;true&lt;/property&gt;
    
    &lt;!-- JDBC connection pool (use the built-in one) --&gt;
    &lt;property name="connection.pool_size"&gt;1&lt;/property&gt;
    
    &lt;!-- Enable Hibernate's automatic session context management --&gt;
    &lt;property name="current_session_context_class"&gt;thread&lt;/property&gt;
    
    &lt;!-- Disable the second-level cache  --&gt;
    &lt;property name="cache.provider_class"&gt;
      org.hibernate.cache.NoCacheProvider
    &lt;/property&gt;
    
    &lt;!-- Echo all executed SQL to stdout --&gt;
    &lt;property name="show_sql"&gt;true&lt;/property&gt;
    
    &lt;!-- disable batching so HSQLDB will propagate errors correctly. --&gt;
    &lt;property name="jdbc.batch_size"&gt;0&lt;/property&gt;
    
    &lt;!-- List all the mapping documents we're using --&gt;
    &lt;mapping class="org.sonatype.mavenbook.weather.model.Atmosphere"/&gt;
    &lt;mapping class="org.sonatype.mavenbook.weather.model.Condition"/&gt;
    &lt;mapping class="org.sonatype.mavenbook.weather.model.Location"/&gt;
    &lt;mapping class="org.sonatype.mavenbook.weather.model.Weather"/&gt;
    &lt;mapping class="org.sonatype.mavenbook.weather.model.Wind"/&gt;
        
  &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;</programlisting>
    </example>

    <para><xref linkend="ex-persist-spring" />和<xref
    linkend="ex-multimodule-web-spring-parent" />的内容是冗余的。Spring Application
    Context
    <acronym>XML</acronym>是被web应用和命令行应用使用的，而<filename>hibernate.cfg.xml</filename>的存在只是为了支持Maven
    Hibernate3插件。本章的后面，我们将会看到如何使用<filename>hibernate.cfg.xml</filename>和Maven
    Hibernate3插件，根据<varname>simple-model</varname>中定义的标注对象模型，来生成一个数据库schema。<filename>hibernate.cfg.xml</filename>会配置JDBC连接属性并且为Maven
    Hibernate3插件枚举标注模型类的列表。</para>
  </section>

  <section>
    <title>simple-webapp模块</title>

    <para>该web应用中项目<varname>simple-webapp</varname><indexterm
        class="startofrange" id="enterprise6a">
        <primary>multimodule project (example)</primary>

        <secondary>multimodule enterprise project</secondary>

        <tertiary>Simple Web Application of</tertiary>
      </indexterm><indexterm class="startofrange" id="enterprise6b">
        <primary>Web applications</primary>

        <secondary>multimodule enterprise project example</secondary>

        <tertiary>Simple Web Application of</tertiary>
      </indexterm><indexterm class="startofrange" id="enterprise6c">
        <primary>enterprise project, multimodule (example)</primary>

        <secondary>Simple Web Application of</secondary>
      </indexterm>中定义。这个简单web应用项目将会定义两个Spring
    <acronym>MVC</acronym>控制器：<classname>WeatherController</classname>和<classname
    role="keep-together">HistoryController</classname>。两者都会引用<varname>simple-weather</varname>和<varname>simple-persist</varname>中定义的组件。Spring容器在应用程序的<filename>web.xml</filename>中配置，该文件引用了<varname
    role="keep-together">simple-weather</varname>中的<filename>applicationContext-weather.xml</filename>文件和<varname>simple-persist</varname>中的<filename>applicationContext-persist.xml</filename>文件。这个简单web应用的组件架构如<xref
    linkend="fig-web-components" />显示。</para>

    <figure id="fig-web-components">
      <title>Spring MVC 控制器引用simple-weather和simple-persist中的组件</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="figs/web/multimodule-web-web-spring.png"
                     scalefit="1" width="6in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para><varname>simple-webapp</varname>的POM如<xref
    linkend="example_pom-for-simple-webapp" />显示。</para>

    <example id="example_pom-for-simple-webapp">
      <title>simple-webapp的POM</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
    &lt;artifactId&gt;simple-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
  &lt;/parent&gt;

  &lt;artifactId&gt;simple-webapp&lt;/artifactId&gt;
  &lt;packaging&gt;war&lt;/packaging&gt;
  &lt;name&gt;Simple Web Application&lt;/name&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt; <co id="coDef-spring-web-1" os="coRef-spring-web-1" />
      &lt;groupId&gt;org.apache.geronimo.specs&lt;/groupId&gt;
      &lt;artifactId&gt;geronimo-servlet_2.4_spec&lt;/artifactId&gt;
      &lt;version&gt;1.1.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
      &lt;artifactId&gt;simple-weather&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
      &lt;artifactId&gt;simple-persist&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring&lt;/artifactId&gt;
      &lt;version&gt;2.0.7&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;
      &lt;artifactId&gt;velocity&lt;/artifactId&gt;
      &lt;version&gt;1.5&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;build&gt;
    &lt;finalName&gt;simple-webapp&lt;/finalName&gt;
    &lt;plugins&gt;
      &lt;plugin&gt; <co id="coDef-spring-web-2" linkends="coRef-spring-web-2" />
        &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;
        &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt;
        &lt;dependencies&gt;<co id="coDef-spring-web-3"
          linkends="coRef-spring-web-3" />
          &lt;dependency&gt;
            &lt;groupId&gt;hsqldb&lt;/groupId&gt;
            &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;
            &lt;version&gt;1.8.0.7&lt;/version&gt;
          &lt;/dependency&gt;
        &lt;/dependencies&gt;        
      &lt;/plugin&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; <co
          id="coDef-spring-web-4" linkends="coRef-spring-web-4" />
        &lt;artifactId&gt;hibernate3-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.0&lt;/version&gt;
        &lt;configuration&gt;
          &lt;components&gt;
            &lt;component&gt;
              &lt;name&gt;hbm2ddl&lt;/name&gt;
              &lt;implementation&gt;annotationconfiguration&lt;/implementation&gt; <co
          id="coDef-spring-web-5" linkends="coRef-spring-web-5" />
            &lt;/component&gt;
          &lt;/components&gt;
        &lt;/configuration&gt;
        &lt;dependencies&gt;
          &lt;dependency&gt;
            &lt;groupId&gt;hsqldb&lt;/groupId&gt;
            &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;
            &lt;version&gt;1.8.0.7&lt;/version&gt;
          &lt;/dependency&gt;
        &lt;/dependencies&gt;        
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</programlisting>
    </example>

    <para>随着书本的推进以及样例变得越来越大，你会注意到<filename>pom.xml</filename>开始呈现得有一些笨重，这里我们配置了四个依赖和两个插件。让我们详细查看一下这个POM然后详述其中一些重要的配置点：</para>

    <calloutlist>
      <callout arearefs="coDef-spring-web-1" id="coRef-spring-web-1">
        <para><varname>simple-webapp</varname>项目定义了四个依赖：来自于Apache
        Geronimo的Servlet
        2.4规格说明实现，simple-weather服务类库，simple-persist持久化类库，以及整个Spring Framework
        2.0.7。</para>
      </callout>

      <callout arearefs="coDef-spring-web-2" id="coRef-spring-web-2">
        <para>Maven Jetty插件<indexterm>
            <primary>Maven Jetty plugin</primary>
          </indexterm><indexterm>
            <primary>Jetty plugin</primary>
          </indexterm>以最简单的方式加入到该项目，我们只是添加一个引用了对应<literal>groupId</literal>和<literal>artifactId</literal>的<literal>plugin</literal>元素。配置这个插件如此平常意味着这个插件的开发者做了很好的工作提供了足够的默认值，在大部分情况下不需要被重写。如果你需要重写一些Jetty插件的配置，那么就需要提供<literal>configuration</literal>元素。</para>
      </callout>

      <callout arearefs="coDef-spring-web-3" id="coRef-spring-web-3">
        <para>在我们的build配置中，我们还配置了Maven Hibernate3插件来访问内嵌的HSQLDB实例。要让Maven
        Hibernate3插件能成功的使用JDBC连接该数据库，该插件需要引用classpath中的HSQLDB
        JDBC驱动。为了让这个插件能使用该依赖，我们在<sgmltag>plugin</sgmltag>声明下面添加了一个<sgmltag>dependency</sgmltag>声明。在该例中，我们引用了hsqldb:hsqldb:1.8.0.7。这个Hibernate插件也需要JDBC驱动来创建数据库，所以我们也在它的配置中添加了这个依赖。</para>
      </callout>

      <callout arearefs="coDef-spring-web-4" id="coRef-spring-web-4">
        <para>这个Maven Hibernate插件<indexterm>
            <primary>Maven Hibernate plugin</primary>
          </indexterm><indexterm>
            <primary>Hibernate plugin</primary>
          </indexterm>正是该POM变得有趣的地方。在下一节，我们将会运行<literal>hbm2ddl</literal>目标来生成HSQLDB数据库。在这个<filename>pom.xml</filename>中，我们包含了对<literal>hibernate3-maven-plugin</literal>版本2.0的引用，该插件由Codehaus
        Mojo维护。</para>
      </callout>

      <callout arearefs="coDef-spring-web-5" id="coRef-spring-web-5">
        <para>Maven
        Hibernate3插件有不同的方法获取Hibernate映射信息，这些信息适用于Hibernate3插件的不同用例。如果你正在使用Hibernate映射XML文件(<filename>.hbm.xml</filename>)，你会要使用<literal>hbm2java</literal>目标生成模型类，你会将implementation设置成<literal>configuration</literal>。如果你使用Hibernate3插件逆向工程从一个数据库产生<filename>.hbm.xml</filename>文件和模型类，你会需要一个<literal>jdbcconfiguration</literal>的implementation。在本例中，我们使用现存的标注对象模型来生成一个数据库。换句话说，我们有我们的Hibernate映射，但我们还没有数据库。在这种用例中，正确的implementation值应该是<literal>annotationconfiguration</literal>。Maven
        Hibernate3插件在后面的一节<xref
        linkend="sect-spring-running-web" />中详细讨论。</para>
      </callout>
    </calloutlist>

    <note>
      <para>一个常见的错误是使用<sgmltag>extensions</sgmltag>配置添加一个插件需要的依赖。这是强烈不推荐的因为extensions会在你的项目中造成classpath污染，以及其它令人讨厌的副作用。此外，extensions行为正在2.1中被重做，最后你都会要改变它。唯一的对<sgmltag>extensions</sgmltag>的正常使用是定义新的wagon实现。</para>
    </note>

    <para>接下来，我们将我们的注意力转移到两个处理所有请求的Spring
    MVC控制器。两个控制器都引用了在<varname>simple-weather</varname>和<varname>simple-persist</varname>中定义的bean。</para>

    <example>
      <title>simple-webapp WeatherController</title>

      <programlisting language="java">package org.sonatype.mavenbook.web;

import org.sonatype.mavenbook.weather.model.Weather;
import org.sonatype.mavenbook.weather.persist.WeatherDAO;
import org.sonatype.mavenbook.weather.WeatherService;
import javax.servlet.http.*;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;

public class WeatherController implements Controller {

  private WeatherService weatherService;
  private WeatherDAO weatherDAO;

  public ModelAndView handleRequest(HttpServletRequest request,
      HttpServletResponse response) throws Exception {

    String zip = request.getParameter("zip");
    Weather weather = weatherService.retrieveForecast(zip);
    weatherDAO.save(weather);
    return new ModelAndView("weather", "weather", weather);
  }

  public WeatherService getWeatherService() {
    return weatherService;
  }

  public void setWeatherService(WeatherService weatherService) {
    this.weatherService = weatherService;
  }

  public WeatherDAO getWeatherDAO() {
    return weatherDAO;
  }

  public void setWeatherDAO(WeatherDAO weatherDAO) {
    this.weatherDAO = weatherDAO;
  }
}</programlisting>
    </example>

    <para><varname>WeatherController</varname>实现了MVC
    Controller接口，该接口强制要求实现如上例中的<methodname>handleRequest()</methodname>方法。如果你看一下该方法的主要内容，你会看到它调用了<varname>weatherService</varname>实例变量的<methodname>retrieveForecast()</methodname>方法。不像前面的章节中，有一个Servlet来初始化<classname>WeatherService</classname>类，<classname>WeatherController</classname>是一个带有<varname>weatherService</varname>属性的bean。Spring
    Ioc容器会负责将<varname>weatherService</varname>组件注入到控制器。同时也注意我们并没有在这个控制器实现中使用<classname
    role="keep-together">WeatherFormatter</classname>；而是将<methodname>retrieveForecast()</methodname>返回的<classname>Weather</classname>对象传递给了<classname>ModelAndView</classname>的构造函数。<classname>ModelAndView</classname>类将被用来呈现<indexterm>
        <primary>Velocity template</primary>
      </indexterm>Velocity模板，这个模板有对<varname>${weather}</varname>变量的引用。<filename>weather.vm</filename>模板存储在<filename>src/main/webapp/WEB-INF/vm</filename>，如<xref
    linkend="ex-weather-vm" />所示。</para>

    <para>在这个<classname>WeatherController</classname>中，在我们呈现天气预报输出之前，我们将<classname>WeatherService</classname>返回的<classname>Weather</classname>对象传递给<classname>WeatherDAO</classname>的<methodname>save()</methodname>方法。这里我们使用Hibernate将<classname>Weather</classname>对象保存到HSQLDB数据库。之后，在<classname>HistoryController</classname>中，我们将看如何能够获取由<classname>WeatherController</classname>保存的天气预报历史信息。</para>

    <example>
      <title>由 WeatherController 呈现的 weather.vm 模板</title>

      <programlisting id="ex-weather-vm" language="xml">&lt;b&gt;Current Weather Conditions for:
  ${weather.location.city}, ${weather.location.region}, 
  ${weather.location.country}&lt;/b&gt;&lt;br/&gt;
  
&lt;ul&gt;
  &lt;li&gt;Temperature: ${weather.condition.temp}&lt;/li&gt;
  &lt;li&gt;Condition: ${weather.condition.text}&lt;/li&gt;
  &lt;li&gt;Humidity: ${weather.atmosphere.humidity}&lt;/li&gt;
  &lt;li&gt;Wind Chill: ${weather.wind.chill}&lt;/li&gt;
  &lt;li&gt;Date: ${weather.date}&lt;/li&gt;
&lt;/ul&gt;
</programlisting>
    </example>

    <para>Velocity模板的语法简单易懂，变量通过<code>${}</code>标记引用。大括弧里面的表达式引用<varname>weather</varname>变量的一个属性，或者该变量属性的属性。<varname>weather</varname>变量是由<classname>WeatherController</classname>传递给该模板的。</para>

    <para><classname>HistoryController</classname>用来获取那些已经由<classname>WeatherController</classname>请求过的最近历史天气预报信息。任何时候当我们从<classname>WeatherController</classname>获取预报的时候，该控制器通过<classname>WeatherDAO</classname>将<classname>Weather</classname>对象保存至数据库。<classname>WeatherDAO</classname>然后使用Hibernate将<classname>Weather</classname>对象剖析成一组相关数据库表的记录行。<classname>HistoryController</classname>如<xref
    linkend="ex-spring-history" />所示。</para>

    <example id="ex-spring-history">
      <title>simple-web 的 HistoryController</title>

      <programlisting language="java">package org.sonatype.mavenbook.web;

import java.util.*;
import javax.servlet.http.*;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;
import org.sonatype.mavenbook.weather.model.*;
import org.sonatype.mavenbook.weather.persist.*;

public class HistoryController implements Controller {

  private LocationDAO locationDAO;
  private WeatherDAO weatherDAO;

  public ModelAndView handleRequest(HttpServletRequest request,
      HttpServletResponse response) throws Exception {
    String zip = request.getParameter("zip");
    Location location = locationDAO.findByZip(zip);
    List&lt;Weather&gt; weathers = weatherDAO.recentForLocation( location );

    Map&lt;String,Object&gt; model = new HashMap&lt;String,Object&gt;();
    model.put( "location", location );
    model.put( "weathers", weathers );

    return new ModelAndView("history", model);
  }

  public WeatherDAO getWeatherDAO() {
    return weatherDAO;
  }

  public void setWeatherDAO(WeatherDAO weatherDAO) {
    this.weatherDAO = weatherDAO;
  }

  public LocationDAO getLocationDAO() {
    return locationDAO;
  }

  public void setLocationDAO(LocationDAO locationDAO) {
    this.locationDAO = locationDAO;
  }
}</programlisting>
    </example>

    <para><classname>HistoryController</classname>被注入了两个定义在<varname>simple-persist</varname>中的<acronym>DAO</acronym>对象。这两个<acronym>DAO</acronym>是<classname>HistoryController</classname>的bean属性：<classname>WeatherDAO</classname>和<classname>LocationDAO</classname>。<classname>HistoryController</classname>的目标是获取一个与<varname>zip</varname>参数对应的<classname>Weather</classname>对象列表。当<classname>WeatherDAO</classname>将<classname>Weather</classname>对象保存至数据库，它不只是保存邮编，它保存了一个与<varname>simple-model</varname>中<classname>Weather</classname>对象相关的<classname>Location</classname>对象。为了获取一个<classname>Weather</classname>对象的<classname>List</classname>，首先通过调用<classname>LocationDAO</classname>的<methodname>findByZip()</methodname>方法，获取与<varname>zip</varname>参数对应的<classname>Location</classname>对象。</para>

    <para>一旦获得了<classname>Location</classname>对象，<classname>HistoryController</classname>之后就会尝试获取与给定的<classname>Location</classname>相匹配的<classname>Weather</classname>对象。在获取了<classname>List&lt;Weather&gt;</classname>之后，一个<classname>HashMap</classname>被创建以存储两个变量，供如<xref
    linkend="ex-spring-history-velocity" />中显示的<filename>history.vm</filename>
    Velocity模板使用。</para>

    <example>
      <title>由 HistoryController 呈现的 history.vm </title>

      <programlisting id="ex-spring-history-velocity" language="java">&lt;b&gt;
Weather History for: ${location.city}, ${location.region}, ${location.country}
&lt;/b&gt;
&lt;br/&gt;
  
#foreach( $weather in $weathers )
  &lt;ul&gt;
    &lt;li&gt;Temperature: $weather.condition.temp&lt;/li&gt;
    &lt;li&gt;Condition: $weather.condition.text&lt;/li&gt;
    &lt;li&gt;Humidity: $weather.atmosphere.humidity&lt;/li&gt;
    &lt;li&gt;Wind Chill: $weather.wind.chill&lt;/li&gt;
    &lt;li&gt;Date: $weather.date&lt;/li&gt;
  &lt;/ul&gt;
#end
</programlisting>
    </example>

    <para><filename>src/main/webapp/WEB-INF/vm</filename>中的<filename>history.vm</filename>模板引用了<varname>location</varname>变量以输出天气预报位置的相关信息。该模板使用了一个Velocity的控制结构，为了循环<varname>weathers</varname>变量中的每个元素。<varname>weathers</varname>中的每个元素被赋给了一个名为<varname>weather</varname>的变量，<code>#foreach</code>和<code>#end</code>中间的模板用来呈现每个预报输出。</para>

    <para>你已经看到了这些<classname>Controller</classname>实现，以及它们如何引用定义在<varname>simple-weather</varname>和<varname>simple-persist</varname>中的其它bean，它们相应HTTP请求，让那些知道如何呈现Velocity模板的神奇的模板系统来控制输出。所有的魔法都在位于<filename>src/main/webapp/WEB-INF/weather-servlet.xml</filename>的Spring
    appliction
    context中配置。这个XML文件配置了控制器并引用了其它Spring管理的bean，它由<classname>ServletContextListener</classname>载入，后者同时也被配置从classpath中载入了<filename>applicationContext-weather.xml</filename>和<filename>applicationContext-persist.xml</filename>。让我们仔细看一下<xref
    linkend="ex-spring-weather-servlet" />中展示的<filename>weather-servlet.xml</filename>。</para>

    <example>
      <title>weather-servlet.xml 中的 Spring 控制器配置</title>

      <programlisting id="ex-spring-weather-servlet" language="xml">&lt;beans&gt;  
     &lt;bean id="weatherController" <co id="coDef-weather-servlet-1"
          linkends="coRef-weather-servlet-1" />
           class="org.sonatype.mavenbook.web.WeatherController"&gt;
       &lt;property name="weatherService" ref="weatherService"/&gt;
       &lt;property name="weatherDAO" ref="weatherDAO"/&gt;
     &lt;/bean&gt;

     &lt;bean id="historyController" 
           class="org.sonatype.mavenbook.web.HistoryController"&gt;
       &lt;property name="weatherDAO" ref="weatherDAO"/&gt;
       &lt;property name="locationDAO" ref="locationDAO"/&gt;
     &lt;/bean&gt;

     &lt;!-- you can have more than one handler defined --&gt;
     &lt;bean id="urlMapping" 
     class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
          &lt;property name="urlMap"&gt;
               &lt;map&gt;
                    &lt;entry key="/weather.x"&gt; <co
          id="coDef-weather-servlet-2" linkends="coRef-weather-servlet-2" />
                         &lt;ref bean="weatherController" /&gt;
                    &lt;/entry&gt;
                    &lt;entry key="/history.x"&gt;
                         &lt;ref bean="historyController" /&gt;
                    &lt;/entry&gt;
               &lt;/map&gt;
          &lt;/property&gt;
     &lt;/bean&gt;


     &lt;bean id="velocityConfig" <co id="coDef-weather-servlet-3"
          linkends="coRef-weather-servlet-3" />
   class="org.springframework.web.servlet.view.velocity.VelocityConfigurer"&gt;
       &lt;property name="resourceLoaderPath" value="/WEB-INF/vm/"/&gt;
     &lt;/bean&gt;

     &lt;bean id="viewResolver" <co id="coDef-weather-servlet-4"
          linkends="coRef-weather-servlet-4" />
   class="org.springframework.web.servlet.view.velocity.VelocityViewResolver"&gt;
       &lt;property name="cache" value="true"/&gt;
       &lt;property name="prefix" value=""/&gt;
       &lt;property name="suffix" value=".vm"/&gt;
       &lt;property name="exposeSpringMacroHelpers" value="true"/&gt;
     &lt;/bean&gt;
&lt;/beans&gt;
</programlisting>
    </example>

    <calloutlist>
      <callout arearefs="coDef-weather-servlet-1" id="coRef-weather-servlet-1">
        <para><filename>weather-servlet.xml</filename>定义了两个控制器作为Spring管理的bean。<varname>weatherController</varname>有两个属性，引用<varname>weatherService</varname>和<varname>weatherDAO</varname>。<varname>historyController</varname>引用了<varname>weatherDAO</varname>和<varname>locationDAO</varname>
        bean。当<classname>ApplicationContext</classname>被创建的时候，它所处的环境能够访问<varname>simple-persist</varname>和<varname>simple-weather</varname>中定义的<classname>ApplicationContext</classname>。在<xref
        linkend="ex-spring-webxml" />中你将看到如何配置Spring以归并多个Spring配置文件的组件。</para>
      </callout>

      <callout arearefs="coDef-weather-servlet-2" id="coRef-weather-servlet-2">
        <para><varname>urlMapping</varname>
        bean定义了调用<classname>WeatherController</classname>和<classname>HistoryController</classname>的<acronym>URL</acronym>模式。该例中，我们使用<classname>SimpleUrlHandlerMapping</classname>，将<filename>/weather.x</filename>映射到<classname>WeatherController</classname>，将<filename>/history.x</filename>映射到<classname>HistoryController</classname>。</para>
      </callout>

      <callout arearefs="coDef-weather-servlet-3" id="coRef-weather-servlet-3">
        <para>由于我们正使用Velocity模板引擎，我们需要传入一些配置选项。在<varname>velocityConfig</varname>
        bean中，我们告诉Velocity从<filename>/WEB-INF/vm</filename>目录中寻找所有的模板。</para>
      </callout>

      <callout arearefs="coDef-weather-servlet-4" id="coRef-weather-servlet-4">
        <para>最后，<varname>viewResolver</varname>使用<classname>VelocityViewResolver</classname>类配置。Spring中有很多<varname>viewResolver</varname>实现，从用来呈现<acronym>JSP</acronym>或者<acronym>JSTL</acronym>页面的标准<varname>viewResolver</varname>，到用来呈现Freemarker模板的<varname>viewResolver</varname>。本例中，我们配置Velocity模板引擎，设置默认的前缀和后缀，它们将被自动附加到那些传给<classname>ModelAndView</classname>的模板名前后。</para>
      </callout>
    </calloutlist>

    <para>最后，<varname>simple-webapp</varname>项目中有一个<filename>web.xml</filename>，提供了这个web应用的基本配置。<filename>web.xml</filename>文件如<xref
    linkend="ex-spring-webxml" />所示：</para>

    <example>
      <title>simple-webapp 的 web.xml</title>

      <programlisting id="ex-spring-webxml" language="xml">&lt;web-app id="simple-webapp" version="2.4" 
     xmlns="http://java.sun.com/xml/ns/j2ee" 
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
     xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee 
                         http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt;
  &lt;display-name&gt;Simple Web Application&lt;/display-name&gt;
  
  &lt;context-param&gt; <co id="coDef-spring-webx-1"
          linkends="coRef-spring-webx-1" />
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;
      classpath:applicationContext-weather.xml
      classpath:applicationContext-persist.xml
    &lt;/param-value&gt;
  &lt;/context-param&gt;
  
  &lt;context-param&gt; <co id="coDef-spring-webx-2"
          linkends="coRef-spring-webx-2" />
    &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;/WEB-INF/log4j.properties&lt;/param-value&gt;
  &lt;/context-param&gt;
  
  &lt;listener&gt; <co id="coDef-spring-webx-3" linkends="coRef-spring-webx-3" />
    &lt;listener-class&gt;
      org.springframework.web.util.Log4jConfigListener
    &lt;/listener-class&gt;
  &lt;/listener&gt;
  
  &lt;listener&gt;
    &lt;listener-class&gt; <co id="coDef-spring-webx-4"
          linkends="coRef-spring-webx-4" />
     org.springframework.web.context.ContextLoaderListener
    &lt;/listener-class&gt;
  &lt;/listener&gt;
  
  &lt;servlet&gt; <co id="coDef-spring-webx-5" linkends="coRef-spring-webx-5" />
    &lt;servlet-name&gt;weather&lt;/servlet-name&gt;
    &lt;servlet-class&gt;
      org.springframework.web.servlet.DispatcherServlet
    &lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;
  
  &lt;servlet-mapping&gt; <co id="coDef-spring-webx-6"
          linkends="coRef-spring-webx-6" />
    &lt;servlet-name&gt;weather&lt;/servlet-name&gt;
    &lt;url-pattern&gt;*.x&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</programlisting>
    </example>

    <calloutlist>
      <callout arearefs="coDef-spring-webx-1" id="coRef-spring-webx-1">
        <para>这里有一些魔法能让我们在项目中重用<filename>applicationContext-weather.xml</filename>和<filename>applicationContext-persist.xml</filename>。<varname>contextConfigLocation</varname>由<classname>ContextLoaderListener</classname>用来创建一个<classname>ApplicationContext</classname>。当一个weather
        servlet被创建的时候，<xref
        linkend="ex-spring-weather-servlet" />中的<filename>weather-servlet.xml</filename>将由此<varname>contextConfigLocation</varname>中创建的<classname>ApplicationContext</classname>赋值。用这种方式，你可以在另外的项目中定义一组bean，然后可以通过classpath引用这些bean。由于<varname>simple-persist</varname>和<varname>simple-weather</varname>的<acronym>JAR</acronym>将会位于<filename>WEB-INF/lib</filename>，我们所要做的只是使用<literal>classpath:</literal>前缀来引用这些文件。（另一种选择是将所有这些文件拷贝到<filename>/WEB-INF</filename>，然后用过如<filename>/WEB-INF/applicationContext-persist.xml</filename>的方式引用它们）。</para>
      </callout>

      <callout arearefs="coDef-spring-webx-2" id="coRef-spring-webx-2">
        <para><varname>log4jConfigLocation</varname>用来告诉<classname>Log4JConfigListener</classname>哪里去寻找Log4J日志配置。该例中，我们告诉Log4J在<filename>/WEB-INF/log4j.properties</filename>中寻找。</para>
      </callout>

      <callout arearefs="coDef-spring-webx-3" id="coRef-spring-webx-3">
        <para>这里确保当web应用启动的时候Log4J系统被配置。将<classname>Log4JConfigListener</classname>放在<classname>ContextLoaderListener</classname>前面十分重要；否则你可能丢失那些指向阻止应用启动问题的重要日志信息。如果你有一个特别大的Spring管理的bean集合，而其中一个碰巧在应用启动的时候出问题了，应用很可能会不能启动。如果你在Spring启动之前有了日志，你就有机会看到警告或错误信息。如果你在Spring启动之前没有配置日志，你就不知道为什么你的应用不能启动了。</para>
      </callout>

      <callout arearefs="coDef-spring-webx-4" id="coRef-spring-webx-4">
        <para><classname>ContextLoaderListener</classname>本质上是一个Spring容器。当应用启动的时候，这个监听器会根据<varname>contextConfigLocation</varname>参数构造一个<classname>ApplicationContext</classname>。</para>
      </callout>

      <callout arearefs="coDef-spring-webx-5" id="coRef-spring-webx-5">
        <para>我们定义一个名为<varname>weather</varname>的Spring <acronym>MVC</acronym>
        <classname>DispatcherServlet</classname>。这会让Spring从<filename>/WEB-INF/weather-servlet.xml</filename>寻找Spring配置文件。你可以拥有任意多的<classname>DispatcherServlet</classname>，一个<classname>DispatcherServlet</classname>可以包含一个或多个Spring
        <acronym>MVC</acronym> <classname>Controller</classname>实现。</para>
      </callout>

      <callout arearefs="coDef-spring-webx-6" id="coRef-spring-webx-6">
        <para>所有以<filename>.x</filename>结尾的请求都会被路由至<varname>weather</varname>
        servlet。注意<filename>.x</filename>扩展名没有任何特殊的意义，这是一个随意的选择，你可以使用任意你喜欢的<acronym>URL</acronym>模式。</para>
      </callout>
    </calloutlist>
  </section>

  <section id="sect-spring-running-web">
    <title>运行这个Web应用</title>

    <para>为了运行这个web应用，你首先需要使用Hibernate3插件<indexterm class="startofrange"
        id="enterprise7a">
        <primary>multimodule project (example)</primary>

        <secondary>multimodule enterprise project</secondary>

        <tertiary>running Web application</tertiary>
      </indexterm><indexterm class="startofrange" id="enterprise7b">
        <primary>Web applications</primary>

        <secondary>multimodule enterprise project example</secondary>

        <tertiary>running Web application</tertiary>
      </indexterm><indexterm class="startofrange" id="enterprise7c">
        <primary>enterprise project, multimodule (example)</primary>

        <secondary>running Web application</secondary>
      </indexterm><indexterm>
        <primary>Maven Hibernate3 plugin</primary>

        <secondary>building database using</secondary>
      </indexterm><indexterm>
        <primary>Hibernate3 plugin</primary>

        <secondary>building database using</secondary>
      </indexterm>构造数据库。为此，在项目<varname>simple-webapp</varname>目录下运行如下命令：</para>

    <screen>$ <command>mvn hibernate3:hbm2ddl</command>
[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'hibernate3'.
[INFO] org.codehaus.mojo: checking for updates from central
[INFO] ------------------------------------------------------------------------
[INFO] Building Chapter 7 Simple Web Application
[INFO]    task-segment: [hibernate3:hbm2ddl]
[INFO] ------------------------------------------------------------------------
[INFO] Preparing hibernate3:hbm2ddl
...
10:24:56,151  INFO org.hibernate.tool.hbm2ddl.SchemaExport - export complete
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
</screen>

    <para>在此之后，应该有一个<filename>${basedir}/data</filename>目录包含了HSQLDB数据库。你可以使用jetty启动web应用：</para>

    <screen>$ <command>mvn jetty:run</command>
[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'jetty'.
[INFO] ------------------------------------------------------------------------
[INFO] Building Chapter 7 Simple Web Application
[INFO]    task-segment: [jetty:run]
[INFO] ------------------------------------------------------------------------
[INFO] Preparing jetty:run
...
[INFO] [jetty:run]
[INFO] Configuring Jetty for project: Chapter 7 Simple Web Application
...
[INFO] Context path = /simple-webapp
[INFO] Tmp directory =  determined at runtime
[INFO] Web defaults = org/mortbay/jetty/webapp/webdefault.xml
[INFO] Web overrides =  none
[INFO] Starting jetty 6.1.7 ...
2008-03-25 10:28:03.639::INFO:  jetty-6.1.7
...
2147 INFO  DispatcherServlet  - FrameworkServlet 'weather': \
           initialization completed in 1654 ms
2008-03-25 10:28:06.341::INFO:  Started SelectChannelConnector@0.0.0.0:8080
[INFO] Started Jetty Server
</screen>

    <para>Jetty启动之后，你可以载入<ulink
    url="http://localhost:8080/simple-webapp/weather.x?zip=60202">http://localhost:8080/simple-webapp/weather.x?zip=60202</ulink>，然后就能在你的浏览器中看到Evanston,
    IL的天气。更改邮编后你就能看到你自己的天气报告了。</para>

    <screen>Current Weather Conditions for: Evanston, IL, US

    * Temperature: 42
    * Condition: Partly Cloudy
    * Humidity: 55
    * Wind Chill: 34
    * Date: Tue Mar 25 10:29:45 CDT 2008
</screen>
  </section>

  <section>
    <title>simple-command模块</title>

    <para><varname>simple-command</varname>项目是<varname>simple-webapp</varname>的一个命令行版本。这个命令行工具有这同样的模块依赖：<varname>simple-persist</varname>和<varname>simple-weather</varname>。现在你需要从命令行运行这个<classname>simple-command</classname>工具，而非通过web浏览器与该应用交互。</para>

    <figure>
      <title>引用 simple-weather 和 simple-persist 的命令行应用</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="figs/web/multimodule-web-command-spring.png"
                     scalefit="1" width="6in" />
        </imageobject>
      </mediaobject>
    </figure>

    <example>
      <title>simple-command 的 POM</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
    &lt;artifactId&gt;simple-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
  &lt;/parent&gt;

  &lt;artifactId&gt;simple-command&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;name&gt;Simple Command Line Tool&lt;/name&gt;

  &lt;build&gt;
    &lt;finalName&gt;${project.artifactId}&lt;/finalName&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;source&gt;1.5&lt;/source&gt;
          &lt;target&gt;1.5&lt;/target&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;testFailureIgnore&gt;true&lt;/testFailureIgnore&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
      &lt;plugin&gt;
       &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;descriptorRefs&gt;
            &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;
          &lt;/descriptorRefs&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
        &lt;artifactId&gt;hibernate3-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.1&lt;/version&gt;
        &lt;configuration&gt;
          &lt;components&gt;
            &lt;component&gt;
              &lt;name&gt;hbm2ddl&lt;/name&gt;
              &lt;implementation&gt;annotationconfiguration&lt;/implementation&gt;
            &lt;/component&gt;
          &lt;/components&gt;
        &lt;/configuration&gt;
        &lt;dependencies&gt;
          &lt;dependency&gt;
            &lt;groupId&gt;hsqldb&lt;/groupId&gt;
            &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;
            &lt;version&gt;1.8.0.7&lt;/version&gt;
          &lt;/dependency&gt;
        &lt;/dependencies&gt;           
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
      &lt;artifactId&gt;simple-weather&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
      &lt;artifactId&gt;simple-persist&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring&lt;/artifactId&gt;
      &lt;version&gt;2.0.7&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;hsqldb&lt;/groupId&gt;
      &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;
      &lt;version&gt;1.8.0.7&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</programlisting>
    </example>

    <para>这个<acronym>POM</acronym>创建一个包含了如<xref
    linkend="ex-spring-command-main-class" />所示的<classname>org.sonatype.mavenbook.weather.Main</classname>类的<acronym>JAR</acronym>文件。在这个<acronym>POM</acronym>中我们配置了Maven
    Assembly插件使用内置的名为<varname>jar-with-dependencies</varname>的装配描述符来创建一个<acronym>JAR</acronym>文件，该文件包含了运行应用所需要的所有二进制代码，包括项目本身的字节码以及所有依赖文件的字节码。</para>

    <example id="ex-spring-command-main-class">
      <title>simple-command 的 Main 类</title>

      <programlisting language="java">package org.sonatype.mavenbook.weather;

import java.util.List;

import org.apache.log4j.PropertyConfigurator;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import org.sonatype.mavenbook.weather.model.Location;
import org.sonatype.mavenbook.weather.model.Weather;
import org.sonatype.mavenbook.weather.persist.LocationDAO;
import org.sonatype.mavenbook.weather.persist.WeatherDAO;

public class Main {

  private WeatherService weatherService;
  private WeatherDAO weatherDAO;
  private LocationDAO locationDAO;

  public static void main(String[] args) throws Exception {
    // Configure Log4J
    PropertyConfigurator.configure(Main.class.getClassLoader().getResource(
        "log4j.properties"));

    // Read the Zip Code from the Command-line (if none supplied, use 60202)
    String zipcode = "60202";
    try {
      zipcode = args[0];
    } catch (Exception e) {
    }

    // Read the Operation from the Command-line (if none supplied use weather)
    String operation = "weather";
    try {
      operation = args[1];
    } catch (Exception e) {
    }

    // Start the program
    Main main = new Main(zipcode);

    ApplicationContext context = 
      new ClassPathXmlApplicationContext(
        new String[] { "classpath:applicationContext-weather.xml",
                       "classpath:applicationContext-persist.xml" });
    main.weatherService = (WeatherService) context.getBean("weatherService");
    main.locationDAO = (LocationDAO) context.getBean("locationDAO");
    main.weatherDAO = (WeatherDAO) context.getBean("weatherDAO");
    if( operation.equals("weather")) {
      main.getWeather();
    } else {
      main.getHistory();
    }
  }

  private String zip;

  public Main(String zip) {
    this.zip = zip;
  }

  public void getWeather() throws Exception {
    Weather weather = weatherService.retrieveForecast(zip);
    weatherDAO.save( weather );
    System.out.print(new WeatherFormatter().formatWeather(weather));
  }

  public void getHistory() throws Exception {
    Location location = locationDAO.findByZip(zip);
    List&lt;Weather&gt; weathers = weatherDAO.recentForLocation(location);
    System.out.print(new WeatherFormatter().formatHistory(location, weathers));
  }
}
</programlisting>
    </example>

    <para>这个<classname>Main</classname>类有对于<classname>WeatherDAO</classname>,
    <classname>LocationDAO</classname>, 以及
    <classname>WeatherService</classname>的引用。该类的静态<methodname>main()</methodname>方法：</para>

    <itemizedlist>
      <listitem>
        <para>从第一个命令行参数读取邮编。</para>
      </listitem>

      <listitem>
        <para>从第二个命令行参数读取操作。如果操作是“weather”，最新的天气将会从web服务获得。如果操作是“history”，该程序会从本地数据库获取历史天气记录。</para>
      </listitem>

      <listitem>
        <para>根据来自于<varname>simple-persist</varname>和<varname>simple-weather</varname>的两个<acronym>XML</acronym>文件载入Spring
        <classname>ApplicationContext</classname>。</para>
      </listitem>

      <listitem>
        <para>创建一个<classname>Main</classname>的实例。</para>
      </listitem>

      <listitem>
        <para>使用来自于Spring
        <classname>ApplicationContext</classname>的bean填充<varname>weatherService</varname>,
        <varname>weatherDAO</varname>, 和
        <varname>locationDAO</varname>。</para>
      </listitem>

      <listitem>
        <para>根据特定的操作运行相应的<methodname>getWeather()</methodname>或者<methodname>getHistory()</methodname>方法。</para>
      </listitem>
    </itemizedlist>

    <para>在web应用中我们使用Spring
    <classname>VelocityViewResolver</classname>来呈现一个Velocity模板。在这个单机实现中给我们需要编写一个简单的类来通过Velocity模板呈现天气数据。<xref
    linkend="ex-spring-weather-formatter" />是<classname>WeatherFormatter</classname>的代码清单，这个类有两个方法来呈现天气报告和天气历史信息。</para>

    <example id="ex-spring-weather-formatter">
      <title>WeatherFormatter 使用 Velocity 模板呈现天气数据</title>

      <programlisting language="java">package org.sonatype.mavenbook.weather;

import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StringWriter;
import java.util.List;

import org.apache.log4j.Logger;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.Velocity;

import org.sonatype.mavenbook.weather.model.Location;
import org.sonatype.mavenbook.weather.model.Weather;

public class WeatherFormatter {

  private static Logger log = Logger.getLogger(WeatherFormatter.class);

  public String formatWeather( Weather weather ) throws Exception {
    log.info( "Formatting Weather Data" );
    Reader reader = 
      new InputStreamReader( getClass().getClassLoader().
                                 getResourceAsStream("weather.vm"));
    VelocityContext context = new VelocityContext();
    context.put("weather", weather );
    StringWriter writer = new StringWriter();
    Velocity.evaluate(context, writer, "", reader);
    return writer.toString();
  }

  public String formatHistory( Location location, List&lt;Weather&gt; weathers )  
        throws Exception {
    log.info( "Formatting History Data" );
    Reader reader = 
      new InputStreamReader( getClass().getClassLoader().
                                 getResourceAsStream("history.vm"));
    VelocityContext context = new VelocityContext();
    context.put("location", location );
    context.put("weathers", weathers );
    StringWriter writer = new StringWriter();
    Velocity.evaluate(context, writer, "", reader);
    return writer.toString();
  }
}
</programlisting>
    </example>

    <para><filename>weather.vm</filename>模板简单的打印邮编对应的城市，国家，区域以及当前的气温。<filename>history.vm</filename>模板打印位置信息并遍历存储在本地数据库中的天气预报记录。两者都位于<filename>${basedir}/src/main/resources</filename>。</para>

    <example>
      <title>weather.vm Velocity 模板</title>

      <programlisting language="java">****************************************
Current Weather Conditions for:
  ${weather.location.city},
  ${weather.location.region},
  ${weather.location.country}
****************************************

 * Temperature: ${weather.condition.temp}
 * Condition: ${weather.condition.text}
 * Humidity: ${weather.atmosphere.humidity}
 * Wind Chill: ${weather.wind.chill}
 * Date: ${weather.date}
</programlisting>
    </example>

    <example>
      <title>history.vm Velocity 模板</title>

      <para><programlisting>Weather History for:
${location.city},
${location.region},
${location.country}


#foreach( $weather in $weathers )
****************************************
 * Temperature: $weather.condition.temp
 * Condition: $weather.condition.text
 * Humidity: $weather.atmosphere.humidity
 * Wind Chill: $weather.wind.chill
 * Date: $weather.date
#end</programlisting></para>
    </example>
  </section>

  <section>
    <title>运行这个命令行程序</title>

    <para><varname>simple-command</varname>项目被配置成创建一个单独的包含项目本身字节码以及所有依赖字节码的<acronym>JAR</acronym>文件。要创建这个装配制品，从<varname>simple-command</varname>项目目录运行Maven
    Assembly插件的<varname>assembly</varname>目标：</para>

    <screen>$ <command>mvn assembly:assembly</command>
[INFO] ------------------------------------------------------------------------
[INFO] Building Chapter 7 Simple Command Line Tool
[INFO]    task-segment: [assembly:assembly] (aggregator-style)
[INFO] ------------------------------------------------------------------------
[INFO] [resources:resources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:compile]
[INFO] Nothing to compile - all classes are up to date
[INFO] [resources:testResources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:testCompile]
[INFO] Nothing to compile - all classes are up to date
[INFO] [surefire:test]
...
[INFO] [jar:jar]
[INFO] Building jar: .../simple-parent/simple-command/target/simple-command.jar
[INFO] [assembly:assembly]
[INFO] Processing DependencySet (output=)
[INFO] Expanding: .../.m2/repository/.../simple-weather-1-SNAPSHOT.jar into \
                                                        /tmp/archived-file-set.93251505.tmp
[INFO] Expanding: .../.m2/repository/.../simple-model-1-SNAPSHOT.jar into \
                                                        /tmp/archived-file-set.2012480870.tmp
[INFO] Expanding: .../.m2/repository/../hibernate-3.2.5.ga.jar into \
                                                        /tmp/archived-file-set.1296516202.tmp
... skipping 25 lines of dependency unpacking ...
[INFO] Expanding: .../.m2/repository/.../velocity-1.5.jar into /tmp/archived-file-set.379482226.tmp
[INFO] Expanding: .../.m2/repository/.../commons-lang-2.1.jar into \
                                                        /tmp/archived-file-set.1329200163.tmp
[INFO] Expanding: .../.m2/repository/.../oro-2.0.8.jar into /tmp/archived-file-set.1993155327.tmp
[INFO] Building jar: .../simple-parent/simple-command/target/simple-command-jar-with-dependencies.jar
</screen>

    <para>构建过程经过了生命周期中编译字节码，运行测试，然后最终为该项目构建一个<acronym>JAR</acronym>。然后<varname>assembly:assembly</varname>目标创建一个带有依赖的<acronym>JAR</acronym>，它将所有依赖解压到一个临时目录，然后将所有字节码收集到<filename>target/</filename>目录下一个名为<filename>simple-command-jar-with-dependencies.jar</filename>的<acronym>JAR</acronym>中。这个“超级的”<acronym>JAR的</acronym>体重为15MB。</para>

    <para>在你运行这个命令行工具之前，你需要调用Hibernate3插件的<varname>hbm2ddl</varname>目标来创建HSQLDB数据库。在<varname>simple-command</varname>目录运行如下的命令：</para>

    <para><screen>$ <command>mvn hibernate3:hbm2ddl</command>
[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'hibernate3'.
[INFO] org.codehaus.mojo: checking for updates from central
[INFO] ------------------------------------------------------------------------
[INFO] Building Chapter 7 Simple Command Line Tool
[INFO]    task-segment: [hibernate3:hbm2ddl]
[INFO] ------------------------------------------------------------------------
[INFO] Preparing hibernate3:hbm2ddl
...
10:24:56,151  INFO org.hibernate.tool.hbm2ddl.SchemaExport - export complete
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
</screen></para>

    <para>在此之后，你应该能在<varname>simple-command</varname>下看到<filename>data/</filename>目录。该<filename>data/</filename>目录包含了HSQLDB数据库。要运行这个命令行天气预报器，在<filename>simple-command/</filename>项目目录下运行如下命令：</para>

    <screen>$ <command>java -cp target/simple-command-jar-with-dependencies.jar \
           org.sonatype.mavenbook.weather.Main 60202</command>
2321 INFO  YahooRetriever  - Retrieving Weather Data
2489 INFO  YahooParser  - Creating XML Reader
2581 INFO  YahooParser  - Parsing XML Response
2875 INFO  WeatherFormatter  - Formatting Weather Data
****************************************
Current Weather Conditions for:
  Evanston, 
  IL, 
  US
****************************************
  
 * Temperature: 75
 * Condition: Partly Cloudy
 * Humidity: 64
 * Wind Chill: 75
 * Date: Wed Aug 06 09:35:30 CDT 2008
</screen>

    <para>要运行历史查询，运行如下命令：</para>

    <screen>$ <command>java -cp target/simple-command-jar-with-dependencies.jar \
           org.sonatype.mavenbook.weather.Main 60202 history</command>
2470 INFO  WeatherFormatter  - Formatting History Data
Weather History for: 
Evanston, IL, US
  
****************************************
 * Temperature: 39
 * Condition: Heavy Rain
 * Humidity: 93
 * Wind Chill: 36
 * Date: 2007-12-02 13:45:27.187
****************************************
 * Temperature: 75
 * Condition: Partly Cloudy
 * Humidity: 64
 * Wind Chill: 75
 * Date: 2008-08-06 09:24:11.725
****************************************
 * Temperature: 75
 * Condition: Partly Cloudy
 * Humidity: 64
 * Wind Chill: 75
 * Date: 2008-08-06 09:27:28.475 </screen>
  </section>

  <section>
    <title>小结</title>

    <para>到目前为止我们花了大量时间在一些不是和Maven直接相关的话题上。这么做是为了演示一些完整的并且有意义的样例项目，以能让你用来帮助实现你的现实系统。我们并没有走任何捷径来快速生成完好的结果，也没有使用Ruby
    on
    Rails式样的东西让你感到惊讶目眩，说你可以在“简单的10分钟内！”创建并完成一个Java企业级应用。市场上这样的东西太多了，有太多的人试图卖给你最简单的框架，又只需要你投入零的时间关注。本章我们想要做的是展现给你整个的画面，整个多模块构建的生态系统。这里我们展现的Maven处于一个你能经常看到的自然应用的上下文中——不是快餐式的，10分钟的简单介绍，往Apache
    Ant扔烂泥，说服你采用Apache Maven。</para>

    <para>如果你离开本章，想知道它到底和Maven有什么关系，那么我们就成功了。我们演示了一个复杂的项目集合，使用了流行的框架，并且使用声明式构建将它们绑在了一起。事实上本章60%以上的内容是在解释Spring和Hibernate，而大部分时间，Maven暂时离开了。这样是可行的。它让你集中注意力于应用本身，而非构建过程。我们专门的来讨论那些在这个人造项目中用到的技术，而不是花时间讨论Maven，以及那些为了“构建一个集成了Spring和Hibernate的构建”你必须做的工作。如果你开始使用Maven，并且花时间学习它，你肯定会开始获益，因为你不需要花时间去编写一些程式化的构建脚本。你不用再花时间去考虑构建中那些平常的方面。</para>

    <para>你可以使用本章介绍的骨架项目作为你自己项目的基础，这么做的机会是，你会发现，你会根据需要创建越来越多的模块。例如，基于本章样例的项目可能有两个单独的模型模块，两个持久化模块以将数据持久化到不同数据库，一些web应用，以及一个Java手机应用。总的来说，这个现实系统包含了15个相关的模块。重点是，你已经看到了本书中最复杂的多模块样例，但你应该知道该样例也仅仅触及了所有Maven可能性的表面。</para>

    <section>
      <title>编写接口项目程序</title>

      <para>本章展现了一个多模块项目，该项目比<xref
      linkend="multimodule" />中展示的简单样例复杂得多，然而它也只是现实项目的一个简化。在大型项目中，你可能发现你正构建一个如<xref
      linkend="fig-multimodule-web-spring-projects-complex" />的系统。</para>

      <figure id="fig-multimodule-web-spring-projects-complex">
        <title>编写接口项目程序</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="figs/web/multimodule-web-spring_projects-complex.png"
                       scalefit="1" width="7in" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>当我们使用术语接口项目的时候，我们是指一个只包含了接口和常量的Maven项目。在<xref
      linkend="fig-multimodule-web-spring-projects-complex" />中，接口项目是<varname>persist-api</varname>和<varname>parse-api</varname>。如果<varname>big-command</varname>和<varname>big-webapp</varname>针对于<varname>persist-api</varname>中定义的接口编写，那么它就能很容易的切换到另一种持久化类库的实现。该图显示了两个<varname>persist-api</varname>项目的实现，一个将数据存储于<acronym>XML</acronym>数据库，另一个将数据存储于关系数据库。如果你使用本章中的一些概念，你就能看到如何仅仅通过传入一个标记，让程序换入一个不同的Spring
      application context
      <acronym>XML</acronym>文件，换出持久化实现的数据源。就像应用程序本身的OO设计一样，通常将接口Maven项目从实现Maven项目中分离是一种很明智的做法。</para>
    </section>
  </section>
</chapter>
